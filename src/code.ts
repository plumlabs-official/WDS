/**
 * Wellwe Design System Automator
 *
 * Figma 플러그인 메인 엔트리
 * - Auto Layout 적용
 * - 간격 표준화
 * - 네이밍 자동화
 * - 컴포넌트화
 * - Agent Server 연동 (LLM 기반 분석)
 */

// Rule-based Auto Layout은 삭제됨 - AI Auto Layout만 사용

import {
  standardizeSelectionSpacing,
} from './modules/spacing';

import {
  cleanupSelectionWrappers,
  flattenSelectionSameNameWrappers,
} from './modules/cleanup';

import {
  shouldSkipNaming,
  isIconLibraryName,
  convertIconLibraryToWDS,
  isKoreanLabel,
  convertKoreanLabel,
  isHyphenIconPattern,
  convertHyphenIconToWDS,
  isInTabbarContext,
  isIconStateContainer,
  isCamelCase,
  convertCamelCaseToPascalCase,
  inferTabItemNameFromIcon,
  isGenericName,
  inferSectionNameFromChildren,
  inferLayoutName,
  shouldSkipForParentComponent,
  tryStructuralNaming,
  isTopLevelScreenFrame,
  cleanScreenName,
  resolveSiblingDuplicates,
  makeUniqueSiblingName,
  isAutoGeneratedName,
  inferNameForAutoGenerated,
  isBlacklistedName,
} from './modules/naming';

import {
  componentizeSelection,
} from './modules/componentize';

/**
 * 유효한 시맨틱 컴포넌트 타입 목록
 * - 이 목록에 없는 타입으로 시작하는 이름은 AI 재분석 대상
 */
const VALID_SEMANTIC_TYPES = [
  // 최상위
  'Screen',
  // 구조 컨테이너 (Layout, Content 금지!)
  'TopBar', 'TabBar', 'Section', 'Container',
  // UI 컴포넌트
  'Card', 'Button', 'Input', 'Avatar', 'Icon', 'Image', 'ListItem', 'TabItem',
  'Badge', 'Tag', 'Header', 'Toggle', 'Checkbox', 'ProgressBar',
  'Timer', 'HomeIndicator', 'Frame',
  // 피드백
  'Toast', 'Modal', 'Snackbar', 'Overlay',
  // 로딩
  'Skeleton', 'Spinner',
];

/**
 * 유효한 시맨틱 이름인지 확인
 * - '/'가 포함되어야 함
 * - 첫 번째 부분이 VALID_SEMANTIC_TYPES에 있어야 함
 */
function hasValidSemanticName(name: string): boolean {
  if (!name.includes('/')) return false;

  const firstPart = name.split('/')[0];
  return VALID_SEMANTIC_TYPES.includes(firstPart);
}

// 현재 명령어 가져오기
const command = figma.command;

// 항상 UI 열기 (플로팅 패널)
figma.showUI(__html__, {
  width: 300,
  height: 520,
  themeColors: true,
  title: 'Design System Automator',
});

// UI에서 오는 메시지 처리
figma.ui.onmessage = handleUIMessage;

// 메뉴에서 직접 명령어 실행한 경우 처리
if (command && command !== 'open-ui') {
  handleCommandWithUI(command);
}

/**
 * 명령어 처리 (UI 유지)
 */
function handleCommandWithUI(cmd: string) {
  switch (cmd) {
    // apply-autolayout은 삭제됨 - apply-autolayout-agent 사용

    case 'standardize-spacing':
      handleStandardizeSpacing();
      break;

    case 'cleanup-wrappers':
      handleCleanupWrappers();
      break;

    case 'flatten-same-name':
      handleFlattenSameName();
      break;

    case 'detach-components':
      handleDetachComponents();
      break;

    case 'delete-hidden-layers':
      handleDeleteHiddenLayers();
      break;

    case 'confirm-delete-hidden':
      confirmDeleteHiddenLayers();
      break;

    case 'cancel-delete-hidden':
      cancelDeleteHiddenLayers();
      break;

    // auto-naming은 삭제됨 - auto-naming-agent 사용

    case 'componentize':
      handleComponentize();
      break;

    case 'componentize-convert':
      handleComponentizeConvert();
      break;

    case 'run-all':
      handleRunAll();
      break;

    case 'apply-autolayout-agent':
      handleAutoLayoutAgent();
      break;

    case 'auto-naming-agent':
      handleNamingAgent();
      break;

    case 'run-all-agent':
      handleRunAllAgent();
      break;

    default:
      figma.notify('알 수 없는 명령입니다.', { error: true });
  }
}

// Agent 결과 타입 정의
interface NamingResultMessage {
  type: 'naming-result';
  success?: boolean;
  data?: {
    suggestedName: string;
    componentType?: string;
    confidence?: number;
    reasoning?: string;
  };
  error?: string;
}

interface NamingBatchResultMessage {
  type: 'naming-batch-result';
  success?: boolean;
  results?: Array<{
    success?: boolean;
    data?: { suggestedName: string };
  }>;
  error?: string;
}

interface NamingContextResultMessage {
  type: 'naming-context-result';
  success?: boolean;
  data?: {
    results: Array<{
      nodeId: string;
      suggestedName: string;
      componentType: string;
      variant?: string;
      size?: string;
      confidence: number;
      reasoning: string;
    }>;
  };
  error?: string;
}

interface ChildSizing {
  index: number;
  layoutAlign: 'INHERIT' | 'STRETCH';
  layoutGrow: 0 | 1;
  reasoning?: string;
}

interface AutoLayoutResultMessage {
  type: 'autolayout-result';
  success?: boolean;
  data?: {
    direction: string;
    gap: number;
    paddingTop?: number;
    paddingRight?: number;
    paddingBottom?: number;
    paddingLeft?: number;
    primaryAxisSizing?: 'HUG' | 'FIXED';
    counterAxisSizing?: 'HUG' | 'FIXED';
    childrenSizing?: ChildSizing[];
    reasoning?: string;
  };
  error?: string;
}

type UIMessage =
  | { type: string }
  | NamingResultMessage
  | NamingBatchResultMessage
  | AutoLayoutResultMessage;

/**
 * UI 메시지 핸들러
 */
async function handleUIMessage(msg: UIMessage) {
  // confirm-delete-hidden은 selectedIds 포함하므로 특별 처리
  if (msg.type === 'confirm-delete-hidden') {
    const selectedIds = (msg as { type: string; selectedIds?: string[] }).selectedIds;
    confirmDeleteHiddenLayers(selectedIds);
    return;
  }

  // 체크박스 변경 시 Figma 선택 상태 동기화
  if (msg.type === 'update-hidden-selection') {
    const selectedIds = (msg as { type: string; selectedIds?: string[] }).selectedIds || [];
    updateHiddenLayerSelection(selectedIds);
    return;
  }

  // 기존 명령어 (Rule-based)
  if (!msg.type.endsWith('-agent') && !msg.type.startsWith('agent-') && !msg.type.endsWith('-result')) {
    handleCommandWithUI(msg.type);
    return;
  }

  // Agent 관련 명령어
  switch (msg.type) {
    case 'apply-autolayout-agent':
      await handleAutoLayoutAgent();
      break;

    case 'auto-naming-agent':
      await handleNamingAgent();
      break;

    case 'run-all-agent':
      await handleRunAllAgent();
      break;

    case 'naming-result':
      handleNamingResult(msg as NamingResultMessage);
      break;

    case 'naming-batch-result':
      handleNamingBatchResult(msg as NamingBatchResultMessage);
      break;

    case 'naming-context-result':
      handleNamingContextResult(msg as NamingContextResultMessage);
      break;

    case 'autolayout-result':
      handleAutoLayoutResult(msg as AutoLayoutResultMessage);
      break;
  }
}

// Rule-based handleApplyAutoLayout은 삭제됨 - AI Auto Layout만 사용

/**
 * 의미 없는 래퍼 제거 핸들러
 */
function handleCleanupWrappers() {
  figma.ui.postMessage({ type: 'task-start', taskName: '래퍼 제거 중...' });

  try {
    const result = cleanupSelectionWrappers();

    if (result.details && result.details.removedCount > 0) {
      console.log('=== 래퍼 제거 결과 ===');
      for (const name of result.details.removedNames) {
        console.log(`  - ${name}`);
      }
    }

    figma.notify(result.message, {
      timeout: 3000,
      error: !result.success,
    });
  } catch (e) {
    figma.notify(`오류: ${e}`, { error: true });
  }

  figma.ui.postMessage({ type: 'task-complete' });
}

/**
 * 동일 이름 중첩 레이어 병합 핸들러 (AI 검증 포함)
 */
async function handleFlattenSameName() {
  figma.ui.postMessage({ type: 'task-start', taskName: '중첩 레이어 병합 중 (AI 검증)...' });

  try {
    const result = await flattenSelectionSameNameWrappers(true);

    if (result.details && result.details.flattenedCount > 0) {
      console.log('=== 중첩 레이어 병합 결과 ===');
      for (const name of result.details.flattenedNames) {
        console.log(`  - ${name}`);
      }
      if (result.details.aiValidatedCount > 0) {
        console.log(`AI 검증: ${result.details.aiValidatedCount}개`);
      }
    }

    figma.notify(result.message, {
      timeout: 3000,
      error: !result.success,
    });
  } catch (e) {
    figma.notify(`오류: ${e}`, { error: true });
  }

  figma.ui.postMessage({ type: 'task-complete' });
}

/**
 * 컴포넌트 브레이크 (일반 프레임으로 전환)
 * - detachInstance() 후 원래 인스턴스 크기 유지
 * - 모든 자식 노드도 함께 스케일링
 */
function handleDetachComponents() {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('프레임을 선택해주세요.', { error: true });
    return;
  }

  figma.ui.postMessage({ type: 'task-start', taskName: '컴포넌트 브레이크 중...' });

  let detachedCount = 0;
  let scaledCount = 0;
  let cleanedCount = 0;

  /**
   * 부모보다 큰 보조 레이어 정리 및 크기 초과 자식 스케일링
   * - Ratio, Constraints 등 반응형 보조 레이어 제거
   * - 부모 bounds를 초과하는 빈 프레임 제거
   * - 원본 크기를 초과하는 자식은 스케일링
   */
  function cleanupAndScaleOversizedChildren(parent: FrameNode, targetWidth: number, targetHeight: number): { removed: number; scaled: number } {
    let removed = 0;
    let scaled = 0;

    // 보조 레이어 이름 패턴 (삭제 대상)
    const auxiliaryPatterns = ['Ratio', 'Constraints', 'Spacer', 'Placeholder'];

    // children 복사본으로 순회 (삭제 중 변경되므로)
    for (const child of [...parent.children]) {
      // 1. 보조 레이어 이름 패턴 체크
      const isAuxiliaryLayer = auxiliaryPatterns.some(pattern =>
        child.name === pattern || child.name.startsWith(pattern + '/')
      );

      // 2. 원본 크기 초과 여부 체크 (targetWidth/Height 기준)
      const exceedsTarget = child.width > targetWidth + 2 || child.height > targetHeight + 2;

      // 3. 빈 프레임 여부 체크 (자식 없고 스타일 없음)
      let isEmptyFrame = false;
      if (child.type === 'FRAME') {
        const frame = child as FrameNode;
        const hasChildren = frame.children.length > 0;
        const fills = frame.fills;
        const hasFills = Array.isArray(fills) && fills.length > 0 &&
                        fills.some(f => f.visible !== false);
        const hasStrokes = frame.strokes.length > 0;
        isEmptyFrame = !hasChildren && !hasFills && !hasStrokes;
      }

      // 보조 레이어이면서 타겟 초과하면 삭제
      if (isAuxiliaryLayer && exceedsTarget) {
        console.log(`[Cleanup] 보조 레이어 삭제: ${child.name} (${child.width}x${child.height} > ${targetWidth}x${targetHeight})`);
        child.remove();
        removed++;
        continue;
      }

      // 빈 프레임이면서 타겟 초과하면 삭제
      if (isEmptyFrame && exceedsTarget) {
        console.log(`[Cleanup] 빈 프레임 삭제: ${child.name} (${child.width}x${child.height})`);
        child.remove();
        removed++;
        continue;
      }

      // 타겟 크기를 초과하는 일반 자식은 스케일링
      if (exceedsTarget && 'resize' in child) {
        const scaleX = child.width > targetWidth ? targetWidth / child.width : 1;
        const scaleY = child.height > targetHeight ? targetHeight / child.height : 1;
        const scale = Math.min(scaleX, scaleY); // 비율 유지를 위해 작은 값 사용

        console.log(`[Cleanup] 크기 초과 자식 스케일링: ${child.name} (${child.width}x${child.height} → scale ${scale.toFixed(3)})`);

        // 스케일링 적용
        scaleNodeRecursively(child, scale, scale);
        scaled++;
      }

      // 재귀적으로 자식도 정리 (타겟 크기는 자식 기준으로)
      if (child.type === 'FRAME' && 'children' in child) {
        const childResult = cleanupAndScaleOversizedChildren(
          child as FrameNode,
          child.width,
          child.height
        );
        removed += childResult.removed;
        scaled += childResult.scaled;
      }
    }

    return { removed, scaled };
  }

  /**
   * 노드와 모든 자식을 스케일링 (constraints 해제 포함)
   */
  function scaleNodeRecursively(node: SceneNode, scaleX: number, scaleY: number): void {
    // constraints 해제 (프레임인 경우)
    if (node.type === 'FRAME') {
      const frame = node as FrameNode;
      // Auto Layout 해제
      if (frame.layoutMode !== 'NONE') {
        frame.layoutMode = 'NONE';
      }
    }

    // 위치 스케일링
    if ('x' in node) {
      node.x = node.x * scaleX;
      node.y = node.y * scaleY;
    }

    // 크기 스케일링 (resize 가능한 노드만)
    if ('resize' in node) {
      const newWidth = node.width * scaleX;
      const newHeight = node.height * scaleY;
      if (newWidth > 0.01 && newHeight > 0.01) {
        try {
          (node as FrameNode).resize(newWidth, newHeight);
        } catch (e) {
          console.log(`[Scale] resize 실패: ${node.name}`, e);
        }
      }
    }

    // 자식이 있으면 재귀 처리
    if ('children' in node) {
      for (const child of [...(node as FrameNode).children]) {
        scaleNodeRecursively(child, scaleX, scaleY);
      }
    }
  }

  function detachRecursively(node: SceneNode): void {
    // 인스턴스인 경우 detach
    if (node.type === 'INSTANCE') {
      try {
        // 1. 원래 크기/위치/clipsContent 저장
        const originalWidth = node.width;
        const originalHeight = node.height;
        const originalX = node.x;
        const originalY = node.y;
        const originalClipsContent = node.clipsContent;

        console.log(`[Detach] 시작: ${node.name} (원래 크기: ${originalWidth}x${originalHeight}, clips: ${originalClipsContent})`);

        // 2. detachInstance()는 새 FrameNode를 반환
        const detachedFrame = node.detachInstance();
        detachedCount++;

        console.log(`[Detach] 완료: ${detachedFrame.name} (detach 후 크기: ${detachedFrame.width}x${detachedFrame.height})`);

        // 3. 크기가 변경되었으면 스케일링으로 복원
        if (detachedFrame) {
          const widthDiff = Math.abs(detachedFrame.width - originalWidth);
          const heightDiff = Math.abs(detachedFrame.height - originalHeight);

          if (widthDiff > 1 || heightDiff > 1) {
            const scaleX = originalWidth / detachedFrame.width;
            const scaleY = originalHeight / detachedFrame.height;

            console.log(`[Detach] 스케일링 필요: ${detachedFrame.name} (scale: ${scaleX.toFixed(3)}x${scaleY.toFixed(3)})`);

            // 프레임 Auto Layout 먼저 해제
            if (detachedFrame.layoutMode !== 'NONE') {
              console.log(`[Detach] Auto Layout 해제: ${detachedFrame.layoutMode}`);
              detachedFrame.layoutMode = 'NONE';
            }

            // 모든 자식 노드 스케일링
            for (const child of [...detachedFrame.children]) {
              scaleNodeRecursively(child, scaleX, scaleY);
            }

            // 프레임 자체 크기 조정
            try {
              detachedFrame.resize(originalWidth, originalHeight);
              console.log(`[Detach] 프레임 resize 완료: ${detachedFrame.width}x${detachedFrame.height}`);
              scaledCount++;
            } catch (e) {
              console.error(`[Detach] 프레임 resize 실패:`, e);
            }
          }

          // 위치 복원
          detachedFrame.x = originalX;
          detachedFrame.y = originalY;

          // clipsContent 복원 (중요: 자식이 부모보다 클 때 잘리도록)
          if (originalClipsContent !== undefined) {
            detachedFrame.clipsContent = originalClipsContent;
            console.log(`[Detach] clipsContent 복원: ${originalClipsContent}`);
          }

          // 원본 크기 기준으로 보조 레이어 정리 및 크기 초과 자식 스케일링
          // Auto Layout 먼저 해제 (HUG 방지)
          if (detachedFrame.layoutMode !== 'NONE') {
            console.log(`[Detach] Cleanup 전 Auto Layout 해제: ${detachedFrame.layoutMode}`);
            detachedFrame.layoutMode = 'NONE';
          }

          const cleanupResult = cleanupAndScaleOversizedChildren(detachedFrame, originalWidth, originalHeight);
          if (cleanupResult.removed > 0) {
            cleanedCount += cleanupResult.removed;
            console.log(`[Detach] ${cleanupResult.removed}개 보조 레이어 정리됨`);
          }
          if (cleanupResult.scaled > 0) {
            scaledCount += cleanupResult.scaled;
            console.log(`[Detach] ${cleanupResult.scaled}개 자식 스케일링됨`);
          }

          // 최종 크기 검증 및 복원
          const finalWidth = detachedFrame.width;
          const finalHeight = detachedFrame.height;
          if (Math.abs(finalWidth - originalWidth) > 1 || Math.abs(finalHeight - originalHeight) > 1) {
            console.log(`[Detach] 최종 크기 복원: ${finalWidth}x${finalHeight} → ${originalWidth}x${originalHeight}`);
            try {
              detachedFrame.resize(originalWidth, originalHeight);
            } catch (e) {
              console.error(`[Detach] 최종 resize 실패:`, e);
            }
          }

          // 반환된 프레임의 자식들도 재귀 탐색 (중첩 인스턴스 처리)
          if ('children' in detachedFrame) {
            for (const child of [...detachedFrame.children]) {
              detachRecursively(child);
            }
          }
        }
        return; // 이미 자식 처리했으므로 종료
      } catch (e) {
        console.error('Detach failed:', node.name, e);
      }
    }

    // 자식이 있으면 재귀 처리
    if ('children' in node) {
      for (const child of [...node.children]) {
        detachRecursively(child);
      }
    }
  }

  for (const node of selection) {
    detachRecursively(node);
  }

  if (detachedCount > 0) {
    let msg = `${detachedCount}개 인스턴스 전환`;
    if (scaledCount > 0) {
      msg += `, ${scaledCount}개 크기 복원`;
    }
    if (cleanedCount > 0) {
      msg += `, ${cleanedCount}개 보조 레이어 정리`;
    }
    figma.notify(msg, { timeout: 3000 });
  } else {
    figma.notify('전환할 컴포넌트 인스턴스가 없습니다.', { timeout: 3000 });
  }

  figma.ui.postMessage({ type: 'task-complete' });
}

// 꺼진 레이어 저장용
let pendingHiddenLayers: SceneNode[] = [];

/**
 * 꺼진 레이어 삭제 (확인 후)
 */
function handleDeleteHiddenLayers() {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('프레임을 선택해주세요.', { error: true });
    return;
  }

  const hiddenLayers: SceneNode[] = [];

  function findHiddenLayers(node: SceneNode) {
    if (!node.visible) {
      hiddenLayers.push(node);
      return; // 숨겨진 노드의 자식은 탐색하지 않음
    }

    if ('children' in node) {
      for (const child of node.children) {
        findHiddenLayers(child);
      }
    }
  }

  for (const node of selection) {
    findHiddenLayers(node);
  }

  if (hiddenLayers.length === 0) {
    figma.notify('꺼진 레이어가 없습니다.', { timeout: 3000 });
    return;
  }

  // 꺼진 레이어 임시로 켜서 보여주기
  for (const layer of hiddenLayers) {
    layer.visible = true;
  }

  // 선택해서 보여주기
  figma.currentPage.selection = hiddenLayers;
  if (hiddenLayers.length > 0) {
    figma.viewport.scrollAndZoomIntoView(hiddenLayers);
  }

  // 저장
  pendingHiddenLayers = hiddenLayers;

  // UI에 확인 요청 (id, name 배열 전송)
  figma.ui.postMessage({
    type: 'confirm-hidden-layers',
    data: {
      count: hiddenLayers.length,
      layers: hiddenLayers.map(l => ({ id: l.id, name: l.name })),
    },
  });
}

/**
 * 꺼진 레이어 삭제 확인 (선택된 ID만)
 */
function confirmDeleteHiddenLayers(selectedIds?: string[]) {
  let deletedCount = 0;
  const idsToDelete = selectedIds ? new Set(selectedIds) : null;

  for (const layer of pendingHiddenLayers) {
    try {
      // selectedIds가 없으면 전체, 있으면 선택된 것만 삭제
      const shouldDelete = !idsToDelete || idsToDelete.has(layer.id);

      if (shouldDelete && layer.parent) {
        layer.remove();
        deletedCount++;
      } else if (!shouldDelete && layer.parent) {
        // 선택되지 않은 레이어는 다시 숨김
        layer.visible = false;
      }
    } catch (e) {
      console.error('Delete failed:', layer.name, e);
    }
  }

  pendingHiddenLayers = [];
  figma.notify(`${deletedCount}개 레이어를 삭제했습니다.`, { timeout: 3000 });
}

/**
 * 꺼진 레이어 삭제 취소
 */
function cancelDeleteHiddenLayers() {
  // 다시 숨기기
  for (const layer of pendingHiddenLayers) {
    try {
      if (layer.parent) {
        layer.visible = false;
      }
    } catch (e) {
      // 무시
    }
  }

  pendingHiddenLayers = [];
  figma.notify('삭제가 취소되었습니다.', { timeout: 2000 });
}

/**
 * 체크박스 선택에 따라 Figma 선택 상태 업데이트
 */
function updateHiddenLayerSelection(selectedIds: string[]) {
  const selectedSet = new Set(selectedIds);
  const selectedNodes: SceneNode[] = [];

  for (const layer of pendingHiddenLayers) {
    if (selectedSet.has(layer.id)) {
      selectedNodes.push(layer);
    }
  }

  // Figma 선택 상태 업데이트
  figma.currentPage.selection = selectedNodes;

  // 선택된 노드가 있으면 뷰포트 이동
  if (selectedNodes.length > 0) {
    figma.viewport.scrollAndZoomIntoView(selectedNodes);
  }
}

/**
 * 간격 표준화 핸들러
 */
function handleStandardizeSpacing() {
  figma.ui.postMessage({ type: 'task-start', taskName: '간격 표준화 중...' });

  try {
    const result = standardizeSelectionSpacing();

    if (result.details && result.details.changedFrames > 0) {
      console.log('=== 간격 표준화 결과 ===');
      for (const item of result.details.allChanges) {
        console.log(`[${item.name}]`);
        for (const change of item.changes) {
          console.log(`  - ${change}`);
        }
      }
    }

    figma.notify(result.message, {
      timeout: 3000,
      error: !result.success,
    });
  } catch (e) {
    figma.notify(`오류: ${e}`, { error: true });
  }

  figma.ui.postMessage({ type: 'task-complete' });
}

// Rule-based 네이밍은 삭제됨 - AI 네이밍만 사용

/**
 * 컴포넌트화 핸들러 (미리보기)
 */
function handleComponentize() {
  try {
    const result = componentizeSelection({
      minOccurrences: 2,
      autoConvert: false,
    });

    if (result.details && result.details.candidatesFound > 0) {
      console.log('=== 컴포넌트 후보 ===');
      for (const candidate of result.details.candidates) {
        console.log(`  [${candidate.name}] - ${candidate.count}회 반복`);
      }
    }

    figma.notify(result.message, {
      timeout: 3000,
      error: !result.success,
    });
  } catch (e) {
    figma.notify(`오류: ${e}`, { error: true });
  }

  // UI 유지 (closePlugin 제거)
}

/**
 * 컴포넌트화 실행 핸들러 (실제 변환)
 */
function handleComponentizeConvert() {
  try {
    const result = componentizeSelection({
      minOccurrences: 2,
      autoConvert: true,
    });

    if (result.details && result.details.componentsCreated > 0) {
      console.log('=== 컴포넌트화 결과 ===');
      for (const candidate of result.details.candidates) {
        console.log(`  [${candidate.name}] - ${candidate.count}회`);
      }
    }

    figma.notify(result.message, {
      timeout: 3000,
      error: !result.success,
    });
  } catch (e) {
    figma.notify(`오류: ${e}`, { error: true });
  }

  // UI 유지 (closePlugin 제거)
}

/**
 * 전체 실행 핸들러 (레거시 - Agent 버전으로 리다이렉트)
 */
function handleRunAll() {
  // Rule-based 버전은 삭제됨 - AI Agent 버전으로 리다이렉트
  figma.notify('AI Agent 파이프라인으로 실행됩니다.', { timeout: 2000 });
  handleRunAllAgent();
}

/**
 * 설정 핸들러
 */
function handleSettings() {
  figma.notify('설정 UI는 추후 구현 예정입니다.', {
    timeout: 3000,
  });
  // UI 유지 (closePlugin 제거)
}

// ============================================
// Agent Server 연동 함수들
// ============================================

/**
 * 노드 스크린샷 캡처 (Base64) - 개별 노드용 (AutoLayout에서 사용)
 */
async function captureNodeScreenshot(node: SceneNode): Promise<string | null> {
  try {
    const bytes = await node.exportAsync({
      format: 'PNG',
      constraint: { type: 'SCALE', value: 2 },
    });

    // Uint8Array to Base64
    let binary = '';
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }

    return 'data:image/png;base64,' + figma.base64Encode(bytes);
  } catch (error) {
    console.error('Screenshot capture failed:', error);
    return null;
  }
}

// ============================================
// 컨텍스트 기반 네이밍 (전체 스크린 활용)
// ============================================

/**
 * 최상위 스크린 프레임 찾기
 * - 노드에서 위로 올라가며 가장 상위의 FRAME 반환
 * - PAGE 바로 아래 프레임 = 스크린
 */
function findScreenFrame(node: SceneNode): FrameNode | null {
  let current: BaseNode | null = node;
  let lastFrame: FrameNode | null = null;

  while (current && current.type !== 'PAGE') {
    if (current.type === 'FRAME') {
      lastFrame = current as FrameNode;
    }
    current = current.parent;
  }

  return lastFrame;
}

/**
 * 전체 스크린 캡처 (1회만)
 * - 1x 스케일로 캡처 (크기 절약)
 */
async function captureScreenContext(screenFrame: FrameNode): Promise<string | null> {
  try {
    const bytes = await screenFrame.exportAsync({
      format: 'PNG',
      constraint: { type: 'SCALE', value: 1 }, // 1x로 충분 (크기 절약)
    });
    return 'data:image/png;base64,' + figma.base64Encode(bytes);
  } catch (error) {
    console.error('Screen context capture failed:', error);
    return null;
  }
}

/**
 * 스크린 기준 노드 깊이 계산
 * - 1: 최상위 (Screen)
 * - 2: Layout 레벨
 * - 3+: 컴포넌트 레벨
 */
function getDepthFromScreen(node: SceneNode, screenFrame: FrameNode): number {
  let depth = 0;
  let current: BaseNode | null = node;

  while (current && current.id !== screenFrame.id) {
    depth++;
    current = current.parent;
  }

  // screenFrame 자체면 depth = 1
  return node.id === screenFrame.id ? 1 : depth;
}

/**
 * 스크린 기준 상대 좌표 및 깊이 계산
 */
function getRelativePosition(node: SceneNode, screenFrame: FrameNode): {
  x: number;
  y: number;
  width: number;
  height: number;
  depth: number;
} {
  // absoluteTransform: [[scaleX, skewY, translateX], [skewX, scaleY, translateY]]
  const nodeAbsolute = node.absoluteTransform;
  const screenAbsolute = screenFrame.absoluteTransform;

  return {
    x: Math.round(nodeAbsolute[0][2] - screenAbsolute[0][2]),
    y: Math.round(nodeAbsolute[1][2] - screenAbsolute[1][2]),
    width: Math.round(node.width),
    height: Math.round(node.height),
    depth: getDepthFromScreen(node, screenFrame),
  };
}

/**
 * 자식 노드 위치 정보 추출
 */
function extractChildrenLayout(frame: FrameNode | GroupNode): Array<{
  id: string;
  name: string;
  x: number;
  y: number;
  width: number;
  height: number;
}> {
  const children: Array<{
    id: string;
    name: string;
    x: number;
    y: number;
    width: number;
    height: number;
  }> = [];

  for (let i = 0; i < frame.children.length; i++) {
    const child = frame.children[i];
    children.push({
      id: child.id,
      name: child.name,
      x: child.x,
      y: child.y,
      width: child.width,
      height: child.height,
    });
  }

  return children;
}

/**
 * 룰 베이스로 방향과 간격 계산
 */
function calculateDirectionAndGap(frame: FrameNode | GroupNode): {
  direction: 'HORIZONTAL' | 'VERTICAL';
  gap: number;
} {
  const children = frame.children;

  if (children.length < 2) {
    return { direction: 'VERTICAL', gap: 0 };
  }

  // 첫 두 자식으로 방향 판단
  const first = children[0];
  const second = children[1];
  const horizontalDiff = Math.abs(first.x - second.x);
  const verticalDiff = Math.abs(first.y - second.y);

  const direction = horizontalDiff > verticalDiff ? 'HORIZONTAL' : 'VERTICAL';

  // 간격 계산
  let totalGap = 0;
  let gapCount = 0;

  for (let i = 0; i < children.length - 1; i++) {
    const current = children[i];
    const next = children[i + 1];

    let gap: number;
    if (direction === 'HORIZONTAL') {
      gap = next.x - (current.x + current.width);
    } else {
      gap = next.y - (current.y + current.height);
    }

    if (gap > 0) {
      totalGap += gap;
      gapCount++;
    }
  }

  const avgGap = gapCount > 0 ? Math.round(totalGap / gapCount) : 0;

  return { direction, gap: avgGap };
}

// 현재 처리 중인 노드 저장 (결과 콜백에서 사용)
let pendingNamingNode: SceneNode | null = null;
let pendingNamingNodes: SceneNode[] = [];
let pendingAutoLayoutNode: FrameNode | null = null;

// 적용 전 스냅샷 저장 (안전 검증용)
let preAutoLayoutSnapshot: {
  width: number;
  height: number;
  childSizes: Array<{ id: string; width: number; height: number }>;
} | null = null;

/**
 * AI Auto Layout Agent 핸들러
 */
async function handleAutoLayoutAgent() {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('프레임을 선택해주세요.', { error: true });
    return;
  }

  const node = selection[0];

  if (node.type !== 'FRAME' && node.type !== 'GROUP') {
    figma.notify('프레임 또는 그룹을 선택해주세요.', { error: true });
    return;
  }

  figma.ui.postMessage({ type: 'task-start', taskName: 'AI Auto Layout 분석 중...' });

  // 스크린샷 캡처
  const screenshot = await captureNodeScreenshot(node);
  const children = extractChildrenLayout(node as FrameNode | GroupNode);

  // 룰 베이스 계산값
  const calculated = calculateDirectionAndGap(node as FrameNode | GroupNode);

  // 적용 전 스냅샷 저장 (안전 검증용)
  const frame = node as FrameNode | GroupNode;
  preAutoLayoutSnapshot = {
    width: frame.width,
    height: frame.height,
    childSizes: frame.children.map(c => ({
      id: c.id,
      width: c.width,
      height: c.height,
    })),
  };

  // 노드 저장
  pendingAutoLayoutNode = node as FrameNode;

  // UI에 Agent 요청 전송
  figma.ui.postMessage({
    type: 'agent-autolayout',
    data: {
      nodeId: node.id,
      screenshot: screenshot,
      width: node.width,
      height: node.height,
      calculatedDirection: calculated.direction,
      calculatedGap: calculated.gap,
      children: children,
    },
  });
}

/**
 * AutoLayout Agent 결과 처리
 */
function handleAutoLayoutResult(msg: AutoLayoutResultMessage) {
  if (!msg.success || !msg.data) {
    figma.notify('Auto Layout 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingAutoLayoutNode = null;
    preAutoLayoutSnapshot = null;
    return;
  }

  const node = pendingAutoLayoutNode;
  if (!node) {
    figma.notify('대상 노드를 찾을 수 없습니다.', { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    preAutoLayoutSnapshot = null;
    return;
  }

  const result = msg.data;

  // NONE인 경우 Auto Layout 적용하지 않음
  if (result.direction === 'NONE') {
    figma.notify('Auto Layout이 적합하지 않은 레이아웃입니다.', { timeout: 3000 });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingAutoLayoutNode = null;
    preAutoLayoutSnapshot = null;
    return;
  }

  const direction = result.direction === 'HORIZONTAL' ? 'HORIZONTAL' : 'VERTICAL';

  try {
    // 0. Auto Layout 적용 전에 자식들을 시각적 순서로 재정렬
    // Figma의 children은 레이어 순서(z-index)이므로 시각적 순서와 다를 수 있음
    const childrenWithPos = node.children.map(child => ({
      node: child,
      x: child.x,
      y: child.y,
    }));

    // 방향에 따라 정렬 (VERTICAL: y 기준, HORIZONTAL: x 기준)
    if (direction === 'VERTICAL') {
      childrenWithPos.sort((a, b) => a.y - b.y);
    } else {
      childrenWithPos.sort((a, b) => a.x - b.x);
    }

    // 레이어 순서 재정렬 (시각적 순서대로)
    for (let i = 0; i < childrenWithPos.length; i++) {
      const child = childrenWithPos[i].node;
      // insertChild로 순서 변경 (마지막 index = 맨 위 레이어)
      node.insertChild(i, child);
    }

    console.log('[AI AutoLayout] 자식 순서 재정렬 완료:', childrenWithPos.map(c => c.node.name).join(', '));

    // 1. Auto Layout 기본 설정
    node.layoutMode = direction;
    node.itemSpacing = result.gap || 0;

    // 2. 패딩 적용
    node.paddingTop = result.paddingTop || 0;
    node.paddingRight = result.paddingRight || 0;
    node.paddingBottom = result.paddingBottom || 0;
    node.paddingLeft = result.paddingLeft || 0;

    // 3. 기본 정렬
    node.primaryAxisAlignItems = 'MIN';
    node.counterAxisAlignItems = 'MIN';

    // 4. 컨테이너 Sizing 적용
    if (result.primaryAxisSizing === 'HUG') {
      node.primaryAxisSizingMode = 'AUTO';
    } else {
      node.primaryAxisSizingMode = 'FIXED';
    }

    if (result.counterAxisSizing === 'HUG') {
      node.counterAxisSizingMode = 'AUTO';
    } else {
      node.counterAxisSizingMode = 'FIXED';
    }

    // 5. 자식 요소 개별 Sizing 적용
    if (result.childrenSizing && result.childrenSizing.length > 0) {
      const children = node.children;
      for (const sizing of result.childrenSizing) {
        if (sizing.index < children.length) {
          const child = children[sizing.index];

          // layoutAlign 적용 (STRETCH = 교차축 FILL)
          if ('layoutAlign' in child) {
            (child as SceneNode & { layoutAlign: string }).layoutAlign = sizing.layoutAlign;
          }

          // layoutGrow 적용 (1 = 주축 FILL)
          if ('layoutGrow' in child) {
            (child as SceneNode & { layoutGrow: number }).layoutGrow = sizing.layoutGrow;
          }

          console.log('[AI AutoLayout] Child ' + sizing.index + ':', sizing.layoutAlign, 'grow=' + sizing.layoutGrow, '-', sizing.reasoning);
        }
      }
    }

    // 6. 안전 검증 - 크기 변화 확인
    if (preAutoLayoutSnapshot) {
      const widthDiff = Math.abs(node.width - preAutoLayoutSnapshot.width);
      const heightDiff = Math.abs(node.height - preAutoLayoutSnapshot.height);
      const threshold = 5; // 5px 이상 변화 시 경고

      if (widthDiff > threshold || heightDiff > threshold) {
        console.warn('[AI AutoLayout] 크기 변화 감지:',
          'width:', preAutoLayoutSnapshot.width, '→', node.width,
          'height:', preAutoLayoutSnapshot.height, '→', node.height
        );
        figma.notify('주의: 프레임 크기가 변경되었습니다 (확인 필요)', { timeout: 4000 });
      }
    }

    console.log('[AI AutoLayout]', result.reasoning);
    figma.notify('AI Auto Layout 적용 완료: ' + direction + ', gap=' + result.gap, { timeout: 3000 });

  } catch (e) {
    console.error('[AI AutoLayout] Error:', e);
    figma.notify('Auto Layout 적용 중 오류: ' + String(e), { error: true });
  }

  figma.ui.postMessage({ type: 'task-complete' });
  pendingAutoLayoutNode = null;
  preAutoLayoutSnapshot = null;
}

/**
 * 노드에 직접 변환 적용 (AI 호출 없이)
 * - 부모 도메인 기반 구조적 네이밍
 * - 아이콘 라이브러리, 한글 레이블, 하이픈 패턴, camelCase 방어
 * @returns 변환된 이름 또는 null (AI 분석 필요)
 */
function tryDirectNaming(node: SceneNode): string | null {
  const name = node.name;

  // -1. 최상위 스크린 프레임 처리 (PAGE 바로 아래)
  // Container/HomeScreen → HomeScreen
  if (isTopLevelScreenFrame(node)) {
    const cleanedName = cleanScreenName(name);
    if (cleanedName !== name) {
      return cleanedName;
    }
    // 이미 깨끗하면 그대로 유지
    return null;
  }

  // 0. Layout 프레임 감지 (최우선 - header, bottom, main content 등)
  // e.g., "header" → "Layout/Header"
  // e.g., "Main Content" → "Layout/Main"
  // 구조적 네이밍보다 먼저 실행하여 Layout 일관성 유지
  const layoutName = inferLayoutName(node);
  if (layoutName) {
    return layoutName;
  }

  // 1. 부모 도메인 기반 구조적 네이밍
  // e.g., "Weekly Challenge Content" → "Content" (부모가 Section/WeeklyChallenge일 때)
  const structuralName = tryStructuralNaming(node);
  if (structuralName) {
    return structuralName;
  }

  // 1. 아이콘 라이브러리 형식 (carbon:xxx, solar:xxx 등)
  if (isIconLibraryName(name)) {
    return convertIconLibraryToWDS(name);
  }

  // 2. 하이픈 패턴 아이콘 (user-circle-02, award-04 등)
  if (isHyphenIconPattern(name)) {
    return convertHyphenIconToWDS(name);
  }

  // 3. 한글 레이블 (홈, 라운지, 마이페이지 등)
  if (isKoreanLabel(name)) {
    const englishLabel = convertKoreanLabel(name);
    // 탭바 컨텍스트면 TabItem/
    if (isInTabbarContext(node)) {
      return `TabItem/${englishLabel}`;
    }
    return englishLabel;
  }

  // 4. 아이콘 상태 컨테이너 (자식에 on/off)
  if (isIconStateContainer(node)) {
    if (isHyphenIconPattern(name)) {
      return convertHyphenIconToWDS(name);
    }
    // 이름 유지
    return null;
  }

  // 5. camelCase 방어 → PascalCase 변환
  if (isCamelCase(name)) {
    return convertCamelCaseToPascalCase(name);
  }

  // 6. 일반 이름 + 자식 키워드 기반 Section 추론
  // e.g., details (자식에 Challenge 키워드) → Section/ActiveChallenge
  const sectionName = inferSectionNameFromChildren(node);
  if (sectionName) {
    return sectionName;
  }

  // 7. 자동 생성 이름 처리 (Frame 123456, Group 123 등)
  // 자식/부모 컨텍스트에서 의미 있는 이름 추론
  const autoGenName = inferNameForAutoGenerated(node);
  if (autoGenName) {
    return autoGenName;
  }

  return null; // AI 분석 필요
}

/**
 * 재귀적으로 모든 자식 노드 수집 (depth 무제한)
 */
function collectAllNodes(node: SceneNode, result: SceneNode[]): void {
  result.push(node);

  if ('children' in node) {
    const children = (node as ChildrenMixin).children;
    for (const child of children) {
      collectAllNodes(child, result);
    }
  }
}

/**
 * AI Naming Agent 핸들러 (재귀 + 제외/변환 로직)
 */
async function handleNamingAgent() {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('노드를 선택해주세요.', { error: true });
    return;
  }

  figma.ui.postMessage({ type: 'task-start', taskName: 'AI 네이밍 분석 중...' });

  // 1. 모든 노드 수집 (재귀)
  const allNodes: SceneNode[] = [];
  for (const node of selection) {
    collectAllNodes(node, allNodes);
  }

  // 2. 직접 변환 vs AI 분석 분류
  const directChanges: { node: SceneNode; oldName: string; newName: string }[] = [];
  const nodesForAI: SceneNode[] = [];
  let skippedCount = 0;

  for (const node of allNodes) {
    // 제외 조건 확인
    if (shouldSkipNaming(node)) {
      skippedCount++;
      continue;
    }

    // 부모 컴포넌트 체크 (Button/*, Card/* 내부면 스킵)
    const parentCheck = shouldSkipForParentComponent(node);
    if (parentCheck.shouldSkip) {
      skippedCount++;
      console.log(`[Naming] 스킵: "${node.name}" - ${parentCheck.reason}`);
      continue;
    }

    // 직접 변환 시도
    const directName = tryDirectNaming(node);

    // directName이 blacklist면 AI로 위임
    if (directName && isBlacklistedName(directName)) {
      console.log(`[Naming] Blacklist 감지: "${directName}" → AI로 위임`);
      if (['FRAME', 'GROUP', 'COMPONENT', 'INSTANCE'].includes(node.type)) {
        nodesForAI.push(node);
      }
    } else if (directName && directName !== node.name) {
      directChanges.push({
        node,
        oldName: node.name,
        newName: directName,
      });
    } else if (['FRAME', 'GROUP', 'COMPONENT', 'INSTANCE'].includes(node.type)) {
      // FRAME/GROUP/COMPONENT/INSTANCE이고 직접 변환 불가능하면 AI 분석 대상
      if (!directName && !hasValidSemanticName(node.name)) {
        nodesForAI.push(node);
      }
    }
  }

  // 3. 형제 중복 이름 해결 + 기존 형제와 충돌 체크
  const resolvedChanges = resolveSiblingDuplicates(directChanges);

  // 기존 형제와 충돌하는 경우도 해결
  for (const change of resolvedChanges) {
    change.newName = makeUniqueSiblingName(change.node, change.newName);
  }

  // 4. 직접 변환 적용
  for (const change of resolvedChanges) {
    change.node.name = change.newName;
    console.log('[Direct Naming]', change.oldName, '→', change.newName);
  }

  // 3.5. 2차 패스: TabItem 자식 아이콘 기반 이름 유추
  // (직접 변환 후에 실행해야 자식 Icon/* 이름이 적용된 상태)
  let tabItemInferredCount = 0;
  for (const node of allNodes) {
    if (node.name.startsWith('TabItem/')) {
      const inferredName = inferTabItemNameFromIcon(node);
      if (inferredName && inferredName !== node.name) {
        console.log('[TabItem Infer]', node.name, '→', inferredName);
        node.name = inferredName;
        tabItemInferredCount++;
      }
    }
  }

  // 4. AI 분석이 필요한 노드가 있으면 Agent Server 호출 (컨텍스트 기반)
  if (nodesForAI.length > 0) {
    // 스크린 프레임 찾기 (첫 번째 노드 기준)
    const screenFrame = findScreenFrame(nodesForAI[0]);
    if (!screenFrame) {
      figma.notify('스크린 프레임을 찾을 수 없습니다.', { error: true });
      figma.ui.postMessage({ type: 'task-complete' });
      return;
    }

    // 전체 스크린 캡처 (1회만)
    const screenScreenshot = await captureScreenContext(screenFrame);
    if (!screenScreenshot) {
      figma.notify('스크린 캡처에 실패했습니다.', { error: true });
      figma.ui.postMessage({ type: 'task-complete' });
      return;
    }

    // 노드 위치 정보 + 텍스트/아이콘 힌트 수집
    pendingNamingNodes = [];
    const nodePositions: Array<{
      nodeId: string;
      currentName: string;
      nodeType: string;
      x: number;
      y: number;
      width: number;
      height: number;
      texts: string[];
      iconHints: string[];
    }> = [];

    for (const node of nodesForAI) {
      pendingNamingNodes.push(node);
      const position = getRelativePosition(node, screenFrame);

      // 자식에서 텍스트/아이콘 힌트 수집
      const texts: string[] = [];
      const iconHints: string[] = [];

      if ('children' in node) {
        for (const child of (node as FrameNode).children) {
          if (child.type === 'TEXT') {
            const textContent = (child as TextNode).characters;
            if (textContent && textContent.trim()) {
              texts.push(textContent.trim());
            }
          }
          if (child.name.startsWith('Icon/')) {
            iconHints.push(child.name.replace('Icon/', ''));
          }
        }
      }

      nodePositions.push({
        nodeId: node.id,
        currentName: node.name,
        nodeType: node.type,
        texts,
        iconHints,
        ...position,
      });
    }

    console.log(`[Context Naming] Screen: ${screenFrame.width}x${screenFrame.height}, Nodes: ${nodePositions.length}`);

    // UI로 컨텍스트 기반 요청 전송
    figma.ui.postMessage({
      type: 'agent-naming-context',
      data: {
        screenScreenshot,
        screenWidth: screenFrame.width,
        screenHeight: screenFrame.height,
        nodes: nodePositions,
      },
    });

    // 직접 변환 결과는 로그로 표시
    if (resolvedChanges.length > 0 || tabItemInferredCount > 0) {
      console.log(`[AI Naming] 직접 변환: ${resolvedChanges.length}개, TabItem 유추: ${tabItemInferredCount}개, AI 분석: ${nodesForAI.length}개, 제외: ${skippedCount}개`);
    }
  } else {
    // AI 분석 필요 없음 - 직접 변환만 완료
    const totalChanged = resolvedChanges.length + tabItemInferredCount;
    const msg = totalChanged > 0
      ? `네이밍 완료: ${totalChanged}개 변환 (${skippedCount}개 제외)`
      : `변경할 이름이 없습니다. (${skippedCount}개 제외)`;
    figma.notify(msg, { timeout: 3000 });
    figma.ui.postMessage({ type: 'task-complete' });
  }
}

/**
 * Naming Agent 단일 결과 처리
 */
function handleNamingResult(msg: NamingResultMessage) {
  if (!msg.success || !msg.data) {
    figma.notify('네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    pendingNamingNode = null;
    return;
  }

  const node = pendingNamingNode;
  if (!node) {
    figma.notify('대상 노드를 찾을 수 없습니다.', { error: true });
    return;
  }

  const result = msg.data;
  const oldName = node.name;
  node.name = result.suggestedName;

  console.log('[AI Naming]', oldName, '→', result.suggestedName);
  console.log('[AI Naming] Confidence:', result.confidence, ', Reasoning:', result.reasoning);

  figma.notify('이름 변경: ' + oldName + ' → ' + result.suggestedName, { timeout: 3000 });

  pendingNamingNode = null;
}

/**
 * Naming Agent 배치 결과 처리
 */
function handleNamingBatchResult(msg: NamingBatchResultMessage) {
  if (!msg.success || !msg.results) {
    figma.notify('배치 네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingNamingNodes = [];
    return;
  }

  let renamedCount = 0;

  for (let i = 0; i < msg.results.length; i++) {
    const result = msg.results[i];
    const node = pendingNamingNodes[i];

    if (result && result.success && result.data && node) {
      const oldName = node.name;
      node.name = result.data.suggestedName;
      console.log('[AI Naming]', oldName, '→', result.data.suggestedName);
      renamedCount++;
    }
  }

  figma.notify('AI 네이밍 완료: ' + renamedCount + '개 이름 변경', { timeout: 3000 });

  figma.ui.postMessage({ type: 'task-complete' });
  pendingNamingNodes = [];
}

/**
 * Naming Agent 컨텍스트 기반 결과 처리 (전체 스크린 분석)
 */
function handleNamingContextResult(msg: NamingContextResultMessage) {
  if (!msg.success || !msg.data || !msg.data.results) {
    figma.notify('컨텍스트 네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingNamingNodes = [];
    return;
  }

  let renamedCount = 0;

  // nodeId로 매칭하여 이름 적용
  for (const result of msg.data.results) {
    const node = pendingNamingNodes.find(n => n.id === result.nodeId);
    if (node) {
      const oldName = node.name;
      node.name = result.suggestedName;
      console.log(`[Context AI Naming] ${oldName} → ${result.suggestedName} (${result.componentType}, confidence: ${result.confidence})`);
      console.log(`  reasoning: ${result.reasoning}`);
      renamedCount++;
    } else {
      console.warn(`[Context AI Naming] Node not found: ${result.nodeId}`);
    }
  }

  figma.notify(`AI 컨텍스트 네이밍 완료: ${renamedCount}개 이름 변경`, { timeout: 3000 });

  figma.ui.postMessage({ type: 'task-complete' });
  pendingNamingNodes = [];
}

/**
 * 전체 실행 (Agent 포함)
 */
async function handleRunAllAgent() {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('선택된 요소가 없습니다.', { error: true });
    return;
  }

  // 파이프라인 시작 - UI에 단계 목록 전송
  const steps = ['래퍼 제거', '컴포넌트 브레이크', 'AI 네이밍', 'AI Auto Layout', '간격 표준화'];
  figma.ui.postMessage({ type: 'pipeline-start', steps });

  // 1. 래퍼 제거
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 0, status: 'active' });
  handleCleanupWrappers();
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 0, status: 'completed' });

  // 2. 컴포넌트 브레이크
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 1, status: 'active' });
  handleDetachComponents();
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 1, status: 'completed' });

  // 3. AI 네이밍
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 2, status: 'active' });
  await handleNamingAgent();
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 2, status: 'completed' });

  // 4. AI Auto Layout
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 3, status: 'active' });
  await handleAutoLayoutAgent();
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 3, status: 'completed' });

  // 5. 간격 표준화
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 4, status: 'active' });
  const spacingResult = standardizeSelectionSpacing();
  console.log('[Pipeline] Spacing:', spacingResult.message);
  figma.ui.postMessage({ type: 'pipeline-step', stepIndex: 4, status: 'completed' });

  // 완료
  figma.ui.postMessage({ type: 'pipeline-complete' });
  figma.notify('AI 파이프라인 완료', { timeout: 3000 });
}

