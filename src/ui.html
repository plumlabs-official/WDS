<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Wellwe Design System Automator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      color: #333;
      padding: 16px;
      background: #fff;
    }

    h1 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #00cc61;
    }

    .section {
      margin-bottom: 16px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    button {
      width: 100%;
      padding: 10px 12px;
      margin-bottom: 8px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #00cc61;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #00b356;
    }

    .btn-secondary {
      background: #f3f3f3;
      color: #333;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #e6e6e6;
    }

    .btn-agent {
      background: #6366f1;
      color: white;
    }

    .btn-agent:hover:not(:disabled) {
      background: #4f46e5;
    }

    .info {
      font-size: 11px;
      color: #797979;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #eee;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 11px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-connected {
      background: #ecfdf5;
      color: #065f46;
    }

    .status-connected .status-dot {
      background: #10b981;
    }

    .status-disconnected {
      background: #fef2f2;
      color: #991b1b;
    }

    .status-disconnected .status-dot {
      background: #ef4444;
    }

    .status-loading {
      background: #fffbeb;
      color: #92400e;
    }

    .status-loading .status-dot {
      background: #f59e0b;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .progress {
      margin-top: 12px;
      font-size: 11px;
      color: #666;
    }

    /* 진행 상태 패널 */
    .progress-panel {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }

    .progress-title {
      font-size: 11px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
    }

    .progress-steps {
      margin: 8px 0 12px 0;
    }

    .progress-step {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
      font-size: 11px;
    }

    .progress-step.completed { color: #10b981; }
    .progress-step.active { color: #6366f1; font-weight: 500; }
    .progress-step.pending { color: #9ca3af; }

    .progress-bar-container {
      height: 4px;
      background: #e5e7eb;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 4px;
    }

    .progress-bar {
      height: 100%;
      background: #6366f1;
      transition: width 0.3s ease;
    }

    .progress-percent {
      font-size: 10px;
      color: #6b7280;
      text-align: right;
    }

    .server-status-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
    }

    .server-status-wrapper .status {
      flex: 1;
      margin-bottom: 0;
    }

    .btn-reconnect {
      width: auto;
      padding: 8px 12px;
      margin-bottom: 0;
      background: #f3f3f3;
      color: #666;
      font-size: 11px;
    }

    .btn-reconnect:hover:not(:disabled) {
      background: #e6e6e6;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      background: #dc2626;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal {
      background: white;
      border-radius: 12px;
      padding: 20px;
      width: 260px;
      max-height: 400px;
      overflow: hidden;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .modal-content {
      font-size: 12px;
      color: #666;
      margin-bottom: 16px;
    }

    .modal-select-all {
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }

    .modal-select-all label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }

    .modal-layers-list {
      max-height: 200px;
      overflow-y: auto;
      background: #f5f5f5;
      border-radius: 8px;
      padding: 8px;
    }

    .layer-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 4px;
      border-bottom: 1px solid #e5e5e5;
      font-size: 11px;
    }

    .layer-item:last-child {
      border-bottom: none;
    }

    .layer-item label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      flex: 1;
    }

    .layer-item input[type="checkbox"] {
      cursor: pointer;
    }

    .modal-buttons {
      display: flex;
      gap: 8px;
    }

    .modal-buttons button {
      flex: 1;
    }
  </style>
</head>
<body>
  <h1>Wellwe Design System</h1>

  <!-- Agent Server Status -->
  <div class="server-status-wrapper">
    <div id="server-status" class="status status-loading">
      <div class="status-dot"></div>
      <span>Agent Server 연결 확인 중...</span>
    </div>
    <button id="btn-reconnect" class="btn-reconnect" onclick="checkServerConnection()">
      재연결
    </button>
  </div>

  <div class="section">
    <div class="section-title">1. 전처리</div>
    <button id="btn-detach-components" class="btn-secondary" onclick="runCommandWithProgress('detach-components', this)">
      컴포넌트 브레이크
    </button>
    <button id="btn-delete-hidden-layers" class="btn-secondary" onclick="runCommand('delete-hidden-layers')">
      꺼진 레이어 삭제
    </button>
    <button id="btn-cleanup-wrappers" class="btn-secondary" onclick="runCommandWithProgress('cleanup-wrappers', this)">
      의미 없는 래퍼 제거
    </button>
    <button id="btn-flatten-same-name" class="btn-secondary" onclick="runCommandWithProgress('flatten-same-name', this)">
      중첩 레이어 병합
    </button>
  </div>

  <div class="section">
    <div class="section-title">2. 네이밍</div>
    <button id="btn-naming-agent" class="btn-agent" onclick="runCommandWithProgress('auto-naming-agent', this)" disabled>
      AI 네이밍 (Agent)
    </button>
  </div>

  <div class="section">
    <div class="section-title">3. Auto Layout</div>
    <button id="btn-autolayout-agent" class="btn-agent" onclick="runCommandWithProgress('apply-autolayout-agent', this)" disabled>
      AI Auto Layout (Agent)
    </button>
    <button id="btn-standardize-spacing" class="btn-secondary" onclick="runCommandWithProgress('standardize-spacing', this)">
      간격 표준화
    </button>
  </div>

  <div class="section">
    <div class="section-title">4. 컴포넌트</div>
    <button id="btn-componentize" class="btn-secondary" onclick="runCommand('componentize')">
      컴포넌트 후보 탐지
    </button>
    <button id="btn-componentize-convert" class="btn-primary" onclick="runCommand('componentize-convert')">
      컴포넌트로 변환
    </button>
  </div>

  <div class="section">
    <button id="btn-run-all-agent" class="btn-agent" onclick="runCommandWithProgress('run-all-agent', this)" disabled>
      전체 실행 (with AI Agent)
    </button>
  </div>

  <div class="info">
    <p>프레임을 선택한 후 버튼을 클릭하세요.</p>
    <p style="margin-top: 4px;">토큰 기반: spacing (0, 4, 8, 12, 16, 24, 32, 64)</p>
  </div>

  <div id="progress" class="progress" style="display: none;"></div>

  <!-- 진행 상태 패널 -->
  <div id="progress-panel" class="progress-panel" style="display: none;">
    <div class="progress-title">진행 상태</div>
    <div id="progress-steps" class="progress-steps"></div>
    <div class="progress-bar-container">
      <div id="progress-bar" class="progress-bar" style="width: 0%;"></div>
    </div>
    <div id="progress-percent" class="progress-percent">0%</div>
  </div>

  <!-- 확인 모달 -->
  <div id="modal-overlay" class="modal-overlay" style="display: none;">
    <div class="modal">
      <div class="modal-title">꺼진 레이어 삭제</div>
      <div class="modal-content">
        <p id="modal-message"></p>
        <div class="modal-select-all">
          <label>
            <input type="checkbox" id="select-all-layers" onchange="toggleSelectAll()">
            <span>전체 선택</span>
          </label>
        </div>
        <div id="modal-layers" class="modal-layers-list"></div>
      </div>
      <div class="modal-buttons">
        <button class="btn-secondary" onclick="cancelDeleteHidden()">취소</button>
        <button class="btn-danger" onclick="confirmDeleteHidden()">선택 삭제</button>
      </div>
    </div>
  </div>

  <script>
    const AGENT_SERVER_URL = 'http://localhost:3001';
    let serverConnected = false;

    // ============================================
    // 진행 상태 관리
    // ============================================
    let currentPipeline = null;

    function showPipelineProgress(steps) {
      currentPipeline = {
        steps: steps,
        currentStep: 0,
        completed: []
      };
      insertProgressPanelAfterButton();
      renderProgress();
      document.getElementById('progress-panel').style.display = 'block';
    }

    function updatePipelineStep(stepIndex, status) {
      if (!currentPipeline) return;

      if (status === 'completed') {
        if (!currentPipeline.completed.includes(stepIndex)) {
          currentPipeline.completed.push(stepIndex);
        }
      }
      currentPipeline.currentStep = stepIndex;
      renderProgress();
    }

    function renderProgress() {
      if (!currentPipeline) return;

      const stepsEl = document.getElementById('progress-steps');
      const barEl = document.getElementById('progress-bar');
      const percentEl = document.getElementById('progress-percent');

      const { steps, currentStep, completed } = currentPipeline;

      stepsEl.innerHTML = steps.map((step, i) => {
        let icon = '○';
        let className = 'pending';

        if (completed.includes(i)) {
          icon = '✓';
          className = 'completed';
        } else if (i === currentStep) {
          icon = '→';
          className = 'active';
        }

        return '<div class="progress-step ' + className + '">' + icon + ' ' + (i + 1) + '. ' + step + '</div>';
      }).join('');

      const percent = Math.round((completed.length / steps.length) * 100);
      barEl.style.width = percent + '%';
      percentEl.textContent = percent + '%';
    }

    function hidePipelineProgress() {
      document.getElementById('progress-panel').style.display = 'none';
      currentPipeline = null;
      activeButton = null;
    }

    // 진행 상태 패널을 버튼 아래에 삽입
    function insertProgressPanelAfterButton() {
      const panel = document.getElementById('progress-panel');
      if (activeButton && activeButton.parentNode) {
        // 버튼 바로 다음에 삽입
        activeButton.parentNode.insertBefore(panel, activeButton.nextSibling);
      }
    }

    // 단일 작업 진행 상태 표시
    function showSingleTaskProgress(taskName) {
      currentPipeline = {
        steps: [taskName],
        currentStep: 0,
        completed: []
      };
      insertProgressPanelAfterButton();
      renderProgress();
      document.getElementById('progress-panel').style.display = 'block';
    }

    function completeSingleTaskProgress() {
      if (currentPipeline && currentPipeline.steps.length === 1) {
        currentPipeline.completed.push(0);
        renderProgress();
        // 1초 후 숨김
        setTimeout(() => {
          hidePipelineProgress();
          activeButton = null;
        }, 1000);
      }
    }

    // Check server connection on load
    checkServerConnection();

    async function checkServerConnection() {
      console.log('[DEBUG] checkServerConnection called');
      const reconnectBtn = document.getElementById('btn-reconnect');
      const statusEl = document.getElementById('server-status');

      // 로딩 상태 표시
      reconnectBtn.disabled = true;
      reconnectBtn.textContent = '연결 중...';
      statusEl.className = 'status status-loading';
      statusEl.innerHTML = '<div class="status-dot"></div><span>연결 시도 중...</span>';

      const urls = [
        'http://localhost:3001/health',
        'http://127.0.0.1:3001/health'
      ];

      for (const url of urls) {
        try {
          console.log('[DEBUG] Trying:', url);
          const response = await fetch(url, { method: 'GET' });
          console.log('[DEBUG] Response:', response.status);

          if (response.ok) {
            serverConnected = true;
            updateServerStatus(true);
            enableAgentButtons(true);
            reconnectBtn.disabled = false;
            reconnectBtn.textContent = '재연결';
            return;
          }
        } catch (error) {
          console.log('[DEBUG] Error for', url, ':', error.message);
        }
      }

      // 모두 실패
      serverConnected = false;
      updateServerStatus(false, 'localhost 접근 불가');
      enableAgentButtons(false);
      reconnectBtn.disabled = false;
      reconnectBtn.textContent = '재연결';
    }

    function updateServerStatus(connected, errorMsg) {
      const statusEl = document.getElementById('server-status');
      if (connected) {
        statusEl.className = 'status status-connected';
        statusEl.innerHTML = '<div class="status-dot"></div><span>Agent Server 연결됨 (localhost:3001)</span>';
      } else {
        statusEl.className = 'status status-disconnected';
        const msg = errorMsg ? 'Error: ' + errorMsg : 'Agent Server 연결 안됨';
        statusEl.innerHTML = '<div class="status-dot"></div><span>' + msg + '</span>';
      }
    }

    function enableAgentButtons(enabled) {
      document.getElementById('btn-autolayout-agent').disabled = !enabled;
      document.getElementById('btn-naming-agent').disabled = !enabled;
      document.getElementById('btn-run-all-agent').disabled = !enabled;
    }

    function showProgress(message) {
      const progressEl = document.getElementById('progress');
      progressEl.style.display = 'block';
      progressEl.textContent = message;
    }

    function hideProgress() {
      document.getElementById('progress').style.display = 'none';
    }

    function runCommand(command) {
      parent.postMessage({ pluginMessage: { type: command } }, '*');
    }

    // 클릭한 버튼 참조 저장
    let activeButton = null;

    function runCommandWithProgress(command, buttonElement) {
      activeButton = buttonElement;
      parent.postMessage({ pluginMessage: { type: command } }, '*');
    }

    // Listen for messages from main code
    window.onmessage = async (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      switch (msg.type) {
        case 'agent-naming':
          await handleNamingAgent(msg.data);
          break;

        case 'agent-naming-batch':
          await handleNamingBatch(msg.data);
          break;

        case 'agent-naming-context':
          await handleNamingContext(msg.data);
          break;

        case 'agent-autolayout':
          await handleAutoLayoutAgent(msg.data);
          break;

        case 'check-connection':
          await checkServerConnection();
          parent.postMessage({
            pluginMessage: {
              type: 'connection-result',
              connected: serverConnected
            }
          }, '*');
          break;

        case 'confirm-hidden-layers':
          showHiddenLayersModal(msg.data);
          break;

        // 파이프라인 진행 상태
        case 'pipeline-start':
          showPipelineProgress(msg.steps);
          break;

        case 'pipeline-step':
          updatePipelineStep(msg.stepIndex, msg.status);
          break;

        case 'pipeline-complete':
          hidePipelineProgress();
          break;

        // 단일 작업 진행 상태
        case 'task-start':
          showSingleTaskProgress(msg.taskName);
          break;

        case 'task-complete':
          completeSingleTaskProgress();
          break;
      }
    };

    // 꺼진 레이어 모달 표시
    let hiddenLayersData = [];

    function showHiddenLayersModal(data) {
      hiddenLayersData = data.layers || [];

      document.getElementById('modal-message').textContent =
        `${data.count}개의 꺼진 레이어가 발견되었습니다. 삭제할 레이어를 선택하세요.`;

      // 체크박스 목록 생성
      const layersContainer = document.getElementById('modal-layers');
      layersContainer.innerHTML = hiddenLayersData.map((layer, index) => `
        <div class="layer-item">
          <label>
            <input type="checkbox" class="layer-checkbox" data-index="${index}" data-id="${layer.id}" checked onchange="updateLayerSelection()">
            <span>${layer.name}</span>
          </label>
        </div>
      `).join('');

      // 전체 선택 체크박스 초기화
      document.getElementById('select-all-layers').checked = true;

      document.getElementById('modal-overlay').style.display = 'flex';
    }

    function toggleSelectAll() {
      const selectAll = document.getElementById('select-all-layers').checked;
      const checkboxes = document.querySelectorAll('.layer-checkbox');
      checkboxes.forEach(cb => cb.checked = selectAll);
      updateLayerSelection();
    }

    function updateLayerSelection() {
      // 선택된 레이어 ID 수집
      const checkboxes = document.querySelectorAll('.layer-checkbox:checked');
      const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.id);

      // Figma에 선택 상태 업데이트 요청
      parent.postMessage({
        pluginMessage: {
          type: 'update-hidden-selection',
          selectedIds: selectedIds
        }
      }, '*');
    }

    function confirmDeleteHidden() {
      // 선택된 레이어 ID 수집
      const checkboxes = document.querySelectorAll('.layer-checkbox:checked');
      const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.id);

      document.getElementById('modal-overlay').style.display = 'none';

      if (selectedIds.length === 0) {
        runCommand('cancel-delete-hidden');
        return;
      }

      // 선택된 ID 전송
      parent.postMessage({
        pluginMessage: {
          type: 'confirm-delete-hidden',
          selectedIds: selectedIds
        }
      }, '*');
    }

    function cancelDeleteHidden() {
      document.getElementById('modal-overlay').style.display = 'none';
      runCommand('cancel-delete-hidden');
    }

    // Naming Agent API call
    async function handleNamingAgent(data) {
      if (!serverConnected) {
        parent.postMessage({
          pluginMessage: {
            type: 'agent-result',
            success: false,
            error: 'Agent server not connected'
          }
        }, '*');
        return;
      }

      showProgress('AI 네이밍 분석 중...');

      try {
        const response = await fetch(AGENT_SERVER_URL + '/agents/naming', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });

        const result = await response.json();

        parent.postMessage({
          pluginMessage: {
            type: 'naming-result',
            ...result
          }
        }, '*');
      } catch (error) {
        parent.postMessage({
          pluginMessage: {
            type: 'naming-result',
            success: false,
            error: error.message
          }
        }, '*');
      } finally {
        hideProgress();
      }
    }

    // Batch Naming Agent API call
    async function handleNamingBatch(data) {
      if (!serverConnected) {
        parent.postMessage({
          pluginMessage: {
            type: 'naming-batch-result',
            success: false,
            error: 'Agent server not connected'
          }
        }, '*');
        return;
      }

      showProgress('AI 네이밍 분석 중... (0/' + data.nodes.length + ')');

      try {
        const results = [];

        for (let i = 0; i < data.nodes.length; i++) {
          showProgress('AI 네이밍 분석 중... (' + (i + 1) + '/' + data.nodes.length + ')');

          const response = await fetch(AGENT_SERVER_URL + '/agents/naming', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data.nodes[i]),
          });

          const result = await response.json();
          results.push(result);
        }

        parent.postMessage({
          pluginMessage: {
            type: 'naming-batch-result',
            success: true,
            results
          }
        }, '*');
      } catch (error) {
        parent.postMessage({
          pluginMessage: {
            type: 'naming-batch-result',
            success: false,
            error: error.message
          }
        }, '*');
      } finally {
        hideProgress();
      }
    }

    // Context-aware Naming Agent API call (전체 스크린 기반)
    async function handleNamingContext(data) {
      if (!serverConnected) {
        parent.postMessage({
          pluginMessage: {
            type: 'naming-context-result',
            success: false,
            error: 'Agent server not connected'
          }
        }, '*');
        return;
      }

      // 진행 패널에 상세 정보 업데이트 (task-start로 패널이 이미 표시됨)
      if (currentPipeline && currentPipeline.steps.length === 1) {
        currentPipeline.steps[0] = 'AI 컨텍스트 네이밍 분석 중... (' + data.nodes.length + '개 노드)';
        renderProgress();
      }

      try {
        const response = await fetch(AGENT_SERVER_URL + '/agents/naming/context', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });

        const result = await response.json();

        parent.postMessage({
          pluginMessage: {
            type: 'naming-context-result',
            ...result
          }
        }, '*');
      } catch (error) {
        parent.postMessage({
          pluginMessage: {
            type: 'naming-context-result',
            success: false,
            error: error.message
          }
        }, '*');
      }
    }

    // AutoLayout Agent API call
    async function handleAutoLayoutAgent(data) {
      if (!serverConnected) {
        parent.postMessage({
          pluginMessage: {
            type: 'autolayout-result',
            success: false,
            error: 'Agent server not connected'
          }
        }, '*');
        return;
      }

      // 진행 패널에 상세 정보 업데이트 (task-start로 패널이 이미 표시됨)
      if (currentPipeline && currentPipeline.steps.length === 1) {
        currentPipeline.steps[0] = 'AI Auto Layout 분석 중...';
        renderProgress();
      }

      try {
        const response = await fetch(AGENT_SERVER_URL + '/agents/autolayout', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });

        const result = await response.json();

        parent.postMessage({
          pluginMessage: {
            type: 'autolayout-result',
            ...result
          }
        }, '*');
      } catch (error) {
        parent.postMessage({
          pluginMessage: {
            type: 'autolayout-result',
            success: false,
            error: error.message
          }
        }, '*');
      }
    }
  </script>
</body>
</html>
