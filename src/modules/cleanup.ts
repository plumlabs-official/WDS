/**
 * 레이어 정리 모듈
 *
 * 역할:
 * - 의미 없는 래퍼 그룹/프레임 제거
 * - 자식 노드를 상위 레벨로 언래핑
 */

/**
 * 자동 생성된 이름인지 판단
 * - "Frame 123456" 패턴
 * - "Group 123" 패턴
 * - "Rectangle 1" 패턴
 */
export function isAutoGeneratedName(name: string): boolean {
  return /^(Frame|Group|Rectangle|Ellipse|Line|Vector)\s*\d*$/.test(name);
}

/**
 * 공격적 래퍼 판단 (자동 생성 이름 + 자식 1개면 제거)
 * - 크기/스타일 검사 없이 제거
 * - 최상위 래퍼 제거에 유용
 */
export function isAutoGeneratedWrapper(node: SceneNode): boolean {
  // 이름이 자동 생성 패턴이 아니면 false
  if (!isAutoGeneratedName(node.name)) return false;

  // 그룹인 경우
  if (node.type === 'GROUP') {
    return 'children' in node && node.children.length === 1;
  }

  // 프레임인 경우
  if (node.type === 'FRAME') {
    // 자식이 1개
    if (node.children.length !== 1) return false;

    // Auto Layout이 있으면 의미 있음
    if (node.layoutMode !== 'NONE') return false;

    return true;
  }

  return false;
}

/**
 * 의미 없는 래퍼인지 판단 (안전 모드)
 *
 * 조건 (2026-01-15 업데이트):
 * 1. 그룹 또는 프레임
 * 2. 자식이 정확히 1개
 * 3. 시각적 스타일 없음 (fill, stroke, effect) - 프레임만
 * 4. Auto Layout 없음 - 프레임만
 *
 * 크기 체크 제거됨: 단일 자식이면 크기와 관계없이 병합 대상
 * 이름과 관계없이 구조적으로 불필요한 래퍼를 제거
 */
export function isMeaninglessWrapper(node: SceneNode): boolean {
  // 그룹인 경우: 단일 자식이면 병합 대상
  if (node.type === 'GROUP') {
    if (!('children' in node) || node.children.length !== 1) return false;
    return true;
  }

  // 프레임인 경우 추가 검사
  if (node.type === 'FRAME') {
    // 자식이 1개가 아니면 의미 있음
    if (node.children.length !== 1) return false;

    // Auto Layout이 있으면 의미 있음
    if (node.layoutMode !== 'NONE') return false;

    // 시각적 스타일 검사 (크기 무관하게 스타일만 체크)
    var fills = node.fills;
    // 흰색/투명 배경은 의미 없는 것으로 간주
    var hasMeaningfulFills = Array.isArray(fills) && fills.length > 0 &&
                   fills.some(function(f) {
                     if (f.visible === false) return false;
                     if (f.type !== 'SOLID') return true; // 그라데이션 등은 의미 있음
                     // 흰색(#FFFFFF) 또는 거의 흰색은 무시
                     var c = f.color;
                     var isWhite = c.r > 0.95 && c.g > 0.95 && c.b > 0.95;
                     return !isWhite;
                   });
    var hasStrokes = node.strokes.length > 0 &&
                     node.strokes.some(function(s) { return s.visible !== false; });
    var hasEffects = node.effects.length > 0 &&
                     node.effects.some(function(e) { return e.visible !== false; });

    // 시각적 스타일이 있으면 의미 있음
    if (hasMeaningfulFills || hasStrokes || hasEffects) return false;

    // 클리핑이 활성화되어 있으면 의미 있음
    if (node.clipsContent) return false;

    return true;
  }

  return false;
}

/**
 * 단일 노드 언래핑
 * 래퍼를 제거하고 자식을 부모 레벨로 이동
 *
 * 중요 (2026-01-15):
 * - 절대 위치 = wrapper.x + child.x (상대 좌표를 무시하면 안 됨)
 * - 자식의 래퍼 내 상대 좌표를 반드시 포함해야 함
 */
export function unwrapNode(wrapper: FrameNode | GroupNode): SceneNode | null {
  try {
    if (!('children' in wrapper) || wrapper.children.length !== 1) {
      return null;
    }

    var child = wrapper.children[0];
    var parent = wrapper.parent;

    if (!parent || !('insertChild' in parent)) {
      return null;
    }

    // 래퍼의 인덱스 위치 저장
    var siblings = parent.children;
    var index = siblings.indexOf(wrapper);

    if (index === -1) {
      // 래퍼가 이미 부모에서 제거됨
      return null;
    }

    // Auto Layout 부모인 경우 위치 계산이 다름
    var isParentAutoLayout =
      parent.type === 'FRAME' && parent.layoutMode !== 'NONE';

    // 자식의 절대 위치 계산 (래퍼 위치 + 자식의 래퍼 내 상대 위치)
    var absoluteX = wrapper.x + child.x;
    var absoluteY = wrapper.y + child.y;

    // 자식을 부모로 이동
    parent.insertChild(index, child);

    // 위치 복원 (Auto Layout이 아닌 경우에만)
    // 절대 위치를 유지하도록 설정
    if (!isParentAutoLayout && 'x' in child) {
      child.x = absoluteX;
      child.y = absoluteY;
    }

    // 래퍼 삭제 (이미 삭제되었을 수 있으므로 try-catch)
    try {
      wrapper.remove();
    } catch (e) {
      // 이미 삭제됨 - 무시
    }

    return child;
  } catch (e) {
    // 노드 접근 중 오류 발생 - 이미 삭제된 노드일 수 있음
    console.log('[Cleanup] unwrapNode error:', e);
    return null;
  }
}

/**
 * 재귀적으로 의미 없는 래퍼 제거
 *
 * @param node 대상 노드
 * @param options.aggressive 공격적 모드 (자동 생성 이름 + 자식 1개면 제거)
 */
export function cleanupWrappersRecursive(
  node: SceneNode,
  options?: { aggressive?: boolean }
): {
  removedCount: number;
  removedNames: string[];
} {
  const aggressive = options?.aggressive || false;
  let removedCount = 0;
  const removedNames: string[] = [];

  function shouldRemove(n: SceneNode): boolean {
    if (n.type !== 'FRAME' && n.type !== 'GROUP') return false;

    // 공격적 모드: 자동 생성 이름 + 자식 1개
    if (aggressive && isAutoGeneratedWrapper(n)) {
      return true;
    }

    // 안전 모드: 기존 조건
    return isMeaninglessWrapper(n);
  }

  function isNodeValid(n: SceneNode): boolean {
    try {
      // 노드가 아직 문서에 존재하는지 확인
      return n.parent !== null;
    } catch {
      return false;
    }
  }

  function traverse(n: SceneNode): SceneNode {
    try {
      // 노드가 이미 삭제되었는지 확인
      if (!isNodeValid(n)) {
        return n;
      }

      // 자식이 있는 노드인 경우 먼저 자식들 처리
      if ('children' in n) {
        // children 배열을 복사해서 순회 (중간에 변경될 수 있으므로)
        const children = n.children.slice();
        for (const child of children) {
          try {
            // 자식이 아직 유효한지 확인 후 처리
            if (isNodeValid(child)) {
              traverse(child);
            }
          } catch (childError) {
            // 개별 자식 처리 중 에러는 무시하고 계속 진행
            console.log('[Cleanup] child traverse error:', childError);
          }
        }
      }

      // 노드가 아직 유효한지 다시 확인
      if (!isNodeValid(n)) {
        return n;
      }

      // 현재 노드가 의미 없는 래퍼인지 확인
      if (shouldRemove(n) && (n.type === 'FRAME' || n.type === 'GROUP')) {
        const name = n.name;
        const unwrapped = unwrapNode(n);
        if (unwrapped) {
          removedCount++;
          removedNames.push(name);
          return unwrapped;
        }
      }

      return n;
    } catch (e) {
      console.log('[Cleanup] traverse error:', e);
      return n;
    }
  }

  traverse(node);

  return { removedCount, removedNames };
}

/**
 * 선택된 노드들의 의미 없는 래퍼 제거
 *
 * @param options.aggressive 공격적 모드 (자동 생성 이름 + 자식 1개면 제거)
 */
export function cleanupSelectionWrappers(options?: { aggressive?: boolean }): {
  success: boolean;
  message: string;
  details?: {
    removedCount: number;
    removedNames: string[];
  };
} {
  try {
    const selection = figma.currentPage.selection;

    if (selection.length === 0) {
      return {
        success: false,
        message: '선택된 요소가 없습니다.',
      };
    }

    let totalRemoved = 0;
    const allRemovedNames: string[] = [];

    for (const node of selection) {
      try {
        const result = cleanupWrappersRecursive(node, options);
        totalRemoved += result.removedCount;
        for (const name of result.removedNames) {
          allRemovedNames.push(name);
        }
      } catch (nodeError) {
        console.log('[Cleanup] node processing error:', nodeError);
        // 개별 노드 에러는 무시하고 계속 진행
      }
    }

    if (totalRemoved === 0) {
      return {
        success: true,
        message: '제거할 의미 없는 래퍼가 없습니다.',
        details: { removedCount: 0, removedNames: [] },
      };
    }

    const mode = options?.aggressive ? '(공격적 모드)' : '';
    return {
      success: true,
      message: `${totalRemoved}개의 의미 없는 래퍼가 제거되었습니다. ${mode}`,
      details: {
        removedCount: totalRemoved,
        removedNames: allRemovedNames,
      },
    };
  } catch (e) {
    console.log('[Cleanup] cleanupSelectionWrappers error:', e);
    return {
      success: false,
      message: '정리 중 오류가 발생했습니다: ' + String(e),
    };
  }
}

/**
 * 의미 없는 래퍼 미리보기 (실제 제거 없이 탐지만)
 */
export function previewMeaninglessWrappers(node: SceneNode): {
  count: number;
  wrappers: { id: string; name: string; childName: string }[];
} {
  const wrappers: { id: string; name: string; childName: string }[] = [];

  function traverse(n: SceneNode) {
    if (isMeaninglessWrapper(n) && 'children' in n && n.children.length === 1) {
      wrappers.push({
        id: n.id,
        name: n.name,
        childName: n.children[0].name,
      });
    }

    if ('children' in n) {
      for (const child of n.children) {
        traverse(child);
      }
    }
  }

  traverse(node);

  return { count: wrappers.length, wrappers };
}

// ============================================
// 동일 이름 중첩 레이어 병합 (Flatten Same-Name Wrappers)
// ============================================

interface NestedChain {
  topNode: FrameNode;        // 최상위 노드
  middleNodes: FrameNode[];  // 제거할 중간 노드들
  bottomNode: FrameNode;     // 최하위 (실제 컨텐츠 보유)
  offsetX: number;           // 최상위 대비 누적 오프셋
  offsetY: number;
}

/**
 * 레이아웃 스냅샷 (병합 전후 비교용)
 */
interface LayoutSnapshot {
  width: number;
  height: number;
  childSnapshots: Array<{
    name: string;
    absoluteX: number;  // 페이지 기준 절대 좌표
    absoluteY: number;
    width: number;
    height: number;
  }>;
}

/**
 * 노드와 모든 leaf 자식들의 레이아웃 스냅샷 캡처
 */
function captureLayoutSnapshot(node: FrameNode): LayoutSnapshot {
  const childSnapshots: LayoutSnapshot['childSnapshots'] = [];

  // leaf 노드 타입 체크
  const LEAF_TYPES = ['TEXT', 'VECTOR', 'RECTANGLE', 'ELLIPSE', 'LINE', 'STAR', 'POLYGON', 'BOOLEAN_OPERATION'];

  function collectLeafChildren(n: SceneNode, parentAbsX: number, parentAbsY: number) {
    const absX = parentAbsX + n.x;
    const absY = parentAbsY + n.y;

    // leaf 노드 (자식이 없거나 TEXT/VECTOR 등)
    if (!('children' in n) || LEAF_TYPES.includes(n.type)) {
      childSnapshots.push({
        name: n.name,
        absoluteX: absX,
        absoluteY: absY,
        width: n.width,
        height: n.height,
      });
      return;
    }

    // 프레임/그룹이면 자식 탐색
    const nodeWithChildren = n as SceneNode & { children: readonly SceneNode[] };
    const children = nodeWithChildren.children;
    if (children.length === 0) {
      // 자식 없는 프레임도 leaf로 처리
      childSnapshots.push({
        name: n.name,
        absoluteX: absX,
        absoluteY: absY,
        width: n.width,
        height: n.height,
      });
      return;
    }

    for (const child of children) {
      collectLeafChildren(child, absX, absY);
    }
  }

  // topNode 기준으로 자식들 수집 (topNode의 위치는 0,0으로 취급)
  for (const child of node.children) {
    collectLeafChildren(child, 0, 0);
  }

  return {
    width: node.width,
    height: node.height,
    childSnapshots,
  };
}

/**
 * 병합 전후 레이아웃 변화 검증
 * @returns 위치가 변경된 요소 목록 (5px 이상 차이)
 */
function validateLayoutChange(
  before: LayoutSnapshot,
  after: LayoutSnapshot,
  tolerance: number = 5
): Array<{ name: string; deltaX: number; deltaY: number }> {
  const changes: Array<{ name: string; deltaX: number; deltaY: number }> = [];

  // before 스냅샷의 각 자식을 after에서 찾아서 비교
  for (const beforeChild of before.childSnapshots) {
    const afterChild = after.childSnapshots.find(c => c.name === beforeChild.name);
    if (!afterChild) {
      // 자식이 사라짐 (이름 변경됐을 수 있음)
      changes.push({
        name: beforeChild.name,
        deltaX: Infinity,
        deltaY: Infinity,
      });
      continue;
    }

    const deltaX = Math.abs(afterChild.absoluteX - beforeChild.absoluteX);
    const deltaY = Math.abs(afterChild.absoluteY - beforeChild.absoluteY);

    if (deltaX > tolerance || deltaY > tolerance) {
      changes.push({
        name: beforeChild.name,
        deltaX: afterChild.absoluteX - beforeChild.absoluteX,
        deltaY: afterChild.absoluteY - beforeChild.absoluteY,
      });
    }
  }

  return changes;
}

/**
 * 두 프레임의 크기가 비슷한지 확인 (허용 오차 내)
 */
function isSimilarSize(a: FrameNode, b: FrameNode, tolerance: number = 5): boolean {
  const widthDiff = Math.abs(a.width - b.width);
  const heightDiff = Math.abs(a.height - b.height);
  return widthDiff <= tolerance && heightDiff <= tolerance;
}

/**
 * 단일 자식 체인 탐지 (크기 무관, 2026-01-15 업데이트)
 * - 단일 자식 프레임 체인을 탐지
 * - 크기가 달라도 병합 대상으로 인식 (부모 크기 유지하면서 병합)
 * - 크기 체크 완전 제거됨
 *
 * @param node 시작 노드
 * @param requireSameName true면 동일 이름만 (기존 동작), false면 이름 무관
 */
function findSingleChildChain(node: FrameNode, requireSameName: boolean = false): NestedChain | null {
  // 자식이 1개가 아니면 체인 아님
  if (node.children.length !== 1) return null;

  const child = node.children[0];
  // 자식이 프레임이 아니면 체인 아님
  if (child.type !== 'FRAME') return null;

  // 동일 이름 모드일 때만 이름 체크
  if (requireSameName && child.name !== node.name) return null;

  // 체인 추적 시작
  const chain: FrameNode[] = [node];
  let current: FrameNode = child as FrameNode;
  let totalOffsetX = child.x;
  let totalOffsetY = child.y;

  // 단일 자식 프레임이 계속되는 동안 추적 (크기 무관)
  while (
    current.children.length === 1 &&
    current.children[0].type === 'FRAME' &&
    (!requireSameName || current.children[0].name === current.name)
  ) {
    chain.push(current);
    const nextChild = current.children[0] as FrameNode;
    totalOffsetX += nextChild.x;
    totalOffsetY += nextChild.y;
    current = nextChild;
  }

  // 마지막 노드 추가 (실제 컨텐츠를 가진 노드)
  chain.push(current);

  // 체인이 2개 이상이어야 병합 (top + bottom, 또는 top + middles + bottom)
  if (chain.length < 2) return null;

  return {
    topNode: chain[0],
    middleNodes: chain.slice(1, -1),  // 2개인 경우 빈 배열
    bottomNode: chain[chain.length - 1],
    offsetX: totalOffsetX,
    offsetY: totalOffsetY,
  };
}

/**
 * 체인 내 모든 노드의 스타일을 topNode에 병합
 * - fills: 하위 노드의 fill을 상위에 레이어처럼 추가 (시각적 순서 유지)
 * - strokes: 병합
 * - effects: 병합
 * - cornerRadius: 가장 큰 값 사용
 * - clipsContent: 하나라도 true면 true
 */
function mergeChainStyles(chain: NestedChain): void {
  const { topNode, middleNodes, bottomNode } = chain;
  const allNodes = [topNode, ...middleNodes, bottomNode];

  // 1. Fills 병합 (하위 → 상위 순서로 레이어링, 시각적으로 위에서 아래로)
  const mergedFills: Paint[] = [];
  // reverse 복사본으로 원본 배열 보존
  const nodesBottomToTop = [...allNodes].reverse();
  for (const node of nodesBottomToTop) {
    const fills = node.fills;
    if (Array.isArray(fills)) {
      for (const fill of fills) {
        if (fill.visible !== false) {
          mergedFills.push(JSON.parse(JSON.stringify(fill)));
        }
      }
    }
  }
  if (mergedFills.length > 0) {
    topNode.fills = mergedFills;
  }

  // 2. Strokes 병합
  const mergedStrokes: Paint[] = [];
  for (const node of allNodes) {
    for (const stroke of node.strokes) {
      if (stroke.visible !== false) {
        mergedStrokes.push(JSON.parse(JSON.stringify(stroke)));
      }
    }
  }
  if (mergedStrokes.length > 0) {
    topNode.strokes = mergedStrokes;
  }

  // 3. Effects 병합 (shadow, blur 등)
  const mergedEffects: Effect[] = [];
  for (const node of allNodes) {
    for (const effect of node.effects) {
      if (effect.visible !== false) {
        mergedEffects.push(JSON.parse(JSON.stringify(effect)));
      }
    }
  }
  if (mergedEffects.length > 0) {
    topNode.effects = mergedEffects;
  }

  // 4. clipsContent: 하나라도 true면 true
  topNode.clipsContent = allNodes.some(n => n.clipsContent);

  // 5. cornerRadius: 가장 큰 값 사용
  const radii = allNodes.map(n => {
    if (typeof n.cornerRadius === 'number') return n.cornerRadius;
    return 0;
  });
  const maxRadius = Math.max(...radii);
  if (maxRadius > 0 && typeof topNode.cornerRadius === 'number') {
    topNode.cornerRadius = maxRadius;
  }
}

/**
 * 자식들의 배치로 방향 추론
 */
function inferDirectionFromChildren(children: readonly SceneNode[]): 'HORIZONTAL' | 'VERTICAL' {
  if (children.length < 2) return 'HORIZONTAL';

  const first = children[0];
  const second = children[1];

  const horizontalDiff = Math.abs(first.x - second.x);
  const verticalDiff = Math.abs(first.y - second.y);

  return horizontalDiff > verticalDiff ? 'HORIZONTAL' : 'VERTICAL';
}

/**
 * 동일 이름 중첩 체인 병합
 * - 중간 노드 제거
 * - 최하위의 자식들을 최상위로 이동
 * - topNode 크기와 위치 유지 (크기가 비슷한 경우에만 병합되므로)
 */
function flattenSameNameChain(chain: NestedChain): { success: boolean; layoutIssues?: string[] } {
  const { topNode, middleNodes, bottomNode, offsetX, offsetY } = chain;

  try {
    // 0. 병합 전 레이아웃 스냅샷 캡처
    const beforeSnapshot = captureLayoutSnapshot(topNode);

    // 0.5. 스타일 병합 (fills, strokes, effects 등을 topNode에 병합)
    mergeChainStyles(chain);

    // 1. 최하위 노드의 자식들과 위치 정보 저장
    const bottomChildren = [...bottomNode.children];

    if (bottomChildren.length === 0) {
      return { success: false };
    }

    // 자식들의 원래 위치 정보 저장 (bottomNode 기준 상대 좌표)
    const childInfos = bottomChildren.map(child => ({
      node: child,
      relativeX: child.x,  // bottomNode 내에서의 상대 좌표
      relativeY: child.y,
    }));

    // 2. 원래 크기 저장
    const originalWidth = topNode.width;
    const originalHeight = topNode.height;

    // 3. topNode의 Auto Layout이 있으면 해제 (절대 위치 사용을 위해)
    const wasAutoLayout = topNode.layoutMode !== 'NONE';
    if (wasAutoLayout) {
      topNode.layoutMode = 'NONE';
    }

    // 4. 자식들을 topNode로 이동하면서 절대 위치 계산
    // 새 위치 = 누적 오프셋(offsetX, offsetY) + bottomNode 내 상대 좌표
    for (const childInfo of childInfos) {
      const newX = offsetX + childInfo.relativeX;
      const newY = offsetY + childInfo.relativeY;

      // 자식을 topNode에 추가
      topNode.appendChild(childInfo.node);

      // 절대 위치 설정
      childInfo.node.x = newX;
      childInfo.node.y = newY;
    }

    // 5. topNode 크기 유지 (원래 크기 복원)
    topNode.resize(originalWidth, originalHeight);

    // 6. 중간 노드들 + bottomNode 제거 (역순으로)
    for (let i = middleNodes.length - 1; i >= 0; i--) {
      try {
        middleNodes[i].remove();
      } catch (e) {
        // 이미 제거됨
      }
    }
    try {
      bottomNode.remove();
    } catch (e) {
      // 이미 제거됨
    }

    console.log(`[Flatten] Applied: size=${originalWidth}x${originalHeight}, offset=(${offsetX}, ${offsetY})`);

    // 7. 병합 후 레이아웃 검증
    const afterSnapshot = captureLayoutSnapshot(topNode);
    const layoutChanges = validateLayoutChange(beforeSnapshot, afterSnapshot, 5);

    if (layoutChanges.length > 0) {
      const issues = layoutChanges.map(c =>
        `${c.name}: (${c.deltaX}, ${c.deltaY}) 이동`
      );
      console.log(`[Flatten] 레이아웃 변화 감지:`, issues);
      return { success: true, layoutIssues: issues };
    }

    return { success: true };
  } catch (e) {
    console.log('[Flatten] flattenSameNameChain error:', e);
    return { success: false };
  }
}

/**
 * 재귀적으로 동일 이름 중첩 체인 병합
 */
export function flattenSameNameWrappersRecursive(node: SceneNode): {
  flattenedCount: number;
  flattenedNames: string[];
  layoutIssues: string[];
} {
  let flattenedCount = 0;
  const flattenedNames: string[] = [];
  const layoutIssues: string[] = [];
  let visitedCount = 0;

  function traverse(n: SceneNode) {
    try {
      // 노드가 유효한지 확인
      if (!n.parent) return;

      visitedCount++;

      // 자식이 있는 모든 노드의 자식 먼저 탐색 (깊이 우선)
      if ('children' in n) {
        const children = [...(n as ChildrenMixin).children];
        for (const child of children) {
          traverse(child);
        }
      }

      // FRAME이 아니면 스킵
      if (n.type !== 'FRAME') {
        return;
      }

      // 노드가 아직 유효한지 확인 (자식 탐색 중 제거되었을 수 있음)
      if (!n.parent) return;

      // 단일 자식 체인 탐지 (이름 무관, 2레벨 이상)
      const chain = findSingleChildChain(n as FrameNode, false);  // false = 이름 무관
      if (chain) {
        const name = n.name;
        const depth = chain.middleNodes.length + 2; // top + middles + bottom (2레벨이면 0+2=2)

        console.log(`[Flatten] 체인 발견: ${name} (${depth}중)`);

        const result = flattenSameNameChain(chain);
        if (result.success) {
          flattenedCount++;
          flattenedNames.push(`${name} (${depth}중 → 1)`);
          console.log(`[Flatten] ${name}: ${depth}중 구조를 1개로 병합 완료`);

          // 레이아웃 이슈 수집
          if (result.layoutIssues && result.layoutIssues.length > 0) {
            layoutIssues.push(`${name}: ${result.layoutIssues.join(', ')}`);
          }
        }
      }
    } catch (e) {
      console.log('[Flatten] traverse error:', e);
    }
  }

  console.log(`[Flatten] 탐색 시작: ${node.name}`);
  traverse(node);
  console.log(`[Flatten] 탐색 완료: ${visitedCount}개 노드 방문, ${flattenedCount}개 병합`);

  if (layoutIssues.length > 0) {
    console.log(`[Flatten] 레이아웃 이슈 ${layoutIssues.length}건:`, layoutIssues);
  }

  return { flattenedCount, flattenedNames, layoutIssues };
}

/**
 * 선택된 노드들의 동일 이름 중첩 체인 병합
 */
export function flattenSelectionSameNameWrappers(): {
  success: boolean;
  message: string;
  details?: {
    flattenedCount: number;
    flattenedNames: string[];
    layoutIssues: string[];
  };
} {
  try {
    const selection = figma.currentPage.selection;

    if (selection.length === 0) {
      return {
        success: false,
        message: '선택된 요소가 없습니다.',
      };
    }

    let totalFlattened = 0;
    const allFlattenedNames: string[] = [];
    const allLayoutIssues: string[] = [];

    for (const node of selection) {
      const result = flattenSameNameWrappersRecursive(node);
      totalFlattened += result.flattenedCount;
      allFlattenedNames.push(...result.flattenedNames);
      allLayoutIssues.push(...result.layoutIssues);
    }

    if (totalFlattened === 0) {
      return {
        success: true,
        message: '병합할 중첩 체인이 없습니다.',
        details: { flattenedCount: 0, flattenedNames: [], layoutIssues: [] },
      };
    }

    let message = `${totalFlattened}개의 중첩 체인이 병합되었습니다.`;
    if (allLayoutIssues.length > 0) {
      message += ` (레이아웃 이슈 ${allLayoutIssues.length}건 - 콘솔 확인)`;
    }

    return {
      success: true,
      message,
      details: {
        flattenedCount: totalFlattened,
        flattenedNames: allFlattenedNames,
        layoutIssues: allLayoutIssues,
      },
    };
  } catch (e) {
    console.log('[Flatten] flattenSelectionSameNameWrappers error:', e);
    return {
      success: false,
      message: '병합 중 오류가 발생했습니다: ' + String(e),
    };
  }
}
