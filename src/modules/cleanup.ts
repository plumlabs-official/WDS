/**
 * 레이어 정리 모듈
 *
 * 역할:
 * - 의미 없는 래퍼 그룹/프레임 제거
 * - 자식 노드를 상위 레벨로 언래핑
 */

/**
 * 자동 생성된 이름인지 판단
 * - "Frame 123456" 패턴
 * - "Group 123" 패턴
 * - "Rectangle 1" 패턴
 */
export function isAutoGeneratedName(name: string): boolean {
  return /^(Frame|Group|Rectangle|Ellipse|Line|Vector)\s*\d*$/.test(name);
}

/**
 * 공격적 래퍼 판단 (자동 생성 이름 + 자식 1개면 제거)
 * - 크기/스타일 검사 없이 제거
 * - 최상위 래퍼 제거에 유용
 */
export function isAutoGeneratedWrapper(node: SceneNode): boolean {
  // 이름이 자동 생성 패턴이 아니면 false
  if (!isAutoGeneratedName(node.name)) return false;

  // 그룹인 경우
  if (node.type === 'GROUP') {
    return 'children' in node && node.children.length === 1;
  }

  // 프레임인 경우
  if (node.type === 'FRAME') {
    // 자식이 1개
    if (node.children.length !== 1) return false;

    // Auto Layout이 있으면 의미 있음
    if (node.layoutMode !== 'NONE') return false;

    return true;
  }

  return false;
}

/**
 * 의미 없는 래퍼인지 판단 (안전 모드)
 *
 * 조건:
 * 1. 그룹 또는 프레임
 * 2. 자식이 정확히 1개
 * 3. 자식이 래퍼와 거의 동일한 크기 (레이아웃 보존)
 * 4. 시각적 스타일 없음 (fill, stroke, effect)
 * 5. Auto Layout 없음
 */
export function isMeaninglessWrapper(node: SceneNode): boolean {
  // 그룹인 경우
  if (node.type === 'GROUP') {
    if (!('children' in node) || node.children.length !== 1) return false;

    // 자식이 거의 같은 크기인지 확인 (허용 오차 2px)
    const child = node.children[0];
    const sizeTolerance = 2;
    const sameWidth = Math.abs(node.width - child.width) <= sizeTolerance;
    const sameHeight = Math.abs(node.height - child.height) <= sizeTolerance;

    return sameWidth && sameHeight;
  }

  // 프레임인 경우 추가 검사
  if (node.type === 'FRAME') {
    // 자식이 1개가 아니면 의미 있음
    if (node.children.length !== 1) return false;

    // Auto Layout이 있으면 의미 있음
    if (node.layoutMode !== 'NONE') return false;

    // 자식이 거의 같은 크기인지 확인 (허용 오차 2px)
    const child = node.children[0];
    const sizeTolerance = 2;
    const sameWidth = Math.abs(node.width - child.width) <= sizeTolerance;
    const sameHeight = Math.abs(node.height - child.height) <= sizeTolerance;

    // 크기가 다르면 의미 있는 래퍼 (패딩/마진 역할)
    if (!sameWidth || !sameHeight) return false;

    // 시각적 스타일 검사
    var fills = node.fills;
    // 흰색/투명 배경은 의미 없는 것으로 간주
    var hasMeaningfulFills = Array.isArray(fills) && fills.length > 0 &&
                   fills.some(function(f) {
                     if (f.visible === false) return false;
                     if (f.type !== 'SOLID') return true; // 그라데이션 등은 의미 있음
                     // 흰색(#FFFFFF) 또는 거의 흰색은 무시
                     var c = f.color;
                     var isWhite = c.r > 0.95 && c.g > 0.95 && c.b > 0.95;
                     return !isWhite;
                   });
    var hasStrokes = node.strokes.length > 0 &&
                     node.strokes.some(function(s) { return s.visible !== false; });
    var hasEffects = node.effects.length > 0 &&
                     node.effects.some(function(e) { return e.visible !== false; });

    // 시각적 스타일이 있으면 의미 있음
    if (hasMeaningfulFills || hasStrokes || hasEffects) return false;

    // 클리핑이 활성화되어 있으면 의미 있음
    if (node.clipsContent) return false;

    return true;
  }

  return false;
}

/**
 * 단일 노드 언래핑
 * 래퍼를 제거하고 자식을 부모 레벨로 이동
 */
export function unwrapNode(wrapper: FrameNode | GroupNode): SceneNode | null {
  try {
    if (!('children' in wrapper) || wrapper.children.length !== 1) {
      return null;
    }

    var child = wrapper.children[0];
    var parent = wrapper.parent;

    if (!parent || !('insertChild' in parent)) {
      return null;
    }

    // 래퍼의 인덱스 위치 저장
    var siblings = parent.children;
    var index = siblings.indexOf(wrapper);

    if (index === -1) {
      // 래퍼가 이미 부모에서 제거됨
      return null;
    }

    // Auto Layout 부모인 경우 위치 계산이 다름
    var isParentAutoLayout =
      parent.type === 'FRAME' && parent.layoutMode !== 'NONE';

    // 래퍼의 위치 저장 (자식이 래퍼와 같은 크기면 래퍼 위치를 사용)
    var wrapperX = wrapper.x;
    var wrapperY = wrapper.y;

    // 자식을 부모로 이동
    parent.insertChild(index, child);

    // 위치 복원 (Auto Layout이 아닌 경우에만)
    // 자식이 래퍼와 같은 크기일 때는 래퍼 위치를 그대로 사용
    if (!isParentAutoLayout && 'x' in child) {
      child.x = wrapperX;
      child.y = wrapperY;
    }

    // 래퍼 삭제 (이미 삭제되었을 수 있으므로 try-catch)
    try {
      wrapper.remove();
    } catch (e) {
      // 이미 삭제됨 - 무시
    }

    return child;
  } catch (e) {
    // 노드 접근 중 오류 발생 - 이미 삭제된 노드일 수 있음
    console.log('[Cleanup] unwrapNode error:', e);
    return null;
  }
}

/**
 * 재귀적으로 의미 없는 래퍼 제거
 *
 * @param node 대상 노드
 * @param options.aggressive 공격적 모드 (자동 생성 이름 + 자식 1개면 제거)
 */
export function cleanupWrappersRecursive(
  node: SceneNode,
  options?: { aggressive?: boolean }
): {
  removedCount: number;
  removedNames: string[];
} {
  const aggressive = options?.aggressive || false;
  let removedCount = 0;
  const removedNames: string[] = [];

  function shouldRemove(n: SceneNode): boolean {
    if (n.type !== 'FRAME' && n.type !== 'GROUP') return false;

    // 공격적 모드: 자동 생성 이름 + 자식 1개
    if (aggressive && isAutoGeneratedWrapper(n)) {
      return true;
    }

    // 안전 모드: 기존 조건
    return isMeaninglessWrapper(n);
  }

  function isNodeValid(n: SceneNode): boolean {
    try {
      // 노드가 아직 문서에 존재하는지 확인
      return n.parent !== null;
    } catch {
      return false;
    }
  }

  function traverse(n: SceneNode): SceneNode {
    try {
      // 노드가 이미 삭제되었는지 확인
      if (!isNodeValid(n)) {
        return n;
      }

      // 자식이 있는 노드인 경우 먼저 자식들 처리
      if ('children' in n) {
        // children 배열을 복사해서 순회 (중간에 변경될 수 있으므로)
        const children = n.children.slice();
        for (const child of children) {
          try {
            // 자식이 아직 유효한지 확인 후 처리
            if (isNodeValid(child)) {
              traverse(child);
            }
          } catch (childError) {
            // 개별 자식 처리 중 에러는 무시하고 계속 진행
            console.log('[Cleanup] child traverse error:', childError);
          }
        }
      }

      // 노드가 아직 유효한지 다시 확인
      if (!isNodeValid(n)) {
        return n;
      }

      // 현재 노드가 의미 없는 래퍼인지 확인
      if (shouldRemove(n) && (n.type === 'FRAME' || n.type === 'GROUP')) {
        const name = n.name;
        const unwrapped = unwrapNode(n);
        if (unwrapped) {
          removedCount++;
          removedNames.push(name);
          return unwrapped;
        }
      }

      return n;
    } catch (e) {
      console.log('[Cleanup] traverse error:', e);
      return n;
    }
  }

  traverse(node);

  return { removedCount, removedNames };
}

/**
 * 선택된 노드들의 의미 없는 래퍼 제거
 *
 * @param options.aggressive 공격적 모드 (자동 생성 이름 + 자식 1개면 제거)
 */
export function cleanupSelectionWrappers(options?: { aggressive?: boolean }): {
  success: boolean;
  message: string;
  details?: {
    removedCount: number;
    removedNames: string[];
  };
} {
  try {
    const selection = figma.currentPage.selection;

    if (selection.length === 0) {
      return {
        success: false,
        message: '선택된 요소가 없습니다.',
      };
    }

    let totalRemoved = 0;
    const allRemovedNames: string[] = [];

    for (const node of selection) {
      try {
        const result = cleanupWrappersRecursive(node, options);
        totalRemoved += result.removedCount;
        for (const name of result.removedNames) {
          allRemovedNames.push(name);
        }
      } catch (nodeError) {
        console.log('[Cleanup] node processing error:', nodeError);
        // 개별 노드 에러는 무시하고 계속 진행
      }
    }

    if (totalRemoved === 0) {
      return {
        success: true,
        message: '제거할 의미 없는 래퍼가 없습니다.',
        details: { removedCount: 0, removedNames: [] },
      };
    }

    const mode = options?.aggressive ? '(공격적 모드)' : '';
    return {
      success: true,
      message: `${totalRemoved}개의 의미 없는 래퍼가 제거되었습니다. ${mode}`,
      details: {
        removedCount: totalRemoved,
        removedNames: allRemovedNames,
      },
    };
  } catch (e) {
    console.log('[Cleanup] cleanupSelectionWrappers error:', e);
    return {
      success: false,
      message: '정리 중 오류가 발생했습니다: ' + String(e),
    };
  }
}

/**
 * 의미 없는 래퍼 미리보기 (실제 제거 없이 탐지만)
 */
export function previewMeaninglessWrappers(node: SceneNode): {
  count: number;
  wrappers: { id: string; name: string; childName: string }[];
} {
  const wrappers: { id: string; name: string; childName: string }[] = [];

  function traverse(n: SceneNode) {
    if (isMeaninglessWrapper(n) && 'children' in n && n.children.length === 1) {
      wrappers.push({
        id: n.id,
        name: n.name,
        childName: n.children[0].name,
      });
    }

    if ('children' in n) {
      for (const child of n.children) {
        traverse(child);
      }
    }
  }

  traverse(node);

  return { count: wrappers.length, wrappers };
}
