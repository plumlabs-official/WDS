# Cleanup Agent (래퍼 제거)

## 개요

| 항목 | 내용 |
|------|------|
| **타입** | 룰 베이스 |
| **역할** | 의미 없는 래퍼 프레임/그룹 제거 |
| **실행 순서** | 1번째 (전처리) |
| **소스 파일** | `src/modules/cleanup.ts` |

## 목적

Figma에서 디자인 작업 시 생성되는 불필요한 중첩 구조를 제거하여:
- 레이어 구조 단순화
- Auto Layout 적용 용이성 향상
- AI 코드 생성 시 불필요한 래퍼 div 방지

## 입력/출력

### 입력
```typescript
interface CleanupInput {
  selection: SceneNode[];  // Figma에서 선택된 노드들
}
```

### 출력
```typescript
interface CleanupOutput {
  success: boolean;
  message: string;
  details?: {
    removedCount: number;
    removedNames: string[];
  };
}
```

## 판단 룰

### 두 가지 모드

| 모드 | 함수 | 설명 |
|------|------|------|
| **안전 모드** | `isMeaninglessWrapper()` | 모든 조건을 엄격하게 검사 |
| **공격적 모드** | `isAutoGeneratedWrapper()` | 자동 생성 이름 + 자식 1개면 제거 |

### 안전 모드 조건 (모두 충족 시)

```
┌─────────────────────────────────────────────────────┐
│              isMeaninglessWrapper()                  │
├─────────────────────────────────────────────────────┤
│ 1. 타입이 GROUP 또는 FRAME                           │
│ 2. 자식이 정확히 1개                                  │
│ 3. Auto Layout 없음 (layoutMode === 'NONE')         │
│ 4. 의미 있는 fill 없음 (흰색/투명 제외)                │
│ 5. stroke 없음                                       │
│ 6. effect 없음                                       │
│ 7. clipsContent === false                           │
│                                                     │
│ ※ 크기 체크 제거됨 (2026-01-15)                      │
│   - 단일 자식이면 크기와 관계없이 병합 대상           │
└─────────────────────────────────────────────────────┘
```

### 공격적 모드 조건

```
┌─────────────────────────────────────────────────────┐
│              isAutoGeneratedWrapper()                │
├─────────────────────────────────────────────────────┤
│ 1. 이름이 자동 생성 패턴                              │
│    - "Frame 123456"                                 │
│    - "Group 123"                                    │
│    - "Rectangle 1" 등                               │
│ 2. 자식이 정확히 1개                                  │
│ 3. Auto Layout 없음 (FRAME인 경우)                   │
│                                                     │
│ ※ 크기/스타일 검사 없음 → 더 많은 래퍼 제거            │
└─────────────────────────────────────────────────────┘
```

### 자동 생성 이름 패턴

```typescript
function isAutoGeneratedName(name: string): boolean {
  return /^(Frame|Group|Rectangle|Ellipse|Line|Vector)\s*\d*$/.test(name);
}

// 매칭 예시
"Frame 1430107280"  // ✓
"Group 123"         // ✓
"Frame"             // ✓
"Rectangle 1"       // ✓
"Button"            // ✗
"이름입력 7"         // ✗
```

### 상세 룰

#### 1. 자식 개수 검사
```typescript
if (node.children.length !== 1) return false;
```

#### 2. 크기 비교 (제거됨 - 2026-01-15)
```typescript
// ❌ 이전 코드 (제거됨)
// const sizeTolerance = 2;
// const sameWidth = Math.abs(node.width - child.width) <= sizeTolerance;
// const sameHeight = Math.abs(node.height - child.height) <= sizeTolerance;
// if (!sameWidth || !sameHeight) return false;

// ✓ 현재: 크기 체크 없음 - 단일 자식이면 크기와 관계없이 병합 대상
```

#### 3. 시각적 스타일 검사
```typescript
// Fill 검사 - 흰색/투명은 무시
const hasMeaningfulFills = fills.some(f => {
  if (f.visible === false) return false;
  if (f.type !== 'SOLID') return true;  // 그라데이션 등은 의미 있음
  // 흰색(r,g,b > 0.95)은 무시
  return !(c.r > 0.95 && c.g > 0.95 && c.b > 0.95);
});

// Stroke 검사
const hasStrokes = node.strokes.some(s => s.visible !== false);

// Effect 검사
const hasEffects = node.effects.some(e => e.visible !== false);
```

#### 4. 클리핑 검사
```typescript
if (node.clipsContent) return false;  // 클리핑은 의미 있음
```

## 처리 로직

### 언래핑 프로세스

```
Before:                    After:
┌─ Wrapper ──────┐         ┌─ Child ──────┐
│  ┌─ Child ──┐  │   →     │  (content)   │
│  │ (content)│  │         └──────────────┘
│  └──────────┘  │
└────────────────┘
```

```typescript
function unwrapNode(wrapper) {
  const child = wrapper.children[0];
  const parent = wrapper.parent;
  const index = parent.children.indexOf(wrapper);

  // 절대 위치 계산 (래퍼 위치 + 자식의 래퍼 내 상대 위치)
  const absoluteX = wrapper.x + child.x;
  const absoluteY = wrapper.y + child.y;

  // 자식을 부모로 이동
  parent.insertChild(index, child);

  // 위치 복원 (Auto Layout이 아닌 경우)
  if (!isParentAutoLayout) {
    child.x = absoluteX;
    child.y = absoluteY;
  }

  // 래퍼 삭제
  wrapper.remove();
}
```

> **주의**: 자식의 상대 좌표를 무시하면 아이콘 등이 잘못된 위치로 이동합니다.
> 반드시 `wrapper.x + child.x` 패턴을 사용하세요.

### 재귀 처리

```typescript
// 깊이 우선 탐색 (자식부터 처리)
function traverse(node) {
  // 1. 자식 먼저 처리
  if ('children' in node) {
    for (const child of node.children.slice()) {
      traverse(child);
    }
  }

  // 2. 현재 노드가 래퍼인지 확인 후 제거
  if (isMeaninglessWrapper(node)) {
    unwrapNode(node);
  }
}
```

## 예외 케이스

### 제거하면 안 되는 경우

| 케이스 | 이유 |
|--------|------|
| 배경색이 있는 프레임 | 시각적 역할 |
| 테두리가 있는 프레임 | 시각적 역할 |
| 그림자가 있는 프레임 | 시각적 역할 |
| Auto Layout 적용됨 | 레이아웃 역할 |
| 클리핑 활성화 | 마스킹 역할 |

> **변경 (2026-01-15)**: "자식과 크기가 다름" 조건 제거됨.
> 이제 크기가 달라도 단일 자식이면 병합 대상입니다.

### 알려진 한계

1. **호버/상태 래퍼**: 인터랙션을 위한 래퍼는 감지 불가
2. **애니메이션 래퍼**: Smart Animate용 래퍼 감지 불가
3. **의도적 그룹핑**: 논리적 그룹은 시각적으로 판단 불가

## 사용 예시

### Figma 플러그인에서
```
1. 정리할 프레임 선택
2. 플러그인 메뉴 > "의미 없는 래퍼 제거" 실행
3. 콘솔에서 제거된 래퍼 목록 확인
```

### 프로그래매틱

**안전 모드 (기본)**
```typescript
import { cleanupSelectionWrappers } from './modules/cleanup';

const result = cleanupSelectionWrappers();
console.log(`${result.details.removedCount}개 래퍼 제거됨`);
```

**공격적 모드** (자동 생성 이름 래퍼 제거)
```typescript
import { cleanupSelectionWrappers } from './modules/cleanup';

const result = cleanupSelectionWrappers({ aggressive: true });
// "Frame 1430107280" 같은 자동 생성 이름 래퍼도 제거
console.log(`${result.details.removedCount}개 래퍼 제거됨 (공격적 모드)`);
```

### 개별 함수 사용
```typescript
import {
  isAutoGeneratedName,
  isAutoGeneratedWrapper,
  isMeaninglessWrapper,
  cleanupWrappersRecursive
} from './modules/cleanup';

// 이름 패턴 확인
isAutoGeneratedName("Frame 1430107280");  // true
isAutoGeneratedName("Button");            // false

// 재귀 제거 (공격적 모드)
const result = cleanupWrappersRecursive(node, { aggressive: true });
```

## 개선 이력

- [x] 이름 패턴 기반 래퍼 감지 (예: "Frame 123456") - 공격적 모드로 구현
- [x] 두 가지 모드 지원 (안전/공격적)

## 개선 예정

- [ ] 사용자 정의 예외 룰 추가
- [ ] 미리보기 UI 제공
- [ ] 플러그인 메뉴에 "공격적 모드" 옵션 추가
