/**
 * 레이어 정리 모듈
 *
 * 역할:
 * - 의미 없는 래퍼 그룹/프레임 제거
 * - 자식 노드를 상위 레벨로 언래핑
 *
 * ⚠️ CLEANUP 작업 체크리스트 (수정 전 확인):
 * - getNodeByIdAsync 사용 (getNodeById 금지, dynamic-page 모드)
 * - 캐시 clear는 진입점 함수에서만 (반복 함수 내부 금지)
 * - 노드 삭제 전 필요한 속성(.name 등) 미리 저장
 * - children 배열 복사 후 순회: [...node.children]
 * - 좌표 계산에서 절대/상대 구분
 *
 * 상세 패턴: .ai/lessons_learned.md 참조
 */

import { isShapeType, isBasicShapeType } from '../constants';
import { AGENT_SERVER_URL } from '../config/env';

/**
 * 자동 생성된 이름인지 판단
 * - "Frame 123456" 패턴
 * - "Group 123" 패턴
 * - "Rectangle 1" 패턴
 */
export function isAutoGeneratedName(name: string): boolean {
  return /^(Frame|Group|Rectangle|Ellipse|Line|Vector)\s*\d*$/.test(name);
}

/**
 * 노드 이동 후 layoutPositioning을 AUTO로 리셋
 *
 * 문제: insertChild/appendChild로 노드를 다른 부모로 이동시킬 때
 * layoutPositioning이 ABSOLUTE로 변경되어 "Ignore auto-layout"이 활성화됨
 *
 * 해결: 이동 후 명시적으로 AUTO로 설정
 */
function resetLayoutPositioning(node: SceneNode): void {
  try {
    // layoutPositioning은 Auto Layout 자식에만 존재
    if ('layoutPositioning' in node) {
      const asLayoutChild = node as SceneNode & { layoutPositioning: 'AUTO' | 'ABSOLUTE' };
      if (asLayoutChild.layoutPositioning === 'ABSOLUTE') {
        asLayoutChild.layoutPositioning = 'AUTO';
        console.log(`[Cleanup] layoutPositioning 리셋: "${node.name}" ABSOLUTE → AUTO`);
      }
    }
  } catch (e) {
    // 부모가 Auto Layout이 아닌 경우 무시
  }
}

// ============================================
// AI 기반 Cleanup 검증
// ============================================

interface CleanupDifference {
  element: string;
  issue: 'position' | 'size' | 'visibility' | 'style';
  description: string;
  fix: {
    nodeId: string;
    action: 'move' | 'resize' | 'show' | 'setStyle';
    params: Record<string, number | string>;
  };
}

interface CleanupValidationResult {
  isIdentical: boolean;
  differences?: CleanupDifference[];
  summary?: string;
}

/**
 * 노드 스크린샷 캡처 (base64)
 */
async function captureNodeScreenshot(node: SceneNode): Promise<string> {
  const bytes = await node.exportAsync({
    format: 'PNG',
    constraint: { type: 'SCALE', value: 1 },
  });
  return figma.base64Encode(bytes);
}

/**
 * Agent Server에 cleanup 검증 요청
 */
async function callCleanupValidator(
  beforeScreenshot: string,
  afterScreenshot: string,
  nodeId: string,
  nodeName: string,
  operationType: 'flatten' | 'cleanup'
): Promise<CleanupValidationResult | null> {
  try {
    // 30초 타임아웃 (Promise.race 사용 - Figma 플러그인 환경에서 AbortController 미지원)
    const timeoutPromise = new Promise<Response>((_, reject) => {
      setTimeout(() => reject(new Error('Timeout')), 30000);
    });

    const fetchPromise = fetch(`${AGENT_SERVER_URL}/agents/cleanup/validate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        beforeScreenshot,
        afterScreenshot,
        nodeId,
        nodeName,
        operationType,
      }),
    });

    const response = await Promise.race([fetchPromise, timeoutPromise]);

    if (!response.ok) {
      console.log(`[Cleanup Validator] HTTP error: ${response.status}`);
      return null;
    }

    const result = await response.json();
    if (result.success && result.data) {
      return result.data as CleanupValidationResult;
    }
    console.log(`[Cleanup Validator] API error: ${result.error}`);
    return null;
  } catch (e: unknown) {
    if (e instanceof Error && e.message === 'Timeout') {
      console.log(`[Cleanup Validator] 타임아웃 (30초)`);
    } else {
      console.log(`[Cleanup Validator] Network error:`, e);
    }
    return null;
  }
}

/**
 * AI가 제안한 복원 지시 적용
 */
function applyCleanupFixes(
  topNode: FrameNode,
  differences: CleanupDifference[]
): { applied: number; failed: number } {
  let applied = 0;
  let failed = 0;

  for (const diff of differences) {
    try {
      // nodeId가 unknown이면 이름으로 찾기
      let targetNode: SceneNode | null = null;
      if (diff.fix.nodeId !== 'unknown') {
        targetNode = figma.getNodeById(diff.fix.nodeId) as SceneNode | null;
      }
      if (!targetNode) {
        // 이름으로 검색 (topNode 내에서)
        targetNode = topNode.findOne(n => n.name.includes(diff.element));
      }

      if (!targetNode) {
        console.log(`[Cleanup Fix] 노드를 찾을 수 없음: ${diff.element}`);
        failed++;
        continue;
      }

      switch (diff.fix.action) {
        case 'move':
          if ('x' in targetNode) {
            targetNode.x = Number(diff.fix.params.x);
            targetNode.y = Number(diff.fix.params.y);
            console.log(`[Cleanup Fix] ${diff.element} 이동: (${diff.fix.params.x}, ${diff.fix.params.y})`);
            applied++;
          }
          break;
        case 'resize':
          if ('resize' in targetNode) {
            (targetNode as FrameNode).resize(
              Number(diff.fix.params.width),
              Number(diff.fix.params.height)
            );
            console.log(`[Cleanup Fix] ${diff.element} 크기 변경: ${diff.fix.params.width}x${diff.fix.params.height}`);
            applied++;
          }
          break;
        case 'show':
          targetNode.visible = true;
          console.log(`[Cleanup Fix] ${diff.element} 표시`);
          applied++;
          break;
        default:
          console.log(`[Cleanup Fix] 미지원 액션: ${diff.fix.action}`);
          failed++;
      }
    } catch (e) {
      console.log(`[Cleanup Fix] 에러:`, e);
      failed++;
    }
  }

  return { applied, failed };
}

/**
 * 공격적 래퍼 판단 (자동 생성 이름 + 자식 1개면 제거)
 * - 크기/스타일 검사 없이 제거
 * - 최상위 래퍼 제거에 유용
 */
export function isAutoGeneratedWrapper(node: SceneNode): boolean {
  // 이름이 자동 생성 패턴이 아니면 false
  if (!isAutoGeneratedName(node.name)) return false;

  // 그룹인 경우
  if (node.type === 'GROUP') {
    return 'children' in node && node.children.length === 1;
  }

  // 프레임인 경우
  if (node.type === 'FRAME') {
    // 자식이 1개
    if (node.children.length !== 1) return false;

    // Auto Layout이 있으면 의미 있음
    if (node.layoutMode !== 'NONE') return false;

    return true;
  }

  return false;
}

/**
 * 의미 없는 래퍼인지 판단 (안전 모드)
 *
 * 조건 (2026-01-15 업데이트):
 * 1. 그룹 또는 프레임
 * 2. 자식이 정확히 1개
 * 3. 시각적 스타일 없음 (fill, stroke, effect) - 프레임만
 * 4. Auto Layout 없음 - 프레임만
 * 5. 자식이 부모 영역 내에 정상 위치 (NEW)
 *
 * 이름과 관계없이 구조적으로 불필요한 래퍼를 제거
 */
// 자손 중에 shape이 있는지 재귀적으로 검사
function hasShapeDescendant(node: SceneNode, depth: number = 0): boolean {
  if (depth > 3) return false; // 최대 3레벨만 검사

  if (isShapeType(node.type)) {
    return true;
  }

  if ('children' in node) {
    for (var i = 0; i < node.children.length; i++) {
      if (hasShapeDescendant(node.children[i], depth + 1)) {
        return true;
      }
    }
  }
  return false;
}

export function isMeaninglessWrapper(node: SceneNode): boolean {
  // ★ 부모가 GROUP인 경우 보존 (GROUP bounding box 재계산으로 좌표 틀어짐 방지)
  var parent = node.parent;
  if (parent && parent.type === 'GROUP') {
    console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 부모가 GROUP`);
    return false;
  }

  // ★ 자동 생성 이름이 아니면 보존 (의도적으로 만든 프레임)
  if (!isAutoGeneratedName(node.name)) {
    return false;
  }

  // 이름 기반 보호 - 이미지/아바타 관련 프레임은 보존
  var PROTECTED_KEYWORDS = ['user', 'avatar', 'pic', 'photo', 'image', 'profile', 'thumbnail', 'icon'];
  var lowerName = node.name.toLowerCase();
  for (var i = 0; i < PROTECTED_KEYWORDS.length; i++) {
    if (lowerName.indexOf(PROTECTED_KEYWORDS[i]) !== -1) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 보호된 키워드 (${PROTECTED_KEYWORDS[i]})`);
      return false;
    }
  }

  // 그룹인 경우: 단일 자식이면 병합 대상
  if (node.type === 'GROUP') {
    if (!('children' in node) || node.children.length !== 1) return false;

    // 자식 좌표가 비정상이면 제거하지 않음 (버그 방지)
    var groupChild = node.children[0];
    if (groupChild.x < -10 || groupChild.y < -10 ||
        groupChild.x > node.width + 10 || groupChild.y > node.height + 10) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 자식 좌표 비정상 (x=${groupChild.x}, y=${groupChild.y})`);
      return false;
    }

    // 자식이 원점(0,0) 근처에 없으면 래퍼가 아님 (위치 오프셋 역할)
    // 허용 오차: 5px (2026-01-16 추가)
    if (groupChild.x > 5 || groupChild.y > 5) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 자식이 원점에서 떨어져 있음 (x=${groupChild.x}, y=${groupChild.y})`);
      return false;
    }

    // 자식이 shape 타입이면 래퍼가 아님 (시각적 컨테이너 역할)
    if (isShapeType(groupChild.type)) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 자식이 shape 타입 (${groupChild.type})`);
      return false;
    }

    return true;
  }

  // 프레임인 경우 추가 검사
  if (node.type === 'FRAME') {
    // 자식이 1개가 아니면 의미 있음
    if (node.children.length !== 1) return false;

    var frameChild = node.children[0];

    // 자식 좌표가 부모 범위를 벗어나면 제거하지 않음 (버그 방지)
    // 허용 오차: -10 ~ 부모크기+10
    if (frameChild.x < -10 || frameChild.y < -10 ||
        frameChild.x > node.width + 10 || frameChild.y > node.height + 10) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 자식 좌표 비정상 (x=${frameChild.x}, y=${frameChild.y}, 부모=${node.width}x${node.height})`);
      return false;
    }

    // 자식이 원점(0,0) 근처에 없으면 래퍼가 아님 (위치 오프셋 역할)
    // 허용 오차: 5px (2026-01-16 추가 - 오프셋 래퍼 보존)
    if (frameChild.x > 5 || frameChild.y > 5) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 자식이 원점에서 떨어져 있음 (x=${frameChild.x}, y=${frameChild.y})`);
      return false;
    }

    // 자식이 shape 타입이면 래퍼가 아님 (시각적 컨테이너 역할)
    if (isShapeType(frameChild.type)) {
      console.log(`[isMeaninglessWrapper] 스킵: ${node.name} - 자식이 shape 타입 (${frameChild.type})`);
      return false;
    }

    // Auto Layout이 있으면 의미 있음
    if (node.layoutMode !== 'NONE') return false;

    // 시각적 스타일 검사 (크기 무관하게 스타일만 체크)
    var fills = node.fills;
    // 흰색/투명 배경은 의미 없는 것으로 간주
    var hasMeaningfulFills = Array.isArray(fills) && fills.length > 0 &&
                   fills.some(function(f) {
                     if (f.visible === false) return false;
                     if (f.type !== 'SOLID') return true; // 그라데이션 등은 의미 있음
                     // 흰색(#FFFFFF) 또는 거의 흰색은 무시
                     var c = f.color;
                     var isWhite = c.r > 0.95 && c.g > 0.95 && c.b > 0.95;
                     return !isWhite;
                   });
    var hasStrokes = node.strokes.length > 0 &&
                     node.strokes.some(function(s) { return s.visible !== false; });
    var hasEffects = node.effects.length > 0 &&
                     node.effects.some(function(e) { return e.visible !== false; });

    // 시각적 스타일이 있으면 의미 있음
    if (hasMeaningfulFills || hasStrokes || hasEffects) return false;

    // 클리핑이 활성화되어 있으면 의미 있음
    if (node.clipsContent) return false;

    return true;
  }

  return false;
}

/**
 * 단일 노드 언래핑
 * 래퍼를 제거하고 자식을 부모 레벨로 이동
 *
 * 중요 (2026-01-15):
 * - 절대 위치 = wrapper.x + child.x (상대 좌표를 무시하면 안 됨)
 * - 자식의 래퍼 내 상대 좌표를 반드시 포함해야 함
 * - 자식 좌표가 비정상이면 언래핑 스킵 (버그 방지)
 */
export function unwrapNode(wrapper: FrameNode | GroupNode): SceneNode | null {
  try {
    if (!('children' in wrapper) || wrapper.children.length !== 1) {
      return null;
    }

    var child = wrapper.children[0];
    var parent = wrapper.parent;

    if (!parent || !('insertChild' in parent)) {
      return null;
    }

    // 안전 검사: 자식 좌표가 래퍼 범위를 벗어나면 스킵
    // (비정상적인 좌표는 데이터 손상 또는 특수 구조를 의미)
    if (child.x < -50 || child.y < -50 ||
        child.x > wrapper.width + 50 || child.y > wrapper.height + 50) {
      console.log(`[unwrapNode] 스킵: ${wrapper.name} - 자식 좌표 비정상 (child.x=${child.x}, child.y=${child.y}, wrapper=${wrapper.width}x${wrapper.height})`);
      return null;
    }

    // 래퍼의 인덱스 위치 저장
    var siblings = parent.children;
    var index = siblings.indexOf(wrapper);

    if (index === -1) {
      // 래퍼가 이미 부모에서 제거됨
      return null;
    }

    // Auto Layout 부모인 경우 위치 계산이 다름
    var isParentAutoLayout =
      parent.type === 'FRAME' && parent.layoutMode !== 'NONE';

    // 자식의 절대 위치 계산 (래퍼 위치 + 자식의 래퍼 내 상대 위치)
    var absoluteX = wrapper.x + child.x;
    var absoluteY = wrapper.y + child.y;

    // 최종 좌표 검증: 계산된 값이 비정상이면 스킵
    if (Math.abs(absoluteX) > 10000 || Math.abs(absoluteY) > 10000) {
      console.log(`[unwrapNode] 스킵: ${wrapper.name} - 계산된 좌표 비정상 (absoluteX=${absoluteX}, absoluteY=${absoluteY})`);
      return null;
    }

    // 자식을 부모로 이동
    parent.insertChild(index, child);

    // 위치 복원 (Auto Layout이 아닌 경우에만)
    // 절대 위치를 유지하도록 설정
    if (!isParentAutoLayout && 'x' in child) {
      child.x = absoluteX;
      child.y = absoluteY;
    }

    // 래퍼 삭제 (이미 삭제되었을 수 있으므로 try-catch)
    try {
      wrapper.remove();
    } catch (e) {
      // 이미 삭제됨 - 무시
    }

    return child;
  } catch (e) {
    // 노드 접근 중 오류 발생 - 이미 삭제된 노드일 수 있음
    console.log('[Cleanup] unwrapNode error:', e);
    return null;
  }
}

// ============================================
// 동일 이름 중첩 레이어 병합 (Flatten Same-Name Wrappers)
// ============================================

interface NestedChain {
  topNode: FrameNode;        // 최상위 노드
  middleNodes: FrameNode[];  // 제거할 중간 노드들
  bottomNode: FrameNode;     // 최하위 (실제 컨텐츠 보유)
  offsetX: number;           // 최상위 대비 누적 오프셋
  offsetY: number;
}

/**
 * 병합 후보 정보 (Human in the Loop용)
 */
export interface MergeCandidate {
  id: string;                 // topNode.id
  name: string;               // 체인 이름
  depth: number;              // 중첩 깊이 (예: 3중)
  hierarchy: string[];        // 계층 구조 (예: ['textfield+dsc', 'textfield+dsc', 'textfield'])
  childrenPreview: string[];  // 최종 자식 미리보기 (예: ['text "매일..."', 'Frame 123'])
  size: { width: number; height: number };
}

/**
 * 레이아웃 스냅샷 (병합 전후 비교용)
 */
interface LayoutSnapshot {
  width: number;
  height: number;
  childSnapshots: Array<{
    name: string;
    absoluteX: number;  // 페이지 기준 절대 좌표
    absoluteY: number;
    width: number;
    height: number;
  }>;
}

/**
 * 노드와 모든 leaf 자식들의 레이아웃 스냅샷 캡처
 */
function captureLayoutSnapshot(node: FrameNode): LayoutSnapshot {
  const childSnapshots: LayoutSnapshot['childSnapshots'] = [];

  // leaf 노드 타입 체크
  const LEAF_TYPES = ['TEXT', 'VECTOR', 'RECTANGLE', 'ELLIPSE', 'LINE', 'STAR', 'POLYGON', 'BOOLEAN_OPERATION'];

  function collectLeafChildren(n: SceneNode, parentAbsX: number, parentAbsY: number) {
    const absX = parentAbsX + n.x;
    const absY = parentAbsY + n.y;

    // leaf 노드 (자식이 없거나 TEXT/VECTOR 등)
    if (!('children' in n) || LEAF_TYPES.includes(n.type)) {
      childSnapshots.push({
        name: n.name,
        absoluteX: absX,
        absoluteY: absY,
        width: n.width,
        height: n.height,
      });
      return;
    }

    // 프레임/그룹이면 자식 탐색
    const nodeWithChildren = n as SceneNode & { children: readonly SceneNode[] };
    const children = nodeWithChildren.children;
    if (children.length === 0) {
      // 자식 없는 프레임도 leaf로 처리
      childSnapshots.push({
        name: n.name,
        absoluteX: absX,
        absoluteY: absY,
        width: n.width,
        height: n.height,
      });
      return;
    }

    for (const child of children) {
      collectLeafChildren(child, absX, absY);
    }
  }

  // topNode 기준으로 자식들 수집 (topNode의 위치는 0,0으로 취급)
  for (const child of node.children) {
    collectLeafChildren(child, 0, 0);
  }

  return {
    width: node.width,
    height: node.height,
    childSnapshots,
  };
}

/**
 * 병합 전후 레이아웃 변화 검증
 * @returns 위치가 변경된 요소 목록 (5px 이상 차이)
 */
function validateLayoutChange(
  before: LayoutSnapshot,
  after: LayoutSnapshot,
  tolerance: number = 5
): Array<{ name: string; deltaX: number; deltaY: number }> {
  const changes: Array<{ name: string; deltaX: number; deltaY: number }> = [];

  // before 스냅샷의 각 자식을 after에서 찾아서 비교
  for (const beforeChild of before.childSnapshots) {
    const afterChild = after.childSnapshots.find(c => c.name === beforeChild.name);
    if (!afterChild) {
      // 자식이 사라짐 (이름 변경됐을 수 있음)
      changes.push({
        name: beforeChild.name,
        deltaX: Infinity,
        deltaY: Infinity,
      });
      continue;
    }

    const deltaX = Math.abs(afterChild.absoluteX - beforeChild.absoluteX);
    const deltaY = Math.abs(afterChild.absoluteY - beforeChild.absoluteY);

    if (deltaX > tolerance || deltaY > tolerance) {
      changes.push({
        name: beforeChild.name,
        deltaX: afterChild.absoluteX - beforeChild.absoluteX,
        deltaY: afterChild.absoluteY - beforeChild.absoluteY,
      });
    }
  }

  return changes;
}

/**
 * 두 프레임의 크기가 비슷한지 확인 (허용 오차 내)
 */
function isSimilarSize(a: FrameNode, b: FrameNode, tolerance: number = 5): boolean {
  const widthDiff = Math.abs(a.width - b.width);
  const heightDiff = Math.abs(a.height - b.height);
  return widthDiff <= tolerance && heightDiff <= tolerance;
}

/**
 * Auto Layout 프레임이 무의미한 래퍼인지 확인
 * 조건:
 * - 패딩이 없거나 무의미 (< 4px)
 * - 시각적 스타일이 없음 (stroke, effect, cornerRadius 없음)
 * - fill은 자식에게 이전 가능하므로 무시
 */
function isEmptyAutoLayoutWrapper(node: FrameNode): boolean {
  // 패딩 체크 (4px 미만이면 무의미)
  const PADDING_THRESHOLD = 4;
  if (node.paddingTop >= PADDING_THRESHOLD ||
      node.paddingRight >= PADDING_THRESHOLD ||
      node.paddingBottom >= PADDING_THRESHOLD ||
      node.paddingLeft >= PADDING_THRESHOLD) {
    return false;
  }

  // cornerRadius 체크
  if (typeof node.cornerRadius === 'number' && node.cornerRadius > 0) {
    return false;
  }

  // strokes 체크
  if (node.strokes && node.strokes.length > 0) {
    for (const s of node.strokes) {
      if (s.visible !== false) return false;
    }
  }

  // effects 체크
  if (node.effects && node.effects.length > 0) {
    for (const e of node.effects) {
      if (e.visible !== false) return false;
    }
  }

  // fill은 자식에게 이전 가능하므로 체크 안 함
  return true;
}

/**
 * 단일 자식 체인 탐지 (크기 유사성 체크 추가, 2026-01-15 수정)
 * - 단일 자식 프레임 체인을 탐지
 * - 크기가 비슷한 경우에만 병합 (패딩 구조 보존)
 * - 크기가 다른 중간 래퍼는 유지됨
 *
 * @param node 시작 노드
 * @param requireSameName true면 동일 이름만 (기존 동작), false면 이름 무관
 */
function findSingleChildChain(node: FrameNode, requireSameName: boolean = false): NestedChain | null {
  // 자식이 1개가 아니면 체인 아님
  if (node.children.length !== 1) return null;

  const child = node.children[0];
  // 자식이 프레임이 아니면 체인 아님
  if (child.type !== 'FRAME') return null;

  // 동일 이름 모드일 때만 이름 체크
  if (requireSameName && child.name !== node.name) return null;

  // 크기 체크 (동일 이름이어도 크기가 너무 다르면 병합 안 함)
  // 2026-01-16 수정: 같은 이름이어도 크기 차이가 크면 스킵
  const isSameNameChain = child.name === node.name;
  const sizeOk = isSimilarSize(node, child as FrameNode, isSameNameChain ? 20 : 5);
  if (!sizeOk) return null;

  // 체인 추적 시작
  const chain: FrameNode[] = [node];
  let current: FrameNode = child as FrameNode;
  let totalOffsetX = child.x;
  let totalOffsetY = child.y;

  // 단일 자식 프레임이 계속되는 동안 추적
  // 동일 이름 체인이면 크기 체크 스킵
  while (
    current.children.length === 1 &&
    current.children[0].type === 'FRAME' &&
    (!requireSameName || current.children[0].name === current.name) &&
    (current.children[0].name === current.name || isSimilarSize(current, current.children[0] as FrameNode))
  ) {
    chain.push(current);
    const nextChild = current.children[0] as FrameNode;
    totalOffsetX += nextChild.x;
    totalOffsetY += nextChild.y;
    current = nextChild;
  }

  // 마지막 노드 추가 (실제 컨텐츠를 가진 노드)
  chain.push(current);

  // 체인이 2개 이상이어야 병합 (top + bottom, 또는 top + middles + bottom)
  if (chain.length < 2) return null;

  return {
    topNode: chain[0],
    middleNodes: chain.slice(1, -1),  // 2개인 경우 빈 배열
    bottomNode: chain[chain.length - 1],
    offsetX: totalOffsetX,
    offsetY: totalOffsetY,
  };
}

/**
 * 체인 내 모든 노드의 스타일을 topNode에 병합
 * - fills: 하위 노드의 fill을 상위에 레이어처럼 추가 (시각적 순서 유지)
 * - strokes: 병합
 * - effects: 병합
 * - cornerRadius: 가장 큰 값 사용
 * - clipsContent: 하나라도 true면 true
 */
function mergeChainStyles(chain: NestedChain): void {
  const { topNode, middleNodes, bottomNode } = chain;
  const allNodes = [topNode, ...middleNodes, bottomNode];

  // 1. Fills 병합 (하위 → 상위 순서로 레이어링, 시각적으로 위에서 아래로)
  const mergedFills: Paint[] = [];
  // reverse 복사본으로 원본 배열 보존
  const nodesBottomToTop = [...allNodes].reverse();
  for (const node of nodesBottomToTop) {
    const fills = node.fills;
    if (Array.isArray(fills)) {
      for (const fill of fills) {
        if (fill.visible !== false) {
          mergedFills.push(JSON.parse(JSON.stringify(fill)));
        }
      }
    }
  }
  if (mergedFills.length > 0) {
    topNode.fills = mergedFills;
  }

  // 2. Strokes 병합
  const mergedStrokes: Paint[] = [];
  for (const node of allNodes) {
    for (const stroke of node.strokes) {
      if (stroke.visible !== false) {
        mergedStrokes.push(JSON.parse(JSON.stringify(stroke)));
      }
    }
  }
  if (mergedStrokes.length > 0) {
    topNode.strokes = mergedStrokes;
  }

  // 3. Effects 병합 (shadow, blur 등)
  const mergedEffects: Effect[] = [];
  for (const node of allNodes) {
    for (const effect of node.effects) {
      if (effect.visible !== false) {
        mergedEffects.push(JSON.parse(JSON.stringify(effect)));
      }
    }
  }
  if (mergedEffects.length > 0) {
    topNode.effects = mergedEffects;
  }

  // 4. clipsContent: 하나라도 true면 true
  topNode.clipsContent = allNodes.some(n => n.clipsContent);

  // 5. cornerRadius: 가장 큰 값 사용
  const radii = allNodes.map(n => {
    if (typeof n.cornerRadius === 'number') return n.cornerRadius;
    return 0;
  });
  const maxRadius = Math.max(...radii);
  if (maxRadius > 0 && typeof topNode.cornerRadius === 'number') {
    topNode.cornerRadius = maxRadius;
  }
}

/**
 * 자식들의 배치로 방향 추론
 */
function inferDirectionFromChildren(children: readonly SceneNode[]): 'HORIZONTAL' | 'VERTICAL' {
  if (children.length < 2) return 'HORIZONTAL';

  const first = children[0];
  const second = children[1];

  const horizontalDiff = Math.abs(first.x - second.x);
  const verticalDiff = Math.abs(first.y - second.y);

  return horizontalDiff > verticalDiff ? 'HORIZONTAL' : 'VERTICAL';
}

/**
 * 동일 이름 중첩 체인 병합 (AI 검증 포함)
 * - 중간 노드 제거
 * - 최하위의 자식들을 최상위로 이동
 * - AI가 병합 전후 스크린샷 비교 후 차이 발견 시 복원
 */
async function flattenSameNameChain(
  chain: NestedChain,
  useAIValidation: boolean = true
): Promise<{ success: boolean; layoutIssues?: string[]; aiValidated?: boolean }> {
  const { topNode, middleNodes, bottomNode, offsetX, offsetY } = chain;

  try {
    // 노드 유효성 검사 (이전 병합으로 삭제되었을 수 있음)
    const topNodeCheck = await figma.getNodeByIdAsync(topNode.id);
    const bottomNodeCheck = await figma.getNodeByIdAsync(bottomNode.id);
    if (!topNodeCheck || !bottomNodeCheck) {
      console.log(`[Flatten] 노드가 이미 삭제됨, 스킵`);
      return { success: false };
    }

    // ===== 새 방식: Auto Layout 부모가 무의미한 래퍼인 경우 =====
    // topNode의 부모가 AL이고, topNode가 무의미한 래퍼이면
    // bottomNode를 topNode 위치로 옮기고 topNode 제거
    const parentNode = topNode.parent;
    if (parentNode && 'layoutMode' in parentNode && parentNode.layoutMode !== 'NONE') {
      // 부모가 Auto Layout인 경우

      // topNode가 무의미한 래퍼인지 확인
      const isTopNodeMeaningless = isEmptyAutoLayoutWrapper(topNode);

      if (isTopNodeMeaningless) {
        console.log(`[Flatten] AL 부모 감지: "${topNode.name}" → bottomNode "${bottomNode.name}"를 상위로 이동`);

        // topNode의 fills를 bottomNode에 이전 (있다면)
        if (topNode.fills && Array.isArray(topNode.fills) && topNode.fills.length > 0) {
          const visibleFills = (topNode.fills as readonly Paint[]).filter(f => f.visible !== false);
          if (visibleFills.length > 0 && 'fills' in bottomNode) {
            const existingFills = (bottomNode.fills as readonly Paint[]) || [];
            (bottomNode as FrameNode).fills = [...visibleFills, ...existingFills];
            console.log(`[Flatten] topNode fills를 bottomNode에 이전`);
          }
        }

        // bottomNode를 topNode의 부모로 이동 (topNode 위치에)
        const topIndex = (parentNode as FrameNode).children.indexOf(topNode);
        (parentNode as FrameNode).insertChild(topIndex, bottomNode);

        // 중간 노드들 + topNode 제거
        for (const mid of middleNodes) {
          try { mid.remove(); } catch (e) { /* 이미 제거됨 */ }
        }
        try { topNode.remove(); } catch (e) { /* 이미 제거됨 */ }

        console.log(`[Flatten] AL 부모 병합 완료`);
        return { success: true, aiValidated: false };
      }
    }

    // ===== 기존 방식: 일반 병합 =====
    // 0. 병합 전 스크린샷 캡처 (AI 검증용) - 2단계 상위 부모까지 캡처하여 레이아웃 영향 감지
    let beforeScreenshot: string | null = null;
    let screenshotTarget: SceneNode = topNode;

    // 2단계 상위 부모까지 올라가서 캡처 (더 넓은 범위의 레이아웃 변화 감지)
    let parent1 = topNode.parent;
    if (parent1 && 'type' in parent1 && parent1.type === 'FRAME') {
      screenshotTarget = parent1 as SceneNode;

      // 2단계 상위가 있으면 더 올라감
      let parent2 = parent1.parent;
      if (parent2 && 'type' in parent2 && parent2.type === 'FRAME') {
        screenshotTarget = parent2 as SceneNode;
        console.log(`[Flatten] 스크린샷 대상: 2단계 상위 "${screenshotTarget.name}"`);
      } else {
        console.log(`[Flatten] 스크린샷 대상: 1단계 상위 "${screenshotTarget.name}"`);
      }
    }

    if (useAIValidation) {
      try {
        beforeScreenshot = await captureNodeScreenshot(screenshotTarget);
        console.log(`[Flatten] 병합 전 스크린샷 캡처 완료`);
      } catch (e) {
        console.log(`[Flatten] 스크린샷 캡처 실패, AI 검증 스킵:`, e);
      }
    }

    // 0.5. 병합 전 모든 자손의 절대 위치 저장 (보정용)
    interface AbsolutePositionInfo {
      id: string;
      name: string;
      absoluteX: number;
      absoluteY: number;
    }
    const beforePositions: AbsolutePositionInfo[] = [];

    function collectAbsolutePositions(node: SceneNode) {
      if (node.absoluteBoundingBox) {
        beforePositions.push({
          id: node.id,
          name: node.name,
          absoluteX: node.absoluteBoundingBox.x,
          absoluteY: node.absoluteBoundingBox.y,
        });
      }
      if ('children' in node) {
        for (const child of node.children) {
          collectAbsolutePositions(child);
        }
      }
    }
    collectAbsolutePositions(bottomNode);
    console.log(`[Flatten] 병합 전 ${beforePositions.length}개 노드 위치 저장`);

    // 0.6. 스타일 병합 (fills, strokes, effects 등을 topNode에 병합)
    mergeChainStyles(chain);

    // 1. 최하위 노드의 자식들과 위치 정보 저장
    const bottomChildren = [...bottomNode.children];

    if (bottomChildren.length === 0) {
      return { success: false };
    }

    // 자식들의 원래 위치 정보 저장 (bottomNode 기준 상대 좌표)
    const childInfos = bottomChildren.map(child => ({
      node: child,
      relativeX: child.x,
      relativeY: child.y,
    }));

    // 2. 원래 크기 저장
    const originalWidth = topNode.width;
    const originalHeight = topNode.height;

    // 3. Auto Layout 설정 저장 (복원용)
    const savedAutoLayout = {
      mode: topNode.layoutMode,
      itemSpacing: topNode.itemSpacing,
      paddingTop: topNode.paddingTop,
      paddingRight: topNode.paddingRight,
      paddingBottom: topNode.paddingBottom,
      paddingLeft: topNode.paddingLeft,
      primaryAxisSizingMode: topNode.primaryAxisSizingMode,
      counterAxisSizingMode: topNode.counterAxisSizingMode,
      primaryAxisAlignItems: topNode.primaryAxisAlignItems,
      counterAxisAlignItems: topNode.counterAxisAlignItems,
    };

    // 4. topNode의 Auto Layout이 있으면 해제
    const wasAutoLayout = topNode.layoutMode !== 'NONE';
    if (wasAutoLayout) {
      topNode.layoutMode = 'NONE';
    }

    // 5. 자식들을 topNode로 이동
    for (const childInfo of childInfos) {
      const newX = offsetX + childInfo.relativeX;
      const newY = offsetY + childInfo.relativeY;
      topNode.appendChild(childInfo.node);
      resetLayoutPositioning(childInfo.node); // Ignore auto-layout 방지
      childInfo.node.x = newX;
      childInfo.node.y = newY;
    }

    // 6. topNode 크기 유지
    topNode.resize(originalWidth, originalHeight);

    // 7. 중간 노드들 + bottomNode 제거
    for (let i = middleNodes.length - 1; i >= 0; i--) {
      try { middleNodes[i].remove(); } catch (e) { /* 이미 제거됨 */ }
    }
    try { bottomNode.remove(); } catch (e) { /* 이미 제거됨 */ }

    console.log(`[Flatten] 병합 완료: size=${originalWidth}x${originalHeight}, offset=(${offsetX}, ${offsetY})`);

    // 8. Auto Layout 복원 (있었다면)
    if (wasAutoLayout && savedAutoLayout.mode !== 'NONE') {
      try {
        const additionalPaddingLeft = offsetX > 0 ? offsetX : 0;
        const additionalPaddingTop = offsetY > 0 ? offsetY : 0;

        topNode.layoutMode = savedAutoLayout.mode;
        topNode.itemSpacing = savedAutoLayout.itemSpacing;
        topNode.paddingTop = savedAutoLayout.paddingTop + additionalPaddingTop;
        topNode.paddingRight = savedAutoLayout.paddingRight;
        topNode.paddingBottom = savedAutoLayout.paddingBottom;
        topNode.paddingLeft = savedAutoLayout.paddingLeft + additionalPaddingLeft;
        topNode.primaryAxisSizingMode = savedAutoLayout.primaryAxisSizingMode;
        topNode.counterAxisSizingMode = savedAutoLayout.counterAxisSizingMode;
        topNode.primaryAxisAlignItems = savedAutoLayout.primaryAxisAlignItems;
        topNode.counterAxisAlignItems = savedAutoLayout.counterAxisAlignItems;

        console.log(`[Flatten] Auto Layout 복원: ${savedAutoLayout.mode}`);
      } catch (e) {
        console.log(`[Flatten] Auto Layout 복원 실패:`, e);
      }
    }

    // 9. 항상 절대 위치 기반 자동 보정 수행 (AI 검증과 무관)
    let corrected = 0;
    const layoutIssues: string[] = [];

    for (const beforePos of beforePositions) {
      try {
        const node = figma.getNodeById(beforePos.id) as SceneNode | null;
        if (node && node.absoluteBoundingBox) {
          const afterX = node.absoluteBoundingBox.x;
          const afterY = node.absoluteBoundingBox.y;
          const deltaX = beforePos.absoluteX - afterX;
          const deltaY = beforePos.absoluteY - afterY;

          // 위치가 2px 이상 틀어졌으면 보정
          if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
            if ('x' in node) {
              node.x += deltaX;
              node.y += deltaY;
              console.log(`[Flatten] 보정: "${beforePos.name}" 이동 (${deltaX.toFixed(1)}, ${deltaY.toFixed(1)})`);
              layoutIssues.push(`${beforePos.name}: (${deltaX.toFixed(1)}, ${deltaY.toFixed(1)}) 보정`);
              corrected++;
            }
          }
        }
      } catch (e) {
        // 노드가 제거되었을 수 있음 - 무시
      }
    }

    if (corrected > 0) {
      console.log(`[Flatten] ${corrected}개 노드 위치 보정 완료`);
    }

    // 10. AI 기반 시각적 검증 (참고용, 보정은 이미 완료)
    if (useAIValidation && beforeScreenshot) {
      try {
        const afterScreenshot = await captureNodeScreenshot(screenshotTarget);
        console.log(`[Flatten] 병합 후 스크린샷 캡처 완료 (대상: ${screenshotTarget.name}), AI 검증 요청...`);

        const validationResult = await callCleanupValidator(
          beforeScreenshot,
          afterScreenshot,
          topNode.id,
          topNode.name,
          'flatten'
        );

        if (validationResult) {
          if (validationResult.isIdentical) {
            console.log(`[Flatten] AI 검증: 시각적 차이 없음 ✓`);
          } else if (validationResult.differences && validationResult.differences.length > 0) {
            console.log(`[Flatten] AI 검증: ${validationResult.differences.length}개 차이 발견`);
            console.log(`[Flatten] AI 요약: ${validationResult.summary}`);
          }
        }

        return { success: true, layoutIssues: layoutIssues.length > 0 ? layoutIssues : undefined, aiValidated: true };
      } catch (e) {
        console.log(`[Flatten] AI 검증 에러:`, e);
      }
    }

    // 10. AI 검증 실패 시 기존 규칙 기반 검증 (폴백)
    const beforeSnapshot = captureLayoutSnapshot(topNode);
    const afterSnapshot = captureLayoutSnapshot(topNode);
    const layoutChanges = validateLayoutChange(beforeSnapshot, afterSnapshot, 5);

    if (layoutChanges.length > 0) {
      const issues = layoutChanges.map(c => `${c.name}: (${c.deltaX}, ${c.deltaY}) 이동`);
      return { success: true, layoutIssues: issues, aiValidated: false };
    }

    return { success: true, aiValidated: false };
  } catch (e) {
    console.log('[Flatten] flattenSameNameChain error:', e);
    return { success: false };
  }
}

/**
 * 재귀적으로 동일 이름 중첩 체인 병합 (AI 검증 포함)
 */
export async function flattenSameNameWrappersRecursive(
  node: SceneNode,
  useAIValidation: boolean = true
): Promise<{
  flattenedCount: number;
  flattenedNames: string[];
  layoutIssues: string[];
  aiValidatedCount: number;
}> {
  let flattenedCount = 0;
  const flattenedNames: string[] = [];
  const layoutIssues: string[] = [];
  let visitedCount = 0;
  let aiValidatedCount = 0;

  // 병합 대상 체인들을 먼저 수집
  const chainsToFlatten: { chain: NestedChain; name: string; depth: number }[] = [];

  function collectChains(n: SceneNode) {
    try {
      if (!n.parent) return;
      visitedCount++;

      // 자식 먼저 탐색 (깊이 우선)
      if ('children' in n) {
        const children = [...(n as ChildrenMixin).children];
        for (const child of children) {
          collectChains(child);
        }
      }

      if (n.type !== 'FRAME') return;
      if (!n.parent) return;

      const chain = findSingleChildChain(n as FrameNode, false);
      if (chain) {
        const depth = chain.middleNodes.length + 2;
        chainsToFlatten.push({ chain, name: n.name, depth });
      }
    } catch (e) {
      console.log('[Flatten] collectChains error:', e);
    }
  }

  console.log(`[Flatten] 탐색 시작: ${node.name}`);
  collectChains(node);
  console.log(`[Flatten] ${chainsToFlatten.length}개 체인 발견`);

  // 수집된 체인들을 순차적으로 병합 (AI 검증은 비동기)
  for (const { chain, name, depth } of chainsToFlatten) {
    try {
      // 노드가 아직 유효한지 확인
      if (!chain.topNode.parent) {
        console.log(`[Flatten] ${name}: 이미 처리됨, 스킵`);
        continue;
      }

      console.log(`[Flatten] 체인 병합: ${name} (${depth}중)`);
      const result = await flattenSameNameChain(chain, useAIValidation);

      if (result.success) {
        flattenedCount++;
        flattenedNames.push(`${name} (${depth}중 → 1)`);
        console.log(`[Flatten] ${name}: 병합 완료`);

        if (result.aiValidated) {
          aiValidatedCount++;
        }

        if (result.layoutIssues && result.layoutIssues.length > 0) {
          layoutIssues.push(`${name}: ${result.layoutIssues.join(', ')}`);
        }
      }
    } catch (e) {
      console.log(`[Flatten] ${name} 병합 에러:`, e);
    }
  }

  console.log(`[Flatten] 완료: ${visitedCount}개 노드 방문, ${flattenedCount}개 병합, ${aiValidatedCount}개 AI 검증`);

  if (layoutIssues.length > 0) {
    console.log(`[Flatten] 레이아웃 이슈 ${layoutIssues.length}건:`, layoutIssues);
  }

  return { flattenedCount, flattenedNames, layoutIssues, aiValidatedCount };
}

// 체인 정보를 임시 저장 (ID로 조회용)
// ⚠️ clear()는 collectSelectionMergeCandidates()에서만! (반복 함수 내부 금지)
const chainCache = new Map<string, NestedChain>();

/**
 * 병합 후보 수집 (Human in the Loop용)
 * - 실제 병합 없이 후보 목록만 반환
 */
export function collectMergeCandidates(node: SceneNode): MergeCandidate[] {
  const candidates: MergeCandidate[] = [];
  // chainCache.clear()는 collectSelectionMergeCandidates에서 한 번만 호출

  function collectChains(n: SceneNode) {
    try {
      if (!n.parent) return;

      // 자식 먼저 탐색 (깊이 우선)
      if ('children' in n) {
        const children = [...(n as ChildrenMixin).children];
        for (const child of children) {
          collectChains(child);
        }
      }

      if (n.type !== 'FRAME') return;
      if (!n.parent) return;

      const chain = findSingleChildChain(n as FrameNode, false);
      if (chain) {
        const depth = chain.middleNodes.length + 2;

        // 계층 구조 수집 (최하위 자식까지 포함)
        const hierarchy: string[] = [chain.topNode.name];
        for (const middle of chain.middleNodes) {
          hierarchy.push(middle.name);
        }
        hierarchy.push(chain.bottomNode.name);

        // bottomNode의 자식들도 계층에 추가
        for (const child of chain.bottomNode.children.slice(0, 5)) {
          const childLabel = child.type === 'TEXT'
            ? `text "${(child as TextNode).characters.substring(0, 15)}${(child as TextNode).characters.length > 15 ? '...' : ''}"`
            : `${child.name}`;
          hierarchy.push(childLabel);
        }
        if (chain.bottomNode.children.length > 5) {
          hierarchy.push(`... 외 ${chain.bottomNode.children.length - 5}개`);
        }

        // 최종 자식 미리보기 (별도로도 유지)
        const childrenPreview: string[] = [];
        for (const child of chain.bottomNode.children.slice(0, 5)) {
          const preview = child.type === 'TEXT'
            ? `text "${(child as TextNode).characters.substring(0, 20)}${(child as TextNode).characters.length > 20 ? '...' : ''}"`
            : `${child.type} "${child.name}"`;
          childrenPreview.push(preview);
        }
        if (chain.bottomNode.children.length > 5) {
          childrenPreview.push(`... 외 ${chain.bottomNode.children.length - 5}개`);
        }

        const candidate: MergeCandidate = {
          id: chain.topNode.id,
          name: n.name,
          depth,
          hierarchy,
          childrenPreview,
          size: {
            width: Math.round(chain.topNode.width),
            height: Math.round(chain.topNode.height),
          },
        };

        candidates.push(candidate);
        chainCache.set(chain.topNode.id, chain);
      }
    } catch (e) {
      console.log('[Flatten] collectChains error:', e);
    }
  }

  console.log(`[Flatten] 후보 수집 시작: ${node.name}`);
  collectChains(node);
  console.log(`[Flatten] ${candidates.length}개 후보 발견`);

  return candidates;
}

/**
 * 선택된 노드에서 병합 후보 수집
 */
export function collectSelectionMergeCandidates(): {
  success: boolean;
  candidates: MergeCandidate[];
  message?: string;
} {
  // ⚠️ 캐시 초기화는 여기서만! (collectMergeCandidates 내부에서 하면 다중 선택 시 손실)
  chainCache.clear();

  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    return {
      success: false,
      candidates: [],
      message: '선택된 요소가 없습니다.',
    };
  }

  const allCandidates: MergeCandidate[] = [];

  for (const node of selection) {
    const candidates = collectMergeCandidates(node);
    allCandidates.push(...candidates);
  }

  return {
    success: true,
    candidates: allCandidates,
    message: `${allCandidates.length}개 병합 후보 발견`,
  };
}

/**
 * 선택된 후보들만 병합 (Human in the Loop)
 */
export async function flattenSelectedCandidates(
  selectedIds: string[],
  useAIValidation: boolean = true
): Promise<{
  success: boolean;
  message: string;
  details?: {
    flattenedCount: number;
    flattenedNames: string[];
    layoutIssues: string[];
    aiValidatedCount: number;
  };
}> {
  try {
    let flattenedCount = 0;
    let aiValidatedCount = 0;
    const flattenedNames: string[] = [];
    const layoutIssues: string[] = [];

    console.log(`[Flatten] 캐시 크기: ${chainCache.size}, 캐시 키: ${Array.from(chainCache.keys()).join(', ')}`);

    const total = selectedIds.length;
    for (let i = 0; i < selectedIds.length; i++) {
      const id = selectedIds[i];
      const chain = chainCache.get(id);
      if (!chain) {
        console.log(`[Flatten] 캐시에서 체인 못 찾음: ${id}`);
        continue;
      }

      console.log(`[Flatten] 캐시 히트: ${id}`);

      // 캐시된 노드 참조가 유효한지 먼저 확인
      let topNodeId: string;
      try {
        topNodeId = chain.topNode.id;
        console.log(`[Flatten] topNode.id 접근 성공: ${topNodeId}`);
      } catch (e) {
        console.log(`[Flatten] ${id}: 캐시된 노드 참조 무효 (topNode.id 접근 실패)`);
        continue;
      }

      // 노드가 아직 존재하는지 확인 (async 사용)
      try {
        const nodeCheck = await figma.getNodeByIdAsync(topNodeId);
        if (!nodeCheck) {
          console.log(`[Flatten] ${id}: 노드가 더 이상 존재하지 않음`);
          continue;
        }
        if (!chain.topNode.parent) {
          console.log(`[Flatten] ${id}: 이미 처리됨 (parent 없음)`);
          continue;
        }
      } catch (e) {
        console.log(`[Flatten] ${id}: getNodeByIdAsync 에러:`, e);
        continue;
      }

      const depth = chain.middleNodes.length + 2;
      // 병합 전에 이름 저장 (병합 후 노드가 삭제되므로)
      const chainName = chain.topNode.name;
      console.log(`[Flatten] 체인 병합: ${chainName} (${depth}중)`);

      // 프로그레스 업데이트
      figma.ui.postMessage({
        type: 'merge-progress',
        current: i + 1,
        total: total,
        name: chainName,
      });

      const result = await flattenSameNameChain(chain, useAIValidation);

      if (result.success) {
        flattenedCount++;
        flattenedNames.push(`${chainName} (${depth}중 → 1)`);

        if (result.aiValidated) {
          aiValidatedCount++;
        }

        if (result.layoutIssues && result.layoutIssues.length > 0) {
          layoutIssues.push(`${chainName}: ${result.layoutIssues.join(', ')}`);
        }
      }
    }

    // 캐시 정리
    chainCache.clear();

    let message = `${flattenedCount}개의 중첩 체인이 병합되었습니다.`;
    if (aiValidatedCount > 0) {
      message += ` (${aiValidatedCount}개 AI 검증)`;
    }

    return {
      success: true,
      message,
      details: {
        flattenedCount,
        flattenedNames,
        layoutIssues,
        aiValidatedCount,
      },
    };
  } catch (e) {
    console.log('[Flatten] flattenSelectedCandidates error:', e);
    return {
      success: false,
      message: '병합 중 오류가 발생했습니다: ' + String(e),
    };
  }
}

/**
 * 선택된 노드들의 동일 이름 중첩 체인 병합 (AI 검증 포함)
 */
export async function flattenSelectionSameNameWrappers(
  useAIValidation: boolean = true
): Promise<{
  success: boolean;
  message: string;
  details?: {
    flattenedCount: number;
    flattenedNames: string[];
    layoutIssues: string[];
    aiValidatedCount: number;
  };
}> {
  try {
    const selection = figma.currentPage.selection;

    if (selection.length === 0) {
      return {
        success: false,
        message: '선택된 요소가 없습니다.',
      };
    }

    let totalFlattened = 0;
    let totalAIValidated = 0;
    const allFlattenedNames: string[] = [];
    const allLayoutIssues: string[] = [];

    for (const node of selection) {
      const result = await flattenSameNameWrappersRecursive(node, useAIValidation);
      totalFlattened += result.flattenedCount;
      totalAIValidated += result.aiValidatedCount;
      allFlattenedNames.push(...result.flattenedNames);
      allLayoutIssues.push(...result.layoutIssues);
    }

    if (totalFlattened === 0) {
      return {
        success: true,
        message: '병합할 중첩 체인이 없습니다.',
        details: { flattenedCount: 0, flattenedNames: [], layoutIssues: [], aiValidatedCount: 0 },
      };
    }

    let message = `${totalFlattened}개의 중첩 체인이 병합되었습니다.`;
    if (totalAIValidated > 0) {
      message += ` (${totalAIValidated}개 AI 검증)`;
    }
    if (allLayoutIssues.length > 0) {
      message += ` (이슈 ${allLayoutIssues.length}건)`;
    }

    return {
      success: true,
      message,
      details: {
        flattenedCount: totalFlattened,
        flattenedNames: allFlattenedNames,
        layoutIssues: allLayoutIssues,
        aiValidatedCount: totalAIValidated,
      },
    };
  } catch (e) {
    console.log('[Flatten] flattenSelectionSameNameWrappers error:', e);
    return {
      success: false,
      message: '병합 중 오류가 발생했습니다: ' + String(e),
    };
  }
}

// ============================================
// AI 검증 기반 공격적 래퍼 제거
// ============================================

/**
 * 공격적 래퍼 판단
 * - 최소 조건만 체크: 자식 1개 + Auto Layout 없음
 * - 스타일, 마스킹 등 무시
 */
/**
 * 공격적 래퍼 판단
 * - isMeaninglessWrapper 기반이지만 이름 보호를 마스킹 역할일 때만 적용
 */
export function isAggressiveWrapper(node: SceneNode): boolean {
  // 프레임이나 그룹만 대상
  if (node.type !== 'FRAME' && node.type !== 'GROUP') return false;
  if (!('children' in node) || node.children.length !== 1) return false;

  // ★ 부모가 GROUP인 경우 보존 (GROUP bounding box 재계산으로 좌표 틀어짐 방지)
  var parent = node.parent;
  if (parent && parent.type === 'GROUP') {
    return false;
  }

  // ★ 자동 생성 이름이 아니면 보존 (의도적으로 만든 프레임 - Hidden, Mask 등)
  if (!isAutoGeneratedName(node.name)) {
    return false;
  }

  var child = node.children[0];

  // 1. 같은 크기 체크 (핵심!)
  var sameSize =
    Math.abs(child.width - node.width) <= 5 &&
    Math.abs(child.height - node.height) <= 5;

  // 2. 마스킹 역할 체크 (프레임만)
  if (node.type === 'FRAME') {
    var isMasking =
      node.clipsContent ||  // 클리핑
      child.width > node.width + 2 ||  // 자식이 더 큼
      child.height > node.height + 2 ||
      child.x < -2 ||  // 음수 좌표
      child.y < -2;

    // 마스킹 역할이면 무조건 보존
    if (isMasking) return false;
  }

  // 2.5. Protected name이면 보존 (user, avatar, pic 등 이미지 관련)
  var PROTECTED_KEYWORDS = ['user', 'avatar', 'pic', 'photo', 'image', 'profile', 'thumbnail'];
  var lowerName = node.name.toLowerCase();
  for (var i = 0; i < PROTECTED_KEYWORDS.length; i++) {
    if (lowerName.indexOf(PROTECTED_KEYWORDS[i]) !== -1) {
      return false;  // 이미지 관련 이름 → 보존
    }
  }

  // 3. 같은 크기면 래퍼 (좌표 상관없이!)
  if (sameSize) {
    // 프레임인 경우 시각적 스타일/Auto Layout 체크
    if (node.type === 'FRAME') {
      // Auto Layout이 있으면 보존
      if (node.layoutMode !== 'NONE') return false;

      // 시각적 스타일 검사
      var fills = node.fills;
      var hasMeaningfulFills = Array.isArray(fills) && fills.length > 0 &&
        fills.some(function(f) {
          if (f.visible === false) return false;
          if (f.type !== 'SOLID') return true;
          var c = f.color;
          var isWhite = c.r > 0.95 && c.g > 0.95 && c.b > 0.95;
          return !isWhite;
        });
      var hasStrokes = node.strokes.length > 0 &&
        node.strokes.some(function(s) { return s.visible !== false; });
      var hasEffects = node.effects.length > 0 &&
        node.effects.some(function(e) { return e.visible !== false; });

      if (hasMeaningfulFills || hasStrokes || hasEffects) return false;
    }

    // 같은 크기 + 스타일 없음 = 래퍼
    return true;
  }

  // 4. 다른 크기면 기존 로직
  // 자식 좌표가 비정상이면 스킵
  if (child.x < -10 || child.y < -10 ||
      child.x > node.width + 10 || child.y > node.height + 10) {
    return false;
  }

  // 자식이 원점에서 떨어져 있으면 스킵 (오프셋 역할)
  if (child.x > 5 || child.y > 5) {
    return false;
  }

  // shape 타입 자식은 보존
  if (isShapeType(child.type)) {
    return false;
  }

  // 프레임인 경우 추가 체크
  if (node.type === 'FRAME') {
    if (node.layoutMode !== 'NONE') return false;

    var fills2 = node.fills;
    var hasFills = Array.isArray(fills2) && fills2.length > 0 &&
      fills2.some(function(f) {
        if (f.visible === false) return false;
        if (f.type !== 'SOLID') return true;
        var c = f.color;
        return !(c.r > 0.95 && c.g > 0.95 && c.b > 0.95);
      });
    var hasStrokes2 = node.strokes.length > 0 &&
      node.strokes.some(function(s) { return s.visible !== false; });
    var hasEffects2 = node.effects.length > 0 &&
      node.effects.some(function(e) { return e.visible !== false; });

    if (hasFills || hasStrokes2 || hasEffects2) return false;
  }

  return true;
}

/**
 * 래퍼 후보 수집 (재귀적)
 */
function collectWrapperCandidates(
  node: SceneNode,
  aggressive: boolean = false
): Array<FrameNode | GroupNode> {
  const candidates: Array<FrameNode | GroupNode> = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      // 자식 먼저 탐색 (깊이 우선)
      if ('children' in n) {
        const children = [...(n as ChildrenMixin).children];
        for (const child of children) {
          traverse(child);
        }
      }

      // 래퍼 판단
      if (n.type === 'FRAME' || n.type === 'GROUP') {
        const isWrapper = aggressive ? isAggressiveWrapper(n) : isMeaninglessWrapper(n);
        if (isWrapper) {
          candidates.push(n as FrameNode | GroupNode);
        }
      }
    } catch (e) {
      console.log('[collectWrapperCandidates] error:', e);
    }
  }

  traverse(node);
  return candidates;
}

interface AggressiveCleanupResult {
  success: boolean;
  removed: number;           // 래퍼 제거 수
  removedNames: string[];    // 래퍼 제거된 이름들
  outOfBoundsRemoved: number; // 범위 밖 요소 제거 수
  emptyFramesRemoved: number; // 빈 프레임 제거 수
  zeroSizeRemoved: number;   // 크기 0 요소 제거 수
  sameNameRemoved: number;   // 동일 이름 중첩 제거 수
  emptyDuplicatesRemoved: number; // 빈 중복 형제 제거 수
  deepFlattenMerged: number; // Deep Flatten AL 병합 수
  deepFlattenEmptyRemoved: number; // Deep Flatten 빈 요소 제거 수
  alUnwrapped: number;       // AL 내부 무의미 프레임 언래핑 수
  // 하위 호환성
  emptyImageRemoved: number;
}

/**
 * 부모 범위 밖에 있는 요소인지 확인
 * (clipsContent=true인 부모에서 잘려나가는 요소)
 */
function isOutOfBounds(node: SceneNode): boolean {
  var parent = node.parent;
  if (!parent || !('width' in parent)) return false;

  // 부모가 clipsContent=true인 프레임인 경우만 체크
  if (parent.type !== 'FRAME' || !parent.clipsContent) return false;

  // 노드가 부모 범위 완전히 밖에 있는지 확인
  var nodeRight = node.x + node.width;
  var nodeBottom = node.y + node.height;
  var parentRight = parent.width;
  var parentBottom = parent.height;

  // 완전히 밖에 있으면 true
  if (nodeRight <= 0 || node.x >= parentRight ||
      nodeBottom <= 0 || node.y >= parentBottom) {
    return true;
  }

  return false;
}

/**
 * 부모 범위 밖 요소 수집 (재귀적)
 */
function collectOutOfBoundsElements(node: SceneNode): SceneNode[] {
  const elements: SceneNode[] = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      if ('children' in n) {
        var children = [...(n as ChildrenMixin).children];
        for (var i = 0; i < children.length; i++) {
          traverse(children[i]);
        }
      }

      if (isOutOfBounds(n)) {
        elements.push(n);
      }
    } catch (e) {
      console.log('[collectOutOfBounds] error:', e);
    }
  }

  traverse(node);
  return elements;
}

/**
 * 완전히 빈 프레임/그룹인지 확인 (자식 없음 + 스타일 없음)
 */
function isEmptyFrame(node: SceneNode): boolean {
  // 프레임이나 그룹만 대상
  if (node.type !== 'FRAME' && node.type !== 'GROUP') return false;

  // ★ 부모가 Auto Layout이면 보존 (삭제 시 형제 요소 재배치됨)
  var parent = node.parent;
  if (parent && parent.type === 'FRAME' && (parent as FrameNode).layoutMode !== 'NONE') {
    return false;
  }

  // protected name이면 제거하지 않음
  var PROTECTED_KEYWORDS = ['user', 'avatar', 'pic', 'photo', 'image', 'profile', 'thumbnail'];
  var lowerName = node.name.toLowerCase();
  for (var i = 0; i < PROTECTED_KEYWORDS.length; i++) {
    if (lowerName.indexOf(PROTECTED_KEYWORDS[i]) !== -1) {
      return false;  // 보호
    }
  }

  // 자식이 있으면 빈 프레임 아님
  if ('children' in node && node.children.length > 0) return false;

  // 프레임인 경우 스타일 체크
  if (node.type === 'FRAME') {
    // fills, strokes, effects가 있으면 보존
    if ('fills' in node && Array.isArray(node.fills) && node.fills.length > 0) {
      var hasVisibleFill = false;
      for (var j = 0; j < node.fills.length; j++) {
        if ((node.fills[j] as Paint).visible !== false) {
          hasVisibleFill = true;
          break;
        }
      }
      if (hasVisibleFill) return false;
    }
    if ('strokes' in node && Array.isArray(node.strokes) && node.strokes.length > 0) {
      return false;
    }
    if ('effects' in node && Array.isArray(node.effects) && node.effects.length > 0) {
      return false;
    }
  }

  return true;
}

/**
 * 크기가 0인 요소인지 확인
 */
function isZeroSize(node: SceneNode): boolean {
  // width나 height가 0이면 보이지 않음
  if ('width' in node && 'height' in node) {
    if (node.width <= 0 || node.height <= 0) {
      return true;
    }
  }
  return false;
}

/**
 * 동일 이름 중첩인지 확인 (부모와 자식 이름이 동일)
 */
function isSameNameNested(node: SceneNode): boolean {
  // 자식이 정확히 1개인 프레임/그룹만 대상
  if (node.type !== 'FRAME' && node.type !== 'GROUP') return false;
  if (!('children' in node) || node.children.length !== 1) return false;

  var child = node.children[0];

  // 마스킹 역할이면 보존 (이름과 상관없이)
  if (node.type === 'FRAME') {
    var isMasking =
      node.clipsContent ||
      child.width > node.width + 2 ||
      child.height > node.height + 2 ||
      child.x < -2 ||
      child.y < -2;

    if (isMasking) {
      return false;  // 마스킹 역할 → 보존
    }
  }

  // 부모와 자식 이름이 정확히 동일하면 제거
  if (node.name === child.name) {
    return true;
  }

  return false;
}

/**
 * 동일 이름 중첩의 내부 프레임인지 확인
 * avatar (27) > avatar (33) 구조에서 내부 avatar (33)를 제거 대상으로 판단
 */
function isInnerSameNameWrapper(node: SceneNode): boolean {
  // 프레임만 대상
  if (node.type !== 'FRAME') return false;

  // 부모가 같은 이름인지 체크
  var parent = node.parent;
  if (!parent || parent.type !== 'FRAME') {
    return false;
  }
  if (parent.name !== node.name) {
    return false;
  }

  console.log(`[InnerWrapper] 후보: ${node.name} (노드: ${node.width.toFixed(1)}x${node.height.toFixed(1)}, 부모: ${parent.width.toFixed(1)}x${parent.height.toFixed(1)})`);

  // 부모가 마스킹 역할인지 체크 (자식=현재노드가 부모보다 큼)
  var parentIsMasking =
    parent.clipsContent ||
    node.width > parent.width + 2 ||
    node.height > parent.height + 2;

  console.log(`[InnerWrapper] 마스킹체크: clipsContent=${parent.clipsContent}, 노드>부모+2? ${node.width}>${parent.width+2}=${node.width > parent.width + 2}`);

  if (!parentIsMasking) {
    console.log(`[InnerWrapper] 스킵: 부모가 마스킹 아님`);
    return false;
  }

  // 현재 노드가 마스킹이 아니면 제거 대상
  // 자식 중 하나라도 현재 노드보다 크면 마스킹
  if ('children' in node && node.children.length > 0) {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (child.width > node.width + 2 || child.height > node.height + 2) {
        console.log(`[InnerWrapper] 스킵: 현재 노드도 마스킹 (자식 ${child.name}: ${child.width}x${child.height})`);
        return false;
      }
    }
  }

  // 시각적 스타일(fills 제외한 strokes, effects)이 있으면 보존
  var hasStrokes = node.strokes.length > 0 &&
    node.strokes.some(function(s) { return s.visible !== false; });
  var hasEffects = node.effects.length > 0 &&
    node.effects.some(function(e) { return e.visible !== false; });

  console.log(`[InnerWrapper] 스타일: strokes=${node.strokes.length}, effects=${node.effects.length}`);

  if (hasStrokes || hasEffects) {
    console.log(`[InnerWrapper] 스킵: 스타일 있음`);
    return false;
  }

  console.log(`[InnerWrapper] ✓ 제거 대상: ${node.name} (${node.id})`);
  return true;
}

/**
 * 동일 이름 중첩의 내부 래퍼 수집
 */
function collectInnerSameNameWrappers(node: SceneNode): SceneNode[] {
  var wrappers: SceneNode[] = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      if ('children' in n) {
        var children = [...(n as ChildrenMixin).children];
        for (var i = 0; i < children.length; i++) {
          traverse(children[i]);
        }
      }

      if (isInnerSameNameWrapper(n)) {
        wrappers.push(n);
      }
    } catch (e) {
      // skip
    }
  }

  traverse(node);
  return wrappers;
}

/**
 * 자식이 여러 개인 래퍼 unwrap
 */
function unwrapNodeMultiple(wrapper: FrameNode | GroupNode): boolean {
  try {
    var parent = wrapper.parent;
    if (!parent || !('children' in parent)) return false;

    var children = [...wrapper.children];
    if (children.length === 0) return false;

    // 래퍼의 인덱스 찾기
    var wrapperIndex = -1;
    for (var i = 0; i < parent.children.length; i++) {
      if (parent.children[i].id === wrapper.id) {
        wrapperIndex = i;
        break;
      }
    }
    if (wrapperIndex === -1) return false;

    // 모든 자식을 부모로 이동 (역순으로 해야 인덱스 유지)
    for (var j = children.length - 1; j >= 0; j--) {
      var child = children[j];
      // 좌표 계산
      child.x = wrapper.x + child.x;
      child.y = wrapper.y + child.y;
      // 부모로 이동
      (parent as ChildrenMixin).insertChild(wrapperIndex, child);
      resetLayoutPositioning(child); // Ignore auto-layout 방지
    }

    // 래퍼 삭제
    wrapper.remove();
    return true;
  } catch (e) {
    console.log('[unwrapNodeMultiple] error:', e);
    return false;
  }
}

/**
 * 완전히 빈 프레임/그룹 수집
 */
function collectEmptyFrames(node: SceneNode): SceneNode[] {
  var frames: SceneNode[] = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      if ('children' in n) {
        var children = [...(n as ChildrenMixin).children];
        for (var i = 0; i < children.length; i++) {
          traverse(children[i]);
        }
      }

      if (isEmptyFrame(n)) {
        frames.push(n);
      }
    } catch (e) {
      // skip
    }
  }

  traverse(node);
  return frames;
}

/**
 * 크기 0인 요소 수집
 */
function collectZeroSizeElements(node: SceneNode): SceneNode[] {
  var elements: SceneNode[] = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      if ('children' in n) {
        var children = [...(n as ChildrenMixin).children];
        for (var i = 0; i < children.length; i++) {
          traverse(children[i]);
        }
      }

      if (isZeroSize(n)) {
        elements.push(n);
      }
    } catch (e) {
      // skip
    }
  }

  traverse(node);
  return elements;
}

/**
 * 동일 이름 중첩 래퍼 수집
 */
function collectSameNameNestedWrappers(node: SceneNode): SceneNode[] {
  var wrappers: SceneNode[] = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      if ('children' in n) {
        var children = [...(n as ChildrenMixin).children];
        for (var i = 0; i < children.length; i++) {
          traverse(children[i]);
        }
      }

      if (isSameNameNested(n)) {
        wrappers.push(n);
      }
    } catch (e) {
      // skip
    }
  }

  traverse(node);
  return wrappers;
}

/**
 * 노드에 실제 렌더링 콘텐츠가 있는지 확인 (재귀)
 * - BOOLEAN_OPERATION은 마스킹 구조이므로 콘텐츠로 취급 안 함 (자식도 무시)
 * - Shape/Text/Vector는 실제 콘텐츠로 취급
 */
function hasVisualContentDeep(node: SceneNode): boolean {
  // 텍스트는 항상 콘텐츠
  if (node.type === 'TEXT') {
    return true;
  }

  // 벡터/라인은 콘텐츠
  if (node.type === 'VECTOR' || node.type === 'LINE') {
    return true;
  }

  // Shape 타입 (RECTANGLE, ELLIPSE 등) - 실제 콘텐츠
  if (node.type === 'RECTANGLE' ||
      node.type === 'ELLIPSE' ||
      node.type === 'POLYGON' ||
      node.type === 'STAR') {
    return true;
  }

  // BOOLEAN_OPERATION은 마스킹 구조이므로 콘텐츠로 취급 안 함
  // 자식도 탐색하지 않음 (마스킹에 사용된 shape들이므로)
  if (node.type === 'BOOLEAN_OPERATION') {
    return false;
  }

  // 그 외 컨테이너는 자식 재귀 탐색
  if ('children' in node) {
    var children = (node as ChildrenMixin).children;
    for (var j = 0; j < children.length; j++) {
      if (hasVisualContentDeep(children[j])) return true;
    }
  }

  return false;
}

/**
 * 빈 중복 형제 프레임 수집
 * - 같은 부모 안에 같은 이름의 프레임이 2개 이상
 * - 그 중 하나는 콘텐츠 있고, 하나는 비어있을 때 빈 것 수집
 */
function collectEmptyDuplicateSiblings(node: SceneNode): SceneNode[] {
  var toRemove: SceneNode[] = [];

  function traverse(n: SceneNode) {
    if (!('children' in n)) return;

    var children = (n as ChildrenMixin).children;

    // 이름별로 자식 그룹화 (FRAME/GROUP만)
    var nameGroups: { [key: string]: SceneNode[] } = {};
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.type === 'FRAME' || child.type === 'GROUP') {
        if (!nameGroups[child.name]) {
          nameGroups[child.name] = [];
        }
        nameGroups[child.name].push(child);
      }
    }

    // 같은 이름이 2개 이상인 그룹 처리
    for (var name in nameGroups) {
      var siblings = nameGroups[name];
      if (siblings.length < 2) continue;

      var withContent: SceneNode[] = [];
      var empty: SceneNode[] = [];

      for (var j = 0; j < siblings.length; j++) {
        if (hasVisualContentDeep(siblings[j])) {
          withContent.push(siblings[j]);
        } else {
          empty.push(siblings[j]);
        }
      }

      // 하나 이상 콘텐츠 있고, 하나 이상 비어있을 때만 빈 것 제거
      if (withContent.length > 0 && empty.length > 0) {
        console.log(`[EmptyDuplicate] "${name}": ${withContent.length}개 콘텐츠O, ${empty.length}개 비어있음 → 빈 것 제거`);
        for (var k = 0; k < empty.length; k++) {
          toRemove.push(empty[k]);
        }
      }
    }

    // 재귀 탐색
    for (var m = 0; m < children.length; m++) {
      traverse(children[m]);
    }
  }

  traverse(node);
  return toRemove;
}

// ============ 기존 함수들 (하위 호환성 유지) ============

/**
 * @deprecated collectEmptyFrames 사용 권장
 * 이미지가 없는 빈 아바타/이미지 프레임인지 확인
 */
function isEmptyImageFrame(node: SceneNode): boolean {
  var IMAGE_KEYWORDS = ['avatar', 'user', 'pic', 'photo', 'image', 'profile', 'thumbnail'];
  var lowerName = node.name.toLowerCase();

  // 이미지 관련 이름인지 확인
  var isImageRelated = false;
  for (var i = 0; i < IMAGE_KEYWORDS.length; i++) {
    if (lowerName.indexOf(IMAGE_KEYWORDS[i]) !== -1) {
      isImageRelated = true;
      break;
    }
  }
  if (!isImageRelated) return false;

  // 자손 중에 실제 이미지/shape가 있는지 확인
  function hasVisualContent(n: SceneNode): boolean {
    // 이미지 타입
    if (n.type === 'IMAGE') return true;

    // Shape 타입 (RECTANGLE, ELLIPSE 등) - 이미지 컨테이너일 가능성
    if (isBasicShapeType(n.type)) {
      // fills가 있으면 시각적 콘텐츠
      if ('fills' in n) {
        var fills = (n as GeometryMixin).fills;
        if (Array.isArray(fills) && fills.length > 0) {
          for (var j = 0; j < fills.length; j++) {
            if (fills[j].visible !== false) {
              return true;
            }
          }
        }
      }
    }

    // 자식 탐색
    if ('children' in n) {
      var children = (n as ChildrenMixin).children;
      for (var k = 0; k < children.length; k++) {
        if (hasVisualContent(children[k])) return true;
      }
    }

    return false;
  }

  // 이미지 관련 이름인데 실제 시각적 콘텐츠가 없으면 빈 프레임
  return !hasVisualContent(node);
}

/**
 * 빈 이미지 프레임 수집 (재귀적)
 */
function collectEmptyImageFrames(node: SceneNode): SceneNode[] {
  var frames: SceneNode[] = [];

  function traverse(n: SceneNode) {
    try {
      if (!n.parent) return;

      if ('children' in n) {
        var children = [...(n as ChildrenMixin).children];
        for (var i = 0; i < children.length; i++) {
          traverse(children[i]);
        }
      }

      if (isEmptyImageFrame(n)) {
        frames.push(n);
      }
    } catch (e) {
      console.log('[collectEmptyImageFrames] error:', e);
    }
  }

  traverse(node);
  return frames;
}

// ============================================
// Auto Layout 내부 무의미 프레임 언래핑
// ============================================

const SAFE_PADDING_THRESHOLD = 4;

/**
 * Auto Layout 내부의 무의미한 중간 프레임 언래핑
 * 조건:
 * - 부모가 Auto Layout
 * - 자식 프레임이 시각적 스타일 없음
 * - 자식 프레임의 padding이 4px 미만
 */
function unwrapInsignificantALChildren(node: SceneNode): number {
  var unwrapped = 0;

  if (node.type !== 'FRAME') return unwrapped;

  var parent = node as FrameNode;

  // 부모가 Auto Layout이어야 함
  if (parent.layoutMode === 'NONE') {
    // 재귀만 수행
    for (var c of [...parent.children]) {
      unwrapped += unwrapInsignificantALChildren(c);
    }
    return unwrapped;
  }

  // 자식들 중 언래핑 대상 찾기
  var children = [...parent.children];
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.type !== 'FRAME') continue;

    var childFrame = child as FrameNode;

    // 조건 체크
    if (!canSafelyUnwrapAL(childFrame)) continue;
    if (hasVisualStylesForAL(childFrame)) continue;
    if (childFrame.children.length === 0) continue;

    // 언래핑 실행
    console.log(`[AL Unwrap] "${childFrame.name}" → 손자 ${childFrame.children.length}개 상위로 이동`);

    var childIndex = parent.children.indexOf(childFrame);
    var grandchildren = [...childFrame.children];

    // 손자들을 부모로 이동 (역순으로 삽입해야 순서 유지)
    for (var j = grandchildren.length - 1; j >= 0; j--) {
      parent.insertChild(childIndex, grandchildren[j]);
      resetLayoutPositioning(grandchildren[j]); // Ignore auto-layout 방지
    }

    // 빈 자식 프레임 제거
    childFrame.remove();
    unwrapped++;
  }

  // 재귀적으로 (새로 이동된) 자식들에도 적용
  for (var c of [...parent.children]) {
    unwrapped += unwrapInsignificantALChildren(c);
  }

  return unwrapped;
}

/**
 * AL 언래핑이 안전한지 체크 (padding 기준)
 */
function canSafelyUnwrapAL(frame: FrameNode): boolean {
  // 일반 프레임이면 OK (padding 개념 없음)
  if (frame.layoutMode === 'NONE') return true;

  // Auto Layout이면 padding 체크
  return frame.paddingLeft < SAFE_PADDING_THRESHOLD &&
         frame.paddingRight < SAFE_PADDING_THRESHOLD &&
         frame.paddingTop < SAFE_PADDING_THRESHOLD &&
         frame.paddingBottom < SAFE_PADDING_THRESHOLD;
}

/**
 * AL 언래핑 대상에서 제외할 시각적 스타일 체크
 */
function hasVisualStylesForAL(frame: FrameNode): boolean {
  // cornerRadius
  if (frame.cornerRadius !== 0) return true;

  // fills
  if (frame.fills && Array.isArray(frame.fills)) {
    for (var fi = 0; fi < frame.fills.length; fi++) {
      if ((frame.fills[fi] as Paint).visible !== false) return true;
    }
  }

  // strokes
  if (frame.strokes && frame.strokes.length > 0) {
    for (var si = 0; si < frame.strokes.length; si++) {
      if (frame.strokes[si].visible !== false) return true;
    }
  }

  // effects
  if (frame.effects && frame.effects.length > 0) {
    for (var ei = 0; ei < frame.effects.length; ei++) {
      if (frame.effects[ei].visible !== false) return true;
    }
  }

  return false;
}

// ============================================
// Deep Flatten - Auto Layout 단일자식 병합
// ============================================

/**
 * 이름 유사도 판단
 * - 'same': 완전히 같은 이름 → 자동 병합
 * - 'similar': 포함 관계 또는 공통 접두사 → 사용자 확인
 * - 'different': 완전히 다름 → 병합 안 함
 */
export type NameSimilarity = 'same' | 'similar' | 'different';

export function getNameSimilarity(parentName: string, childName: string): NameSimilarity {
  // 완전히 같음
  if (parentName === childName) return 'same';

  // 포함 관계 (textfield+dsc ↔ textfield)
  if (parentName.includes(childName) || childName.includes(parentName)) return 'similar';

  // 접두사/접미사 공유 (txt+count ↔ txt+label)
  var parentParts = parentName.split(/[+_\/\-]/);
  var childParts = childName.split(/[+_\/\-]/);
  var shared = parentParts.filter(function(p) {
    return p.length > 2 && childParts.indexOf(p) !== -1;
  });
  if (shared.length > 0) return 'similar';

  // 둘 다 자동생성 이름이면 유사로 처리
  if (isAutoGeneratedName(parentName) && isAutoGeneratedName(childName)) return 'similar';

  return 'different';
}

/**
 * 병합 후보 정보
 */
export interface MergeCandidate {
  parentId: string;
  parentName: string;
  childId: string;
  childName: string;
  similarity: NameSimilarity;
  depth: number;
}

/**
 * Auto Layout 단일자식 병합
 * - 부모가 Auto Layout이고 자식이 Auto Layout 프레임 하나뿐일 때
 * - 자식의 자식들을 부모로 이동
 * - 패딩/간격 속성 합산
 */
function mergeAutoLayoutSingleChild(parent: FrameNode): boolean {
  // 부모가 Auto Layout이어야 함
  if (parent.layoutMode === 'NONE') return false;

  // 자식이 정확히 1개여야 함
  if (parent.children.length !== 1) return false;

  var child = parent.children[0];

  // 자식이 FRAME이어야 함
  if (child.type !== 'FRAME') return false;

  // 자식도 Auto Layout이어야 함
  if (child.layoutMode === 'NONE') return false;

  // ★ 이름 유사도 기반 조건 (2026-01-16 v2)

  // 1. 이름 유사도 체크
  var similarity = getNameSimilarity(parent.name, child.name);
  if (similarity === 'different') {
    // 완전히 다른 이름이면 병합 안 함
    return false;
  }

  // 2. 레이아웃 방향이 같아야 함
  if (parent.layoutMode !== child.layoutMode) {
    return false;
  }

  console.log(`[DeepFlatten] 이름 유사도: "${parent.name}" > "${child.name}" = ${similarity}`);

  // 3. 크기가 거의 같아야 함 (허용 오차 2px)
  var widthDiff = Math.abs(parent.width - child.width);
  var heightDiff = Math.abs(parent.height - child.height);
  if (widthDiff > 2 || heightDiff > 2) {
    return false;
  }

  // 4. 부모에 시각적 스타일 없어야 함
  if (parent.fills && Array.isArray(parent.fills) && parent.fills.length > 0) {
    for (var i = 0; i < parent.fills.length; i++) {
      var fill = parent.fills[i] as Paint;
      if (fill.visible !== false) {
        return false;
      }
    }
  }
  if (parent.strokes && parent.strokes.length > 0) {
    for (var j = 0; j < parent.strokes.length; j++) {
      if (parent.strokes[j].visible !== false) {
        return false;
      }
    }
  }
  if (parent.effects && parent.effects.length > 0) {
    for (var k = 0; k < parent.effects.length; k++) {
      if (parent.effects[k].visible !== false) {
        return false;
      }
    }
  }

  // 5. 자식이 원점 근처에 있어야 함 (오프셋 역할이 아님)
  if (child.x > 5 || child.y > 5) {
    return false;
  }

  console.log(`[DeepFlatten] AL 병합: ${parent.name} > ${child.name} (동일 이름, 동일 크기)`);

  // 레이아웃 속성 병합 계산
  var newPaddingLeft = parent.paddingLeft + child.paddingLeft + child.x;
  var newPaddingTop = parent.paddingTop + child.paddingTop + child.y;
  var newPaddingRight = parent.paddingRight + child.paddingRight;
  var newPaddingBottom = parent.paddingBottom + child.paddingBottom;

  // 자식의 자식들 정보 수집
  var grandchildren = [...child.children];

  // 자식의 자식들을 부모로 이동
  for (var i = 0; i < grandchildren.length; i++) {
    parent.appendChild(grandchildren[i]);
    resetLayoutPositioning(grandchildren[i]); // Ignore auto-layout 방지
  }

  // 부모 레이아웃 속성 업데이트
  parent.paddingLeft = newPaddingLeft;
  parent.paddingTop = newPaddingTop;
  parent.paddingRight = newPaddingRight;
  parent.paddingBottom = newPaddingBottom;
  parent.itemSpacing = child.itemSpacing;

  // ★ 추가 속성 인계 (자식 → 부모) - 자식이 실제 콘텐츠 담당
  // 정렬 속성
  parent.primaryAxisAlignItems = child.primaryAxisAlignItems;
  parent.counterAxisAlignItems = child.counterAxisAlignItems;

  // 크기 모드
  parent.layoutSizingHorizontal = child.layoutSizingHorizontal;
  parent.layoutSizingVertical = child.layoutSizingVertical;

  // wrap 속성 (있으면)
  if ('layoutWrap' in parent && 'layoutWrap' in child) {
    (parent as any).layoutWrap = (child as any).layoutWrap;
  }
  if ('counterAxisSpacing' in parent && 'counterAxisSpacing' in child) {
    (parent as any).counterAxisSpacing = (child as any).counterAxisSpacing;
  }

  // ★ 시각적 속성 인계 (자식이 스타일 담당일 수 있음)
  // cornerRadius (둥근 모서리)
  if (child.cornerRadius !== 0 && parent.cornerRadius === 0) {
    parent.cornerRadius = child.cornerRadius;
    console.log(`[DeepFlatten] cornerRadius 인계: ${child.cornerRadius}`);
  }
  // 개별 모서리 (topLeftRadius 등)
  if ('topLeftRadius' in child && 'topLeftRadius' in parent) {
    if ((child as any).topLeftRadius !== 0 || (child as any).topRightRadius !== 0 ||
        (child as any).bottomLeftRadius !== 0 || (child as any).bottomRightRadius !== 0) {
      (parent as any).topLeftRadius = (child as any).topLeftRadius;
      (parent as any).topRightRadius = (child as any).topRightRadius;
      (parent as any).bottomLeftRadius = (child as any).bottomLeftRadius;
      (parent as any).bottomRightRadius = (child as any).bottomRightRadius;
    }
  }

  // fills (배경색) - 부모가 비어있고 자식에 있으면 인계
  if (child.fills && Array.isArray(child.fills) && child.fills.length > 0) {
    var childHasVisibleFill = false;
    for (var fi = 0; fi < child.fills.length; fi++) {
      if ((child.fills[fi] as Paint).visible !== false) {
        childHasVisibleFill = true;
        break;
      }
    }
    if (childHasVisibleFill) {
      var parentHasVisibleFill = false;
      if (parent.fills && Array.isArray(parent.fills)) {
        for (var pi = 0; pi < parent.fills.length; pi++) {
          if ((parent.fills[pi] as Paint).visible !== false) {
            parentHasVisibleFill = true;
            break;
          }
        }
      }
      if (!parentHasVisibleFill) {
        parent.fills = child.fills;
        console.log(`[DeepFlatten] fills 인계`);
      }
    }
  }

  // strokes (테두리) - 부모가 비어있고 자식에 있으면 인계
  if (child.strokes && child.strokes.length > 0) {
    var childHasVisibleStroke = false;
    for (var si = 0; si < child.strokes.length; si++) {
      if (child.strokes[si].visible !== false) {
        childHasVisibleStroke = true;
        break;
      }
    }
    if (childHasVisibleStroke && (!parent.strokes || parent.strokes.length === 0)) {
      parent.strokes = child.strokes;
      parent.strokeWeight = child.strokeWeight;
      console.log(`[DeepFlatten] strokes 인계`);
    }
  }

  // effects (그림자 등) - 부모가 비어있고 자식에 있으면 인계
  if (child.effects && child.effects.length > 0) {
    var childHasVisibleEffect = false;
    for (var ei = 0; ei < child.effects.length; ei++) {
      if (child.effects[ei].visible !== false) {
        childHasVisibleEffect = true;
        break;
      }
    }
    if (childHasVisibleEffect && (!parent.effects || parent.effects.length === 0)) {
      parent.effects = child.effects;
      console.log(`[DeepFlatten] effects 인계`);
    }
  }

  // 레이아웃 방향이 다르면 자식 방향으로 변경
  if (parent.layoutMode !== child.layoutMode) {
    console.log(`[DeepFlatten] 레이아웃 방향 변경: ${parent.layoutMode} → ${child.layoutMode}`);
    parent.layoutMode = child.layoutMode;
  }

  // 자식 제거
  try {
    child.remove();
  } catch (e) {
    // 이미 제거됨
  }

  console.log(`[DeepFlatten] 병합 완료: padding=(${newPaddingLeft}, ${newPaddingTop}), gap=${parent.itemSpacing}, align=${parent.primaryAxisAlignItems}/${parent.counterAxisAlignItems}`);
  return true;
}

/**
 * 완전히 빈 요소인지 확인 (자식도 없고 시각적 스타일도 없음)
 */
function isCompletelyEmpty(node: SceneNode): boolean {
  // 프레임이나 그룹만 대상
  if (node.type !== 'FRAME' && node.type !== 'GROUP') return false;

  // 자식이 있으면 빈 게 아님
  if ('children' in node && node.children.length > 0) return false;

  // 프레임인 경우 시각적 스타일 체크
  if (node.type === 'FRAME') {
    // fills가 있으면 보존
    if ('fills' in node && Array.isArray(node.fills)) {
      for (var i = 0; i < node.fills.length; i++) {
        if ((node.fills[i] as Paint).visible !== false) {
          return false;
        }
      }
    }
    // strokes가 있으면 보존
    if (node.strokes.length > 0) {
      for (var j = 0; j < node.strokes.length; j++) {
        if (node.strokes[j].visible !== false) {
          return false;
        }
      }
    }
    // effects가 있으면 보존
    if (node.effects.length > 0) {
      for (var k = 0; k < node.effects.length; k++) {
        if (node.effects[k].visible !== false) {
          return false;
        }
      }
    }
  }

  return true;
}

/**
 * Auto Layout 내부 빈 요소 제거
 * - 형제가 있을 때만 제거 (단독 빈 요소는 placeholder일 수 있음)
 */
function removeEmptyFromAutoLayout(node: FrameNode): number {
  if (node.layoutMode === 'NONE') return 0;

  var removed = 0;
  var children = [...node.children];

  // 형제가 1개 이하면 제거하지 않음
  if (children.length <= 1) return 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (isCompletelyEmpty(child)) {
      console.log(`[DeepFlatten] AL 내 빈 요소 제거: ${child.name}`);
      try {
        child.remove();
        removed++;
      } catch (e) {
        // 이미 제거됨
      }
    }
  }

  return removed;
}

/**
 * 깊은 구조 단순화 (재귀적)
 * - Auto Layout 단일자식 병합
 * - 빈 요소 제거
 * - 반복 적용
 */
function deepFlattenNode(node: SceneNode): { merged: number; emptyRemoved: number } {
  var merged = 0;
  var emptyRemoved = 0;

  if (node.type !== 'FRAME') {
    return { merged, emptyRemoved };
  }

  var frame = node as FrameNode;
  var changed = true;
  var iterations = 0;
  var maxIterations = 10;  // 무한 루프 방지

  while (changed && iterations < maxIterations) {
    changed = false;
    iterations++;

    // 1. Auto Layout 단일자식 병합
    if (mergeAutoLayoutSingleChild(frame)) {
      merged++;
      changed = true;
      continue;  // 병합 후 다시 체크
    }

    // 2. 빈 요소 제거
    var removedCount = removeEmptyFromAutoLayout(frame);
    if (removedCount > 0) {
      emptyRemoved += removedCount;
      changed = true;
    }
  }

  // 3. 재귀적으로 자식들에도 적용
  var children = [...frame.children];
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.type === 'FRAME') {
      var childResult = deepFlattenNode(child);
      merged += childResult.merged;
      emptyRemoved += childResult.emptyRemoved;
    }
  }

  return { merged, emptyRemoved };
}

/**
 * 선택된 노드에 깊은 구조 단순화 적용
 */
function collectAndDeepFlatten(node: SceneNode): { merged: number; emptyRemoved: number } {
  console.log(`[DeepFlatten] 시작: ${node.name}`);

  // 깊이 우선으로 자식부터 처리
  var totalMerged = 0;
  var totalEmptyRemoved = 0;

  function traverse(n: SceneNode) {
    if ('children' in n) {
      var children = [...(n as ChildrenMixin).children];
      for (var i = 0; i < children.length; i++) {
        traverse(children[i]);
      }
    }

    if (n.type === 'FRAME') {
      var result = deepFlattenNode(n);
      totalMerged += result.merged;
      totalEmptyRemoved += result.emptyRemoved;
    }
  }

  traverse(node);

  console.log(`[DeepFlatten] 완료: ${totalMerged}개 병합, ${totalEmptyRemoved}개 빈요소 제거`);
  return { merged: totalMerged, emptyRemoved: totalEmptyRemoved };
}

/**
 * 공격적 래퍼 제거 (규칙 기반)
 * 실행 순서:
 * 1. 완전히 빈 프레임/그룹 제거
 * 2. 크기 0인 요소 제거
 * 3. 부모 범위 밖 요소 제거
 * 4. 기존 래퍼 제거 (unwrap)
 * 5. 동일 이름 중첩 제거 (unwrap)
 * 6. 빈 중복 형제 제거
 * 7. Deep Flatten (Auto Layout 단일자식 병합)
 */
export function cleanupWrappersAggressive(node: SceneNode): AggressiveCleanupResult {
  console.log(`[Aggressive] 시작: ${node.name}`);

  // 0. Auto Layout 내부 무의미 프레임 언래핑 (비활성화 - 레이아웃 안정성 문제)
  // var alUnwrapped = unwrapInsignificantALChildren(node);
  // console.log(`[Aggressive] AL 언래핑: ${alUnwrapped}개`);
  var alUnwrapped = 0;

  // 1. 완전히 빈 프레임/그룹 제거
  var emptyFrames = collectEmptyFrames(node);
  console.log(`[Aggressive] 빈 프레임 ${emptyFrames.length}개 발견`);

  var emptyFramesRemoved = 0;
  for (var i = 0; i < emptyFrames.length; i++) {
    try {
      console.log(`[Aggressive] 빈 프레임 제거: ${emptyFrames[i].name}`);
      emptyFrames[i].remove();
      emptyFramesRemoved++;
    } catch (e) {
      // 이미 제거됨
    }
  }

  // 2. 크기 0인 요소 제거
  var zeroSizeElements = collectZeroSizeElements(node);
  console.log(`[Aggressive] 크기 0 요소 ${zeroSizeElements.length}개 발견`);

  var zeroSizeRemoved = 0;
  for (var j = 0; j < zeroSizeElements.length; j++) {
    try {
      console.log(`[Aggressive] 크기 0 제거: ${zeroSizeElements[j].name}`);
      zeroSizeElements[j].remove();
      zeroSizeRemoved++;
    } catch (e) {
      // 이미 제거됨
    }
  }

  // 3. 부모 범위 밖 요소 제거
  var outOfBoundsElements = collectOutOfBoundsElements(node);
  console.log(`[Aggressive] 범위 밖 요소 ${outOfBoundsElements.length}개 발견`);

  var outOfBoundsRemoved = 0;
  for (var k = 0; k < outOfBoundsElements.length; k++) {
    try {
      console.log(`[Aggressive] 범위 밖 제거: ${outOfBoundsElements[k].name}`);
      outOfBoundsElements[k].remove();
      outOfBoundsRemoved++;
    } catch (e) {
      // 이미 제거됨
    }
  }

  // 4. 기존 래퍼 제거 (unwrap)
  var candidates = collectWrapperCandidates(node, true);
  console.log(`[Aggressive] 래퍼 후보 ${candidates.length}개 발견`);

  var removedCount = 0;
  var removedNames: string[] = [];

  for (var m = 0; m < candidates.length; m++) {
    var wrapper = candidates[m];
    try {
      var wrapperName = wrapper.name;
      var unwrapped = unwrapNode(wrapper);
      if (unwrapped) {
        removedCount++;
        removedNames.push(wrapperName);
      }
    } catch (e) {
      console.log(`[Aggressive] 래퍼 제거 실패: ${wrapper.name}`, e);
    }
  }

  // 5. 동일 이름 중첩의 내부 래퍼 먼저 제거 (avatar > avatar에서 내부 avatar)
  // 외부보다 내부를 먼저 제거해야 부모 구조가 유지됨
  var innerWrappers = collectInnerSameNameWrappers(node);
  console.log(`[Aggressive] 내부 동일이름 래퍼 ${innerWrappers.length}개 발견`);

  var sameNameRemoved = 0;
  var innerRemoved = 0;
  for (var p = 0; p < innerWrappers.length; p++) {
    var innerWrapper = innerWrappers[p];
    try {
      console.log(`[Aggressive] 내부 래퍼 제거: ${innerWrapper.name}`);
      var innerUnwrapped = unwrapNodeMultiple(innerWrapper as FrameNode);
      if (innerUnwrapped) {
        innerRemoved++;
        sameNameRemoved++;
      }
    } catch (e) {
      // 이미 제거됨
    }
  }

  // 6. 동일 이름 중첩 제거 (unwrap) - 외부 프레임
  // 마스킹 역할 아닌 외부 래퍼 제거
  var sameNameWrappers = collectSameNameNestedWrappers(node);
  console.log(`[Aggressive] 동일 이름 중첩 ${sameNameWrappers.length}개 발견`);

  for (var n = 0; n < sameNameWrappers.length; n++) {
    var sameNameWrapper = sameNameWrappers[n];
    try {
      console.log(`[Aggressive] 동일 이름 중첩 제거: ${sameNameWrapper.name}`);
      var sameUnwrapped = unwrapNode(sameNameWrapper);
      if (sameUnwrapped) {
        sameNameRemoved++;
      }
    } catch (e) {
      // 이미 제거됨
    }
  }

  // 7. 빈 중복 형제 제거
  // 같은 이름의 형제 중 콘텐츠 없는 것만 제거 (feed 카드 등 보호)
  var emptyDuplicates = collectEmptyDuplicateSiblings(node);
  console.log(`[Aggressive] 빈 중복 형제 ${emptyDuplicates.length}개 발견`);

  var emptyDuplicatesRemoved = 0;
  for (var q = 0; q < emptyDuplicates.length; q++) {
    var emptyDup = emptyDuplicates[q];
    try {
      console.log(`[Aggressive] 빈 중복 제거: ${emptyDup.name}`);
      emptyDup.remove();
      emptyDuplicatesRemoved++;
    } catch (e) {
      // 이미 제거됨
    }
  }

  // 8. Deep Flatten (Auto Layout 단일자식 병합)
  // ★ 비활성화 - 기존 flattenSameNameChain과 충돌, 추가 검토 필요 (2026-01-16)
  var deepFlattenMerged = 0;
  var deepFlattenEmptyRemoved = 0;

  console.log(`[Aggressive] 완료: AL언래핑 ${alUnwrapped}, 빈프레임 ${emptyFramesRemoved}, 크기0 ${zeroSizeRemoved}, 범위밖 ${outOfBoundsRemoved}, 래퍼 ${removedCount}, 동일이름 ${sameNameRemoved}, 빈중복 ${emptyDuplicatesRemoved}, AL병합 ${deepFlattenMerged}, AL빈제거 ${deepFlattenEmptyRemoved}`);

  return {
    success: true,
    removed: removedCount,
    removedNames,
    outOfBoundsRemoved,
    emptyFramesRemoved,
    zeroSizeRemoved,
    sameNameRemoved,
    emptyDuplicatesRemoved,
    deepFlattenMerged,
    deepFlattenEmptyRemoved,
    alUnwrapped,
    // 하위 호환
    emptyImageRemoved: emptyFramesRemoved,
  };
}

/**
 * 선택된 노드들에 공격적 래퍼 제거 적용 (규칙 기반)
 */
export function cleanupSelectionWrappersAggressive(): {
  success: boolean;
  message: string;
  details?: AggressiveCleanupResult;
} {
  try {
    var selection = figma.currentPage.selection;

    if (selection.length === 0) {
      return {
        success: false,
        message: '선택된 요소가 없습니다.',
      };
    }

    var totalRemoved = 0;
    var totalOutOfBounds = 0;
    var totalEmptyFrames = 0;
    var totalZeroSize = 0;
    var totalSameName = 0;
    var totalEmptyDuplicates = 0;
    var totalDeepFlattenMerged = 0;
    var totalDeepFlattenEmpty = 0;
    var totalALUnwrapped = 0;
    var allRemovedNames: string[] = [];

    for (var i = 0; i < selection.length; i++) {
      var result = cleanupWrappersAggressive(selection[i]);
      totalRemoved += result.removed;
      totalOutOfBounds += result.outOfBoundsRemoved;
      totalEmptyFrames += result.emptyFramesRemoved;
      totalZeroSize += result.zeroSizeRemoved;
      totalSameName += result.sameNameRemoved;
      totalEmptyDuplicates += result.emptyDuplicatesRemoved;
      totalDeepFlattenMerged += result.deepFlattenMerged;
      totalDeepFlattenEmpty += result.deepFlattenEmptyRemoved;
      totalALUnwrapped += result.alUnwrapped;
      for (var j = 0; j < result.removedNames.length; j++) {
        allRemovedNames.push(result.removedNames[j]);
      }
    }

    var totalAll = totalRemoved + totalOutOfBounds + totalEmptyFrames + totalZeroSize + totalSameName + totalEmptyDuplicates + totalDeepFlattenMerged + totalDeepFlattenEmpty + totalALUnwrapped;

    if (totalAll === 0) {
      return {
        success: true,
        message: '제거할 요소가 없습니다.',
        details: {
          success: true,
          removed: 0,
          removedNames: [],
          outOfBoundsRemoved: 0,
          emptyFramesRemoved: 0,
          zeroSizeRemoved: 0,
          sameNameRemoved: 0,
          emptyDuplicatesRemoved: 0,
          deepFlattenMerged: 0,
          deepFlattenEmptyRemoved: 0,
          alUnwrapped: 0,
          emptyImageRemoved: 0,
        },
      };
    }

    var msgParts: string[] = [];
    if (totalEmptyFrames > 0) {
      msgParts.push(totalEmptyFrames + '개 빈프레임');
    }
    if (totalZeroSize > 0) {
      msgParts.push(totalZeroSize + '개 크기0');
    }
    if (totalOutOfBounds > 0) {
      msgParts.push(totalOutOfBounds + '개 범위밖');
    }
    if (totalRemoved > 0) {
      msgParts.push(totalRemoved + '개 래퍼');
    }
    if (totalSameName > 0) {
      msgParts.push(totalSameName + '개 동일이름');
    }
    if (totalEmptyDuplicates > 0) {
      msgParts.push(totalEmptyDuplicates + '개 빈중복');
    }
    if (totalDeepFlattenMerged > 0) {
      msgParts.push(totalDeepFlattenMerged + '개 AL병합');
    }
    if (totalDeepFlattenEmpty > 0) {
      msgParts.push(totalDeepFlattenEmpty + '개 AL빈제거');
    }
    if (totalALUnwrapped > 0) {
      msgParts.push(totalALUnwrapped + '개 AL언래핑');
    }
    var msg = msgParts.join(', ') + ' 제거';

    return {
      success: true,
      message: msg,
      details: {
        success: true,
        removed: totalRemoved,
        removedNames: allRemovedNames,
        outOfBoundsRemoved: totalOutOfBounds,
        emptyFramesRemoved: totalEmptyFrames,
        zeroSizeRemoved: totalZeroSize,
        sameNameRemoved: totalSameName,
        emptyDuplicatesRemoved: totalEmptyDuplicates,
        deepFlattenMerged: totalDeepFlattenMerged,
        deepFlattenEmptyRemoved: totalDeepFlattenEmpty,
        alUnwrapped: totalALUnwrapped,
        emptyImageRemoved: totalEmptyFrames,
      },
    };
  } catch (e) {
    console.log('[Aggressive Cleanup] error:', e);
    return {
      success: false,
      message: '정리 중 오류가 발생했습니다: ' + String(e),
    };
  }
}

// ============================================
// Group → Frame 변환
// ============================================

/**
 * 단일 GROUP을 FRAME으로 변환
 */
function convertGroupToFrame(group: GroupNode): FrameNode | null {
  try {
    // 노드가 아직 존재하는지 확인
    var groupName: string;
    var groupX: number;
    var groupY: number;
    var groupW: number;
    var groupH: number;
    try {
      groupName = group.name;
      groupX = group.x;
      groupY = group.y;
      groupW = group.width;
      groupH = group.height;
    } catch (e) {
      return null;
    }

    var parent = group.parent;
    if (!parent || !('children' in parent)) return null;

    var index = parent.children.indexOf(group);
    if (index < 0) return null;

    // ★ 핵심: 모든 자식의 상대 좌표와 크기를 미리 계산
    // GROUP에서 자식을 하나씩 빼면 GROUP 위치가 변경되므로
    // FRAME으로 이동 시 constraints가 적용되어 크기가 변할 수 있으므로 크기도 저장
    var childData: Array<{ node: SceneNode; relX: number; relY: number; w: number; h: number }> = [];
    var children = [...group.children];
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      childData.push({
        node: child,
        relX: child.x - groupX,
        relY: child.y - groupY,
        w: child.width,
        h: child.height
      });
    }

    // 새 프레임 생성
    var frame = figma.createFrame();
    frame.name = groupName;
    frame.x = groupX;
    frame.y = groupY;
    frame.resize(groupW, groupH);
    frame.fills = [];
    frame.clipsContent = false;

    // 같은 위치에 삽입
    parent.insertChild(index, frame);

    // 미리 계산한 좌표와 크기로 자식 이동
    for (var j = 0; j < childData.length; j++) {
      var data = childData[j];
      frame.appendChild(data.node);
      data.node.x = data.relX;
      data.node.y = data.relY;
      // 크기 복원 (constraints로 인한 크기 변경 방지)
      if ('resize' in data.node) {
        try {
          (data.node as GeometryMixin).resize(data.w, data.h);
        } catch (e) {
          // 일부 노드는 resize 불가
        }
      }
    }

    // 원본 그룹 제거
    try {
      group.remove();
    } catch (e) {
      // GROUP은 자식이 없으면 자동 제거될 수 있음
    }

    return frame;
  } catch (e) {
    console.log(`[GroupToFrame] 변환 실패`, e);
    return null;
  }
}

/**
 * 노드 내 모든 GROUP을 FRAME으로 변환
 * 깊이 우선 탐색으로 가장 깊은 GROUP부터 변환 (좌표 안정성)
 */
export function convertAllGroupsToFrames(node: SceneNode): {
  success: boolean;
  converted: number;
  names: string[];
} {
  var converted = 0;
  var names: string[] = [];

  // 모든 GROUP 수집 (깊이 우선 - 자식 먼저, 부모 나중)
  var groups: GroupNode[] = [];

  function collectAllGroups(n: SceneNode) {
    if ('children' in n) {
      var children = [...(n as ChildrenMixin).children];
      for (var i = 0; i < children.length; i++) {
        collectAllGroups(children[i]);
      }
    }
    if (n.type === 'GROUP') {
      groups.push(n as GroupNode);
    }
  }

  collectAllGroups(node);
  console.log(`[GroupToFrame] 전체 GROUP ${groups.length}개 발견`);

  for (var i = 0; i < groups.length; i++) {
    var group = groups[i];
    var groupName: string;
    try {
      groupName = group.name;
    } catch (e) {
      continue;
    }
    var result = convertGroupToFrame(group);
    if (result) {
      converted++;
      names.push(groupName);
      console.log(`[GroupToFrame] 변환: ${groupName}`);
    }
  }

  return { success: true, converted, names };
}

/**
 * 선택된 노드들의 GROUP을 FRAME으로 변환
 */
export function convertSelectionGroupsToFrames(): {
  success: boolean;
  message: string;
  converted: number;
} {
  try {
    var selection = figma.currentPage.selection;

    if (selection.length === 0) {
      return {
        success: false,
        message: '선택된 요소가 없습니다.',
        converted: 0,
      };
    }

    var totalConverted = 0;
    var allNames: string[] = [];

    for (var i = 0; i < selection.length; i++) {
      var result = convertAllGroupsToFrames(selection[i]);
      totalConverted += result.converted;
      for (var j = 0; j < result.names.length; j++) {
        allNames.push(result.names[j]);
      }
    }

    if (totalConverted === 0) {
      return {
        success: true,
        message: '변환할 GROUP이 없습니다.',
        converted: 0,
      };
    }

    return {
      success: true,
      message: `${totalConverted}개 GROUP → FRAME 변환 완료`,
      converted: totalConverted,
    };
  } catch (e) {
    console.log('[GroupToFrame] error:', e);
    return {
      success: false,
      message: '변환 중 오류가 발생했습니다: ' + String(e),
      converted: 0,
    };
  }
}
