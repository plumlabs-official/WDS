/**
 * Cleanup 유틸리티 함수 모듈
 *
 * cleanup.ts에서 추출된 순수 유틸리티 함수들
 * - 자동 생성 이름 판단
 * - 레이아웃 위치 리셋
 * - Shape 자손 탐지
 * - 크기 비교
 * - Auto Layout 래퍼 판단
 */

import { isShapeType } from '../../constants';

// ============================================
// 이름 판단 유틸리티
// ============================================

/**
 * 자동 생성된 이름인지 판단
 *
 * Figma에서 자동으로 생성되는 레이어 이름 패턴을 검사합니다.
 *
 * @param name - 검사할 레이어 이름
 * @returns 자동 생성 패턴이면 true
 *
 * @example
 * isAutoGeneratedName("Frame 123456") // true
 * isAutoGeneratedName("Group 1")       // true
 * isAutoGeneratedName("Rectangle 5")   // true
 * isAutoGeneratedName("Button")        // false
 * isAutoGeneratedName("Header Frame")  // false
 *
 * 지원 패턴:
 * - "Frame 123456"
 * - "Group 123"
 * - "Rectangle 1"
 * - "Ellipse 2"
 * - "Line 3"
 * - "Vector 4"
 */
export function isAutoGeneratedName(name: string): boolean {
  return /^(Frame|Group|Rectangle|Ellipse|Line|Vector)\s*\d*$/.test(name);
}

// ============================================
// 레이아웃 유틸리티
// ============================================

/**
 * 노드 이동 후 layoutPositioning을 AUTO로 리셋
 *
 * 문제: insertChild/appendChild로 노드를 다른 부모로 이동시킬 때
 * layoutPositioning이 ABSOLUTE로 변경되어 "Ignore auto-layout"이 활성화됨
 *
 * 해결: 이동 후 명시적으로 AUTO로 설정
 *
 * @param node - 리셋할 노드
 *
 * @example
 * parent.insertChild(index, child);
 * resetLayoutPositioning(child); // ABSOLUTE → AUTO
 */
export function resetLayoutPositioning(node: SceneNode): void {
  try {
    // layoutPositioning은 Auto Layout 자식에만 존재
    if ('layoutPositioning' in node) {
      const asLayoutChild = node as SceneNode & { layoutPositioning: 'AUTO' | 'ABSOLUTE' };
      if (asLayoutChild.layoutPositioning === 'ABSOLUTE') {
        asLayoutChild.layoutPositioning = 'AUTO';
        console.log(`[Cleanup] layoutPositioning 리셋: "${node.name}" ABSOLUTE → AUTO`);
      }
    }
  } catch (e) {
    // 부모가 Auto Layout이 아닌 경우 무시
  }
}

// ============================================
// 노드 탐색 유틸리티
// ============================================

/**
 * 자손 중에 shape이 있는지 재귀적으로 검사
 *
 * Shape 타입: RECTANGLE, ELLIPSE, POLYGON, STAR, LINE, VECTOR
 *
 * @param node - 검사할 노드
 * @param depth - 현재 탐색 깊이 (내부용, 기본값 0)
 * @returns shape 자손이 있으면 true
 *
 * @example
 * // 버튼 내부에 Rectangle이 있는지 확인
 * if (hasShapeDescendant(buttonFrame)) {
 *   console.log("시각적 컨테이너 역할을 하는 프레임");
 * }
 *
 * @remarks
 * 성능을 위해 최대 3레벨까지만 탐색합니다.
 */
export function hasShapeDescendant(node: SceneNode, depth: number = 0): boolean {
  if (depth > 3) return false; // 최대 3레벨만 검사

  if (isShapeType(node.type)) {
    return true;
  }

  if ('children' in node) {
    for (let i = 0; i < node.children.length; i++) {
      if (hasShapeDescendant(node.children[i], depth + 1)) {
        return true;
      }
    }
  }
  return false;
}

// ============================================
// 크기/비교 유틸리티
// ============================================

/**
 * 두 프레임의 크기가 비슷한지 확인 (허용 오차 내)
 *
 * @param a - 첫 번째 프레임
 * @param b - 두 번째 프레임
 * @param tolerance - 허용 오차 (px), 기본값 5
 * @returns 크기 차이가 tolerance 이내면 true
 *
 * @example
 * // 5px 오차 이내인지 확인 (기본값)
 * isSimilarSize(frameA, frameB) // true if |width diff| <= 5 && |height diff| <= 5
 *
 * // 20px 오차 허용 (동일 이름 체인용)
 * isSimilarSize(frameA, frameB, 20)
 */
export function isSimilarSize(a: FrameNode, b: FrameNode, tolerance: number = 5): boolean {
  const widthDiff = Math.abs(a.width - b.width);
  const heightDiff = Math.abs(a.height - b.height);
  return widthDiff <= tolerance && heightDiff <= tolerance;
}

/**
 * Auto Layout 프레임이 무의미한 래퍼인지 확인
 *
 * 조건:
 * - 패딩이 없거나 무의미 (< 4px)
 * - 시각적 스타일이 없음 (stroke, effect, cornerRadius 없음)
 * - fill은 자식에게 이전 가능하므로 무시
 *
 * @param node - 검사할 프레임 노드
 * @returns 무의미한 래퍼면 true
 *
 * @example
 * if (node.layoutMode !== 'NONE' && isEmptyAutoLayoutWrapper(node)) {
 *   // 이 Auto Layout 프레임은 병합 가능
 * }
 */
export function isEmptyAutoLayoutWrapper(node: FrameNode): boolean {
  // 패딩 체크 (4px 미만이면 무의미)
  const PADDING_THRESHOLD = 4;
  if (node.paddingTop >= PADDING_THRESHOLD ||
      node.paddingRight >= PADDING_THRESHOLD ||
      node.paddingBottom >= PADDING_THRESHOLD ||
      node.paddingLeft >= PADDING_THRESHOLD) {
    return false;
  }

  // cornerRadius 체크
  if (typeof node.cornerRadius === 'number' && node.cornerRadius > 0) {
    return false;
  }

  // strokes 체크
  if (node.strokes && node.strokes.length > 0) {
    for (const s of node.strokes) {
      if (s.visible !== false) return false;
    }
  }

  // effects 체크
  if (node.effects && node.effects.length > 0) {
    for (const e of node.effects) {
      if (e.visible !== false) return false;
    }
  }

  // fill은 자식에게 이전 가능하므로 체크 안 함
  return true;
}

// ============================================
// 보호 키워드 (상수)
// ============================================

/**
 * 이름 기반 보호 키워드 목록
 *
 * 이 키워드가 포함된 프레임은 래퍼로 판단하지 않음
 * (이미지/아바타 관련 프레임 보존용)
 */
export const PROTECTED_KEYWORDS = [
  'user',
  'avatar',
  'pic',
  'photo',
  'image',
  'profile',
  'thumbnail',
  'icon',
] as const;

/**
 * 이름에 보호 키워드가 포함되어 있는지 확인
 *
 * @param name - 검사할 레이어 이름
 * @returns 보호 키워드가 포함되어 있으면 true
 *
 * @example
 * hasProtectedKeyword("user-avatar")  // true
 * hasProtectedKeyword("profile-pic")  // true
 * hasProtectedKeyword("Button")       // false
 */
export function hasProtectedKeyword(name: string): boolean {
  const lowerName = name.toLowerCase();
  return PROTECTED_KEYWORDS.some(keyword => lowerName.includes(keyword));
}
