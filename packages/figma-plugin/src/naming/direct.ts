/**
 * Direct Naming Module
 *
 * AI 호출 없이 규칙 기반으로 직접 네이밍하는 함수들
 */

import {
  isIconLibraryName,
  convertIconLibraryToWDS,
  isKoreanLabel,
  convertKoreanLabel,
  isHyphenIconPattern,
  convertHyphenIconToWDS,
  isInTabbarContext,
  isIconStateContainer,
  isCamelCase,
  convertCamelCaseToPascalCase,
  inferSectionNameFromChildren,
  inferLayoutName,
  tryStructuralNaming,
  isTopLevelScreenFrame,
  cleanScreenName,
  inferNameForAutoGenerated,
} from './helpers';

/**
 * 유효한 시맨틱 컴포넌트 타입 목록
 * - 이 목록에 없는 타입으로 시작하는 이름은 AI 재분석 대상
 */
export const VALID_SEMANTIC_TYPES = [
  // 최상위
  'Screen',
  // 구조 컨테이너 (Layout, Content 금지!)
  'TopBar', 'TabBar', 'Section', 'Container',
  // UI 컴포넌트
  'Card', 'Button', 'Input', 'Avatar', 'Icon', 'Image', 'ListItem', 'TabItem',
  'Badge', 'Tag', 'Header', 'Toggle', 'Checkbox', 'ProgressBar',
  'Timer', 'HomeIndicator', 'Frame',
  // 피드백
  'Toast', 'Modal', 'Snackbar', 'Overlay',
  // 로딩
  'Skeleton', 'Spinner',
];

/**
 * 유효한 시맨틱 이름인지 확인
 * - '/'가 포함되어야 함
 * - 첫 번째 부분이 VALID_SEMANTIC_TYPES에 있어야 함
 */
export function hasValidSemanticName(name: string): boolean {
  if (!name.includes('/')) return false;

  const firstPart = name.split('/')[0];
  return VALID_SEMANTIC_TYPES.includes(firstPart);
}

/**
 * 노드에 직접 변환 적용 (AI 호출 없이)
 * - 부모 도메인 기반 구조적 네이밍
 * - 아이콘 라이브러리, 한글 레이블, 하이픈 패턴, camelCase 방어
 * @returns 변환된 이름 또는 null (AI 분석 필요)
 */
export function tryDirectNaming(node: SceneNode): string | null {
  const name = node.name;

  // -1. 최상위 스크린 프레임 처리 (PAGE 바로 아래)
  // Container/HomeScreen → HomeScreen
  if (isTopLevelScreenFrame(node)) {
    const cleanedName = cleanScreenName(name);
    if (cleanedName !== name) {
      return cleanedName;
    }
    // 이미 깨끗하면 그대로 유지
    return null;
  }

  // 0. Layout 프레임 감지 (최우선 - header, bottom, main content 등)
  // e.g., "header" → "Layout/Header"
  // e.g., "Main Content" → "Layout/Main"
  // 구조적 네이밍보다 먼저 실행하여 Layout 일관성 유지
  const layoutName = inferLayoutName(node);
  if (layoutName) {
    return layoutName;
  }

  // 1. 부모 도메인 기반 구조적 네이밍
  // e.g., "Weekly Challenge Content" → "Content" (부모가 Section/WeeklyChallenge일 때)
  const structuralName = tryStructuralNaming(node);
  if (structuralName) {
    return structuralName;
  }

  // 1. 아이콘 라이브러리 형식 (carbon:xxx, solar:xxx 등)
  if (isIconLibraryName(name)) {
    return convertIconLibraryToWDS(name);
  }

  // 2. 하이픈 패턴 아이콘 (user-circle-02, award-04 등)
  if (isHyphenIconPattern(name)) {
    return convertHyphenIconToWDS(name);
  }

  // 3. 한글 레이블 (홈, 라운지, 마이페이지 등)
  if (isKoreanLabel(name)) {
    const englishLabel = convertKoreanLabel(name);
    // 탭바 컨텍스트면 TabItem/
    if (isInTabbarContext(node)) {
      return `TabItem/${englishLabel}`;
    }
    return englishLabel;
  }

  // 4. 아이콘 상태 컨테이너 (자식에 on/off)
  if (isIconStateContainer(node)) {
    if (isHyphenIconPattern(name)) {
      return convertHyphenIconToWDS(name);
    }
    // 이름 유지
    return null;
  }

  // 5. camelCase 방어 → PascalCase 변환
  if (isCamelCase(name)) {
    return convertCamelCaseToPascalCase(name);
  }

  // 6. 일반 이름 + 자식 키워드 기반 Section 추론
  // e.g., details (자식에 Challenge 키워드) → Section/ActiveChallenge
  const sectionName = inferSectionNameFromChildren(node);
  if (sectionName) {
    return sectionName;
  }

  // 7. 자동 생성 이름 처리 (Frame 123456, Group 123 등)
  // 자식/부모 컨텍스트에서 의미 있는 이름 추론
  const autoGenName = inferNameForAutoGenerated(node);
  if (autoGenName) {
    return autoGenName;
  }

  return null; // AI 분석 필요
}

/**
 * 재귀적으로 모든 자식 노드 수집 (depth 무제한)
 */
export function collectAllNodes(node: SceneNode, result: SceneNode[]): void {
  result.push(node);

  if ('children' in node) {
    const children = (node as ChildrenMixin).children;
    for (const child of children) {
      collectAllNodes(child, result);
    }
  }
}
