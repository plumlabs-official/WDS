/**
 * Naming Handler Module
 *
 * AI Naming Agent와의 통신 및 결과 처리
 */

import {
  shouldSkipNaming,
  shouldSkipForParentComponent,
  inferTabItemNameFromIcon,
  resolveSiblingDuplicates,
  makeUniqueSiblingName,
  hasExistingSiblingConflict,
  isAutoGeneratedName,
  isBlacklistedName,
} from './helpers';

import {
  tryDirectNaming,
  collectAllNodes,
  hasValidSemanticName,
} from './direct';

// ============================================
// Types
// ============================================

export interface NamingResultMessage {
  type: 'naming-result';
  success?: boolean;
  data?: {
    suggestedName: string;
    componentType?: string;
    confidence?: number;
    reasoning?: string;
  };
  error?: string;
}

export interface NamingBatchResultMessage {
  type: 'naming-batch-result';
  success?: boolean;
  results?: Array<{
    success?: boolean;
    data?: { suggestedName: string };
  }>;
  error?: string;
}

export interface NamingContextResultMessage {
  type: 'naming-context-result';
  success?: boolean;
  data?: {
    results: Array<{
      nodeId: string;
      suggestedName: string;
      componentType: string;
      variant?: string;
      size?: string;
      confidence: number;
      reasoning: string;
    }>;
  };
  error?: string;
}

// ============================================
// State
// ============================================

let pendingNamingNode: SceneNode | null = null;
let pendingNamingNodes: SceneNode[] = [];

export function getPendingNamingNode(): SceneNode | null {
  return pendingNamingNode;
}

export function setPendingNamingNode(node: SceneNode | null): void {
  pendingNamingNode = node;
}

export function getPendingNamingNodes(): SceneNode[] {
  return pendingNamingNodes;
}

export function setPendingNamingNodes(nodes: SceneNode[]): void {
  pendingNamingNodes = nodes;
}

export function clearPendingNamingNodes(): void {
  pendingNamingNodes = [];
}

// ============================================
// Utilities
// ============================================

/**
 * 최상위 스크린 프레임 찾기
 * - 노드에서 위로 올라가며 가장 상위의 FRAME 반환
 * - PAGE 바로 아래 프레임 = 스크린
 */
function findScreenFrame(node: SceneNode): FrameNode | null {
  let current: BaseNode | null = node;
  let lastFrame: FrameNode | null = null;

  while (current && current.type !== 'PAGE') {
    if (current.type === 'FRAME') {
      lastFrame = current as FrameNode;
    }
    current = current.parent;
  }

  return lastFrame;
}

/**
 * 전체 스크린 캡처 (1회만)
 * - 1x 스케일로 캡처 (크기 절약)
 */
async function captureScreenContext(screenFrame: FrameNode): Promise<string | null> {
  try {
    const bytes = await screenFrame.exportAsync({
      format: 'PNG',
      constraint: { type: 'SCALE', value: 1 }, // 1x로 충분 (크기 절약)
    });
    return 'data:image/png;base64,' + figma.base64Encode(bytes);
  } catch (error) {
    console.error('Screen context capture failed:', error);
    return null;
  }
}

/**
 * 스크린 기준 노드 깊이 계산
 * - 1: 최상위 (Screen)
 * - 2: Layout 레벨
 * - 3+: 컴포넌트 레벨
 */
function getDepthFromScreen(node: SceneNode, screenFrame: FrameNode): number {
  let depth = 0;
  let current: BaseNode | null = node;

  while (current && current.id !== screenFrame.id) {
    depth++;
    current = current.parent;
  }

  // screenFrame 자체면 depth = 1
  return node.id === screenFrame.id ? 1 : depth;
}

/**
 * 스크린 기준 상대 좌표 및 깊이 계산
 */
function getRelativePosition(node: SceneNode, screenFrame: FrameNode): {
  x: number;
  y: number;
  width: number;
  height: number;
  depth: number;
} {
  // absoluteTransform: [[scaleX, skewY, translateX], [skewX, scaleY, translateY]]
  const nodeAbsolute = node.absoluteTransform;
  const screenAbsolute = screenFrame.absoluteTransform;

  return {
    x: Math.round(nodeAbsolute[0][2] - screenAbsolute[0][2]),
    y: Math.round(nodeAbsolute[1][2] - screenAbsolute[1][2]),
    width: Math.round(node.width),
    height: Math.round(node.height),
    depth: getDepthFromScreen(node, screenFrame),
  };
}

/**
 * 노드 구조 정보 추출 (패턴 매칭용)
 */
/**
 * 텍스트 지문 계산 (TEXT 노드 구분용)
 * - 길이 버킷 (S/M/L)
 * - 숫자/한글/영문 포함 여부
 */
function getTextFingerprint(text: string): string {
  if (!text || text.length === 0) return '';

  const len = text.length <= 10 ? 'S' : text.length <= 30 ? 'M' : 'L';
  const hasNum = /\d/.test(text) ? 'N' : '';
  const hasKor = /[가-힣]/.test(text) ? 'K' : '';
  const hasEng = /[a-zA-Z]/.test(text) ? 'E' : '';
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(text) ? 'P' : '';

  return `${len}${hasNum}${hasKor}${hasEng}${hasSpecial}`;
}

function extractNodeStructure(node: SceneNode, screenFrame: FrameNode): {
  childCount: number;
  childTypes: string[];
  childNames: string[];
  layoutMode: 'HORIZONTAL' | 'VERTICAL' | 'NONE';
  width: number;
  height: number;
  aspectRatio: number;
  positionZone: 'top' | 'middle' | 'bottom';
  textHints: string[];
  iconHints: string[];
  parentName: string | null;
  vectorPathHash: string | null;
  textFingerprint: string | null;
  // 버튼 속성 감지용
  fillColor: string | null;
  opacity: number | null;
  hasStroke: boolean;
  strokeColor: string | null;
  iconPosition: 'left' | 'right' | 'only' | null;
  // 컴포넌트 속성 확장 (Avatar, Card 등)
  cornerRadius: number | null;
  strokeWidth: number | null;
  hasShadow: boolean;
} {
  const childTypes: string[] = [];
  const childNames: string[] = [];
  const textHints: string[] = [];
  const iconHints: string[] = [];
  let vectorPathHash: string | null = null;
  let textFingerprint: string | null = null;

  // 자식 정보 수집
  if ('children' in node) {
    const frame = node as FrameNode;
    for (const child of frame.children) {
      childTypes.push(child.type);
      childNames.push(child.name);

      // 텍스트 힌트
      if (child.type === 'TEXT') {
        const text = (child as TextNode).characters.trim();
        if (text && text.length < 50) {
          textHints.push(text);
        }
      }

      // 아이콘 힌트
      if (child.name.startsWith('Icon/')) {
        iconHints.push(child.name.replace('Icon/', ''));
      }

      // 벡터 경로 해시 (아이콘 구분용)
      if (child.type === 'VECTOR' && 'vectorPaths' in child) {
        const paths = (child as VectorNode).vectorPaths;
        if (paths && paths.length > 0) {
          // 간단한 해시: path 데이터의 첫 100자 + 길이
          const pathStr = paths.map(p => p.data).join('|');
          vectorPathHash = `${pathStr.length}-${pathStr.substring(0, 100)}`;
        }
      }
    }
  }

  // 노드 자체가 벡터인 경우
  if (node.type === 'VECTOR' && 'vectorPaths' in node) {
    const paths = (node as VectorNode).vectorPaths;
    if (paths && paths.length > 0) {
      const pathStr = paths.map(p => p.data).join('|');
      vectorPathHash = `${pathStr.length}-${pathStr.substring(0, 100)}`;
    }
  }

  // 노드 자체가 TEXT인 경우 - 텍스트 지문 계산
  if (node.type === 'TEXT') {
    const text = (node as TextNode).characters;
    textFingerprint = getTextFingerprint(text);
  }

  // 레이아웃 모드
  let layoutMode: 'HORIZONTAL' | 'VERTICAL' | 'NONE' = 'NONE';
  if (node.type === 'FRAME') {
    const frame = node as FrameNode;
    if (frame.layoutMode === 'HORIZONTAL' || frame.layoutMode === 'VERTICAL') {
      layoutMode = frame.layoutMode;
    }
  }

  // 위치 영역 계산 (스크린 기준 상대 좌표)
  const nodeAbsolute = node.absoluteTransform;
  const screenAbsolute = screenFrame.absoluteTransform;
  const relativeY = nodeAbsolute[1][2] - screenAbsolute[1][2];
  const centerY = relativeY + node.height / 2;
  const relativeYRatio = centerY / screenFrame.height;

  let positionZone: 'top' | 'middle' | 'bottom' = 'middle';
  if (relativeYRatio < 0.15) positionZone = 'top';
  else if (relativeYRatio >= 0.85) positionZone = 'bottom';

  // 부모 이름 추출 (자동생성 이름은 제외)
  let parentName: string | null = null;
  if (node.parent && 'name' in node.parent) {
    const pName = (node.parent as SceneNode).name;
    if (pName && !isAutoGeneratedName(pName)) {
      parentName = pName;
    }
  }

  // 채우기 색상 추출 (첫 번째 solid fill, 노드 또는 자식에서)
  let fillColor: string | null = null;
  let opacity: number | null = null;

  // 헬퍼: 노드에서 solid fill 색상 추출
  const extractFillFromNode = (n: SceneNode): { color: string | null; opacity: number | null } => {
    if ('fills' in n && Array.isArray(n.fills)) {
      const fills = n.fills as Paint[];
      const solidFill = fills.find(f => f.type === 'SOLID' && f.visible !== false);
      if (solidFill && solidFill.type === 'SOLID') {
        const c = solidFill.color;
        const r = Math.round(c.r * 255).toString(16).padStart(2, '0');
        const g = Math.round(c.g * 255).toString(16).padStart(2, '0');
        const b = Math.round(c.b * 255).toString(16).padStart(2, '0');
        return {
          color: `#${r}${g}${b}`.toUpperCase(),
          opacity: solidFill.opacity ?? 1
        };
      }
    }
    return { color: null, opacity: null };
  };

  // 1. 노드 자체에서 fill 추출 시도
  const nodeFill = extractFillFromNode(node);
  fillColor = nodeFill.color;
  opacity = nodeFill.opacity;

  // 2. 노드에 fill이 없으면 자식에서 재귀적으로 탐색 (최대 2레벨)
  // 버튼 구조: Button > Background (GROUP/FRAME) > Rectangle
  if (!fillColor && 'children' in node) {
    const findFillRecursive = (parent: SceneNode, depth: number): { color: string | null; opacity: number | null } => {
      if (depth > 2) return { color: null, opacity: null };
      if (!('children' in parent)) return { color: null, opacity: null };

      const frame = parent as FrameNode;
      for (const child of frame.children) {
        // RECTANGLE, ELLIPSE에서 직접 fill 추출
        if (child.type === 'RECTANGLE' || child.type === 'ELLIPSE') {
          const childFill = extractFillFromNode(child);
          if (childFill.color) {
            return childFill;
          }
        }
        // FRAME, GROUP인 경우 한 레벨 더 탐색
        if ((child.type === 'FRAME' || child.type === 'GROUP') && 'children' in child) {
          const nestedFill = findFillRecursive(child, depth + 1);
          if (nestedFill.color) {
            return nestedFill;
          }
        }
      }
      return { color: null, opacity: null };
    };

    const foundFill = findFillRecursive(node, 1);
    fillColor = foundFill.color;
    opacity = foundFill.opacity;
  }

  // 노드 전체 투명도도 고려
  if ('opacity' in node && typeof node.opacity === 'number') {
    opacity = opacity !== null ? opacity * node.opacity : node.opacity;
  }

  // Stroke 정보 추출 (Outlined 버튼 감지용)
  let hasStroke = false;
  let strokeColor: string | null = null;

  // 헬퍼: 노드에서 stroke 정보 추출
  const extractStrokeFromNode = (n: SceneNode): { hasStroke: boolean; color: string | null } => {
    if ('strokes' in n && Array.isArray(n.strokes)) {
      const strokes = n.strokes as Paint[];
      const visibleStroke = strokes.find(s => s.type === 'SOLID' && s.visible !== false);
      if (visibleStroke && visibleStroke.type === 'SOLID') {
        const c = visibleStroke.color;
        const r = Math.round(c.r * 255).toString(16).padStart(2, '0');
        const g = Math.round(c.g * 255).toString(16).padStart(2, '0');
        const b = Math.round(c.b * 255).toString(16).padStart(2, '0');
        return {
          hasStroke: true,
          color: `#${r}${g}${b}`.toUpperCase()
        };
      }
    }
    return { hasStroke: false, color: null };
  };

  // 1. 노드 자체에서 stroke 추출
  const nodeStroke = extractStrokeFromNode(node);
  hasStroke = nodeStroke.hasStroke;
  strokeColor = nodeStroke.color;

  // 2. 노드에 stroke가 없으면 자식에서 재귀적으로 탐색 (최대 2레벨)
  if (!hasStroke && 'children' in node) {
    const findStrokeRecursive = (parent: SceneNode, depth: number): { hasStroke: boolean; color: string | null } => {
      if (depth > 2) return { hasStroke: false, color: null };
      if (!('children' in parent)) return { hasStroke: false, color: null };

      const frame = parent as FrameNode;
      for (const child of frame.children) {
        if (child.type === 'RECTANGLE' || child.type === 'ELLIPSE') {
          const childStroke = extractStrokeFromNode(child);
          if (childStroke.hasStroke) {
            return childStroke;
          }
        }
        if ((child.type === 'FRAME' || child.type === 'GROUP') && 'children' in child) {
          const nestedStroke = findStrokeRecursive(child, depth + 1);
          if (nestedStroke.hasStroke) {
            return nestedStroke;
          }
        }
      }
      return { hasStroke: false, color: null };
    };

    const foundStroke = findStrokeRecursive(node, 1);
    hasStroke = foundStroke.hasStroke;
    strokeColor = foundStroke.color;
  }

  // cornerRadius 추출 (Avatar Circle 감지용)
  let cornerRadius: number | null = null;
  if ('cornerRadius' in node && typeof node.cornerRadius === 'number') {
    cornerRadius = node.cornerRadius;
  } else if ('children' in node) {
    // 자식에서 cornerRadius 찾기 (첫 번째 RECTANGLE/ELLIPSE)
    const frame = node as FrameNode;
    for (const child of frame.children) {
      if ((child.type === 'RECTANGLE' || child.type === 'ELLIPSE') &&
          'cornerRadius' in child && typeof child.cornerRadius === 'number') {
        cornerRadius = child.cornerRadius;
        break;
      }
    }
  }

  // strokeWidth 추출 (Input 테두리 두께)
  let strokeWidth: number | null = null;
  if ('strokeWeight' in node && typeof node.strokeWeight === 'number') {
    strokeWidth = node.strokeWeight;
  } else if ('children' in node) {
    // 자식에서 strokeWeight 찾기
    const frame = node as FrameNode;
    for (const child of frame.children) {
      if ('strokeWeight' in child && typeof child.strokeWeight === 'number' && child.strokeWeight > 0) {
        strokeWidth = child.strokeWeight;
        break;
      }
    }
  }

  // effects 추출 (Card Elevation 감지용)
  let hasShadow = false;
  if ('effects' in node && Array.isArray(node.effects)) {
    hasShadow = (node.effects as Effect[]).some(
      e => e.type === 'DROP_SHADOW' && e.visible !== false
    );
  }
  // 노드에 없으면 자식에서 찾기
  if (!hasShadow && 'children' in node) {
    const frame = node as FrameNode;
    for (const child of frame.children) {
      if ('effects' in child && Array.isArray(child.effects)) {
        hasShadow = (child.effects as Effect[]).some(
          e => e.type === 'DROP_SHADOW' && e.visible !== false
        );
        if (hasShadow) break;
      }
    }
  }

  // 아이콘 위치 감지 (버튼 내 아이콘 위치)
  let iconPosition: 'left' | 'right' | 'only' | null = null;

  if ('children' in node) {
    const frame = node as FrameNode;
    let iconChild: SceneNode | null = null;
    let textChild: SceneNode | null = null;

    for (const child of frame.children) {
      // 아이콘 감지: VECTOR, Icon/* 이름, 또는 작은 FRAME/GROUP (아이콘 컨테이너)
      if (child.type === 'VECTOR' ||
          child.name.startsWith('Icon/') ||
          child.name.toLowerCase().includes('icon') ||
          (child.type === 'FRAME' && child.width < 32 && child.height < 32)) {
        iconChild = child;
      }
      // 텍스트 감지
      if (child.type === 'TEXT') {
        textChild = child;
      }
    }

    if (iconChild) {
      if (!textChild) {
        // 아이콘만 있음
        iconPosition = 'only';
      } else {
        // 아이콘과 텍스트 둘 다 있음 - 위치 비교
        const iconCenterX = iconChild.x + iconChild.width / 2;
        const textCenterX = textChild.x + textChild.width / 2;
        iconPosition = iconCenterX < textCenterX ? 'left' : 'right';
      }
    }
  }

  return {
    childCount: childTypes.length,
    childTypes,
    childNames: childNames.length > 0 ? childNames : [],
    layoutMode,
    width: node.width,
    height: node.height,
    aspectRatio: node.width / node.height,
    positionZone,
    textHints: textHints.length > 0 ? textHints : [],
    iconHints: iconHints.length > 0 ? iconHints : [],
    parentName,
    vectorPathHash,
    textFingerprint,
    fillColor,
    opacity,
    hasStroke,
    strokeColor,
    iconPosition,
    cornerRadius,
    strokeWidth,
    hasShadow,
  };
}

// ============================================
// Handlers
// ============================================

/**
 * AI Naming Agent 핸들러 (재귀 + 제외/변환 로직)
 */
export async function handleNamingAgent(): Promise<void> {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('노드를 선택해주세요.', { error: true });
    return;
  }

  figma.ui.postMessage({ type: 'task-start', taskName: 'AI 네이밍 분석 중...' });

  // 1. 모든 노드 수집 (재귀)
  const allNodes: SceneNode[] = [];
  for (const node of selection) {
    collectAllNodes(node, allNodes);
  }

  // 2. 직접 변환 vs AI 분석 분류
  const directChanges: { node: SceneNode; oldName: string; newName: string }[] = [];
  const nodesForAI: SceneNode[] = [];
  let skippedCount = 0;
  const AI_TARGET_TYPES = ['FRAME', 'GROUP', 'COMPONENT', 'INSTANCE', 'TEXT', 'RECTANGLE'];

  for (const node of allNodes) {
    // 디버그: 최상위 프레임 체크
    const isTopLevel = node.parent?.type === 'PAGE';
    if (isTopLevel) {
      console.log(`[Naming Debug] 최상위 프레임 감지: "${node.name}" (type: ${node.type})`);
    }

    // 제외 조건 확인
    if (shouldSkipNaming(node)) {
      if (isTopLevel) console.log(`[Naming Debug] 최상위 프레임 스킵됨 (shouldSkipNaming)`);
      skippedCount++;
      continue;
    }

    // 부모 컴포넌트 체크 (Button/*, Card/* 내부면 스킵)
    const parentCheck = shouldSkipForParentComponent(node);
    if (parentCheck.shouldSkip) {
      if (isTopLevel) console.log(`[Naming Debug] 최상위 프레임 스킵됨 (shouldSkipForParentComponent): ${parentCheck.reason}`);
      skippedCount++;
      console.log(`[Naming] 스킵: "${node.name}" - ${parentCheck.reason}`);
      continue;
    }

    // 직접 변환 시도
    const directName = tryDirectNaming(node);
    if (isTopLevel) console.log(`[Naming Debug] 최상위 프레임 directName: ${directName}`);

    // 언더스코어 포함 노드는 무조건 AI 분석 대상 (네이밍 규칙 위반)
    if (node.name.includes('_') && AI_TARGET_TYPES.includes(node.type)) {
      console.log(`[Naming] 언더스코어 감지: "${node.name}" → AI로 위임`);
      nodesForAI.push(node);
      continue;
    }

    // directName이 blacklist면 AI로 위임
    if (directName && isBlacklistedName(directName)) {
      console.log(`[Naming] Blacklist 감지: "${directName}" → AI로 위임`);
      if (AI_TARGET_TYPES.includes(node.type)) {
        nodesForAI.push(node);
      }
    } else if (directName && directName !== node.name) {
      directChanges.push({
        node,
        oldName: node.name,
        newName: directName,
      });
    } else if (AI_TARGET_TYPES.includes(node.type)) {
      // AI 대상 타입이고 직접 변환 불가능하면 AI 분석 대상
      // 자동생성 이름(Frame 123456)은 무조건 포함
      if (isAutoGeneratedName(node.name)) {
        nodesForAI.push(node);
      } else if (!directName && !hasValidSemanticName(node.name)) {
        nodesForAI.push(node);
      }
    }
  }

  // 디버그: 노드 분류 요약
  console.log(`[Naming Debug] 전체: ${allNodes.length}, 스킵: ${skippedCount}, 직접변환: ${directChanges.length}, AI위임: ${nodesForAI.length}`);
  const underscoreNodes = nodesForAI.filter(n => n.name.includes('_'));
  if (underscoreNodes.length > 0) {
    console.log(`[Naming Debug] AI위임 중 언더스코어 포함: ${underscoreNodes.length}개`);
  }

  // 3. 형제 중복 이름 해결 + 기존 형제와 충돌 체크
  const resolvedChanges = resolveSiblingDuplicates(directChanges);
  const appliedDirectChanges: { node: SceneNode; oldName: string; newName: string }[] = [];
  let collisionDeferredCount = 0;

  // 기존 형제와 충돌하는 경우는 직접 변경 스킵 후 AI 재분석으로 위임
  for (const change of resolvedChanges) {
    const uniqueName = makeUniqueSiblingName(change.node, change.newName);
    if (uniqueName === change.node.name && uniqueName !== change.newName) {
      collisionDeferredCount++;
      if (AI_TARGET_TYPES.includes(change.node.type) && !nodesForAI.some(n => n.id === change.node.id)) {
        nodesForAI.push(change.node);
      }
      console.log(`[Naming] 충돌로 직접 변경 스킵 → AI 재분석: "${change.oldName}" -> "${change.newName}"`);
      continue;
    }
    change.newName = uniqueName;
    appliedDirectChanges.push(change);
  }

  // UI 메타 배지: 충돌로 AI 재분석 이관된 개수
  figma.ui.postMessage({
    type: 'naming-deferred-info',
    count: collisionDeferredCount,
  });

  // 4. 직접 변환 적용
  for (const change of appliedDirectChanges) {
    change.node.name = change.newName;
    console.log('[Direct Naming]', change.oldName, '→', change.newName);
  }

  // 4.5. 룰베이스 패턴 정보 수집 (나중에 AI 네이밍 완료 후 저장)
  let ruleBasedPatterns: Array<{ name: string; structure: ReturnType<typeof extractNodeStructure>; sourceNodeId: string }> = [];
  if (appliedDirectChanges.length > 0) {
    const screenFrameForPatterns = findScreenFrame(appliedDirectChanges[0].node);
    if (screenFrameForPatterns) {
      ruleBasedPatterns = appliedDirectChanges.map(change => ({
        name: change.newName,
        structure: extractNodeStructure(change.node, screenFrameForPatterns),
        sourceNodeId: change.node.id
      }));
      console.log(`[Pattern] 룰베이스 ${ruleBasedPatterns.length}개 패턴 수집 (저장은 네이밍 완료 후)`);
    }
  }

  // 3.5. 2차 패스: TabItem 자식 아이콘 기반 이름 유추
  // (직접 변환 후에 실행해야 자식 Icon/* 이름이 적용된 상태)
  let tabItemInferredCount = 0;
  for (const node of allNodes) {
    if (node.name.startsWith('TabItem/')) {
      const inferredName = inferTabItemNameFromIcon(node);
      if (inferredName && inferredName !== node.name) {
        console.log('[TabItem Infer]', node.name, '→', inferredName);
        node.name = inferredName;
        tabItemInferredCount++;
      }
    }
  }

  // 4. AI 분석이 필요한 노드가 있으면 Agent Server 호출 (컨텍스트 기반)
  if (nodesForAI.length > 0) {
    // 스크린 프레임 찾기 (첫 번째 노드 기준)
    const screenFrame = findScreenFrame(nodesForAI[0]);
    if (!screenFrame) {
      figma.notify('스크린 프레임을 찾을 수 없습니다.', { error: true });
      figma.ui.postMessage({ type: 'task-complete' });
      return;
    }

    // 전체 스크린 캡처 (1회만)
    const screenScreenshot = await captureScreenContext(screenFrame);
    if (!screenScreenshot) {
      figma.notify('스크린 캡처에 실패했습니다.', { error: true });
      figma.ui.postMessage({ type: 'task-complete' });
      return;
    }

    // 노드 위치 정보 + 텍스트/아이콘 힌트 + 구조 정보 수집
    pendingNamingNodes = [];
    const nodePositions: Array<{
      nodeId: string;
      currentName: string;
      parentNodeId: string | null;
      parentName: string | null;
      nodeType: string;
      x: number;
      y: number;
      width: number;
      height: number;
      texts: string[];
      iconHints: string[];
      structure: ReturnType<typeof extractNodeStructure>;
    }> = [];

    for (const node of nodesForAI) {
      pendingNamingNodes.push(node);
      const position = getRelativePosition(node, screenFrame);

      // 자식에서 텍스트/아이콘 힌트 수집
      const texts: string[] = [];
      const iconHints: string[] = [];

      if ('children' in node) {
        for (const child of (node as FrameNode).children) {
          if (child.type === 'TEXT') {
            const textContent = (child as TextNode).characters;
            if (textContent && textContent.trim()) {
              texts.push(textContent.trim());
            }
          }
          if (child.name.startsWith('Icon/')) {
            iconHints.push(child.name.replace('Icon/', ''));
          }
        }
      }

      // 부모 정보 가져오기 (부모-자식 동일 이름 방지용)
      const parentNodeId = node.parent && node.parent.type !== 'PAGE'
        ? node.parent.id
        : null;
      const parentName = node.parent && node.parent.type !== 'PAGE'
        ? (node.parent as SceneNode).name
        : null;

      // 구조 정보 추출 (패턴 매칭용)
      const structure = extractNodeStructure(node, screenFrame);

      nodePositions.push({
        nodeId: node.id,
        currentName: node.name,
        parentNodeId,
        parentName,
        nodeType: node.type,
        texts,
        iconHints,
        structure,
        ...position,
      });
    }

    console.log(`[Context Naming] Screen: ${screenFrame.width}x${screenFrame.height}, Nodes: ${nodePositions.length}`);

    // UI로 컨텍스트 기반 요청 전송 (룰베이스 패턴도 함께 전달 - 네이밍 완료 후 저장용)
    figma.ui.postMessage({
      type: 'agent-naming-context',
      data: {
        screenScreenshot,
        screenWidth: screenFrame.width,
        screenHeight: screenFrame.height,
        nodes: nodePositions,
        ruleBasedPatterns, // 네이밍 완료 후 저장할 룰베이스 패턴
      },
    });

    // 직접 변환 결과는 로그로 표시
    if (appliedDirectChanges.length > 0 || tabItemInferredCount > 0 || collisionDeferredCount > 0) {
      console.log(`[AI Naming] 직접 변환: ${appliedDirectChanges.length}개, 충돌→AI: ${collisionDeferredCount}개, TabItem 유추: ${tabItemInferredCount}개, AI 분석: ${nodesForAI.length}개, 제외: ${skippedCount}개`);
    }
  } else {
    // AI 분석이 없으면 배지 초기화
    figma.ui.postMessage({
      type: 'naming-deferred-info',
      count: 0,
    });

    // AI 분석 필요 없음 - 직접 변환만 완료
    const totalChanged = appliedDirectChanges.length + tabItemInferredCount;
    const msg = totalChanged > 0
      ? `네이밍 완료: ${totalChanged}개 변환 (${skippedCount}개 제외)`
      : `변경할 이름이 없습니다. (${skippedCount}개 제외)`;
    figma.notify(msg, { timeout: 3000 });
    figma.ui.postMessage({ type: 'task-complete' });
  }
}

/**
 * Naming Agent 단일 결과 처리
 */
export function handleNamingResult(msg: NamingResultMessage): void {
  if (!msg.success || !msg.data) {
    figma.notify('네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    pendingNamingNode = null;
    return;
  }

  const node = pendingNamingNode;
  if (!node) {
    figma.notify('대상 노드를 찾을 수 없습니다.', { error: true });
    return;
  }

  const result = msg.data;
  const oldName = node.name;

  // 충돌 체크: 충돌 시 적용 보류
  if (hasExistingSiblingConflict(node, result.suggestedName)) {
    console.log(`[AI Naming] 충돌 보류: "${oldName}" → "${result.suggestedName}" (형제 충돌)`);
    figma.notify(`충돌로 적용 보류: ${result.suggestedName}`, { error: true, timeout: 3000 });
    figma.ui.postMessage({
      type: 'naming-collision-hold',
      nodes: [{ nodeId: node.id, suggestedName: result.suggestedName, currentName: oldName }]
    });
    pendingNamingNode = null;
    return;
  }

  node.name = result.suggestedName;

  console.log('[AI Naming]', oldName, '→', result.suggestedName);
  console.log('[AI Naming] Confidence:', result.confidence, ', Reasoning:', result.reasoning);

  figma.notify('이름 변경: ' + oldName + ' → ' + result.suggestedName, { timeout: 3000 });

  pendingNamingNode = null;
}

/**
 * Naming Agent 배치 결과 처리
 */
export function handleNamingBatchResult(msg: NamingBatchResultMessage): void {
  if (!msg.success || !msg.results) {
    figma.notify('배치 네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingNamingNodes = [];
    return;
  }

  let renamedCount = 0;
  const collisionNodes: { nodeId: string; suggestedName: string; currentName: string }[] = [];

  // 1차 패스: AI 제안 이름 중 같은 부모 아래 중복 감지 (충돌 후보 전부 보류 정책)
  const proposedByParent = new Map<string, Map<string, number[]>>(); // parentId -> (name -> indices[])
  for (let i = 0; i < msg.results.length; i++) {
    const result = msg.results[i];
    const node = pendingNamingNodes[i];
    if (result && result.success && result.data && node && node.parent) {
      const parentId = node.parent.id;
      const suggestedName = result.data.suggestedName;
      if (!proposedByParent.has(parentId)) {
        proposedByParent.set(parentId, new Map());
      }
      const nameMap = proposedByParent.get(parentId)!;
      if (!nameMap.has(suggestedName)) {
        nameMap.set(suggestedName, []);
      }
      nameMap.get(suggestedName)!.push(i);
    }
  }

  // 중복 제안된 인덱스 집합
  const duplicateIndices = new Set<number>();
  for (const [_parentId, nameMap] of proposedByParent) {
    for (const [_name, indices] of nameMap) {
      if (indices.length > 1) {
        indices.forEach(idx => duplicateIndices.add(idx));
      }
    }
  }
  if (duplicateIndices.size > 0) {
    console.log(`[AI Naming] 중복 제안 감지: ${duplicateIndices.size}개 노드 전부 보류`);
  }

  // 2차 패스: 실제 적용
  for (let i = 0; i < msg.results.length; i++) {
    const result = msg.results[i];
    const node = pendingNamingNodes[i];

    if (result && result.success && result.data && node) {
      const suggestedName = result.data.suggestedName;
      const oldName = node.name;

      // 충돌 체크 1: AI가 같은 이름을 여러 노드에 제안 → 전부 보류
      if (duplicateIndices.has(i)) {
        collisionNodes.push({ nodeId: node.id, suggestedName, currentName: oldName });
        console.log(`[AI Naming] 중복 제안 보류: "${oldName}" → "${suggestedName}"`);
        continue;
      }

      // 충돌 체크 2: 기존 형제와 충돌 → 보류
      if (hasExistingSiblingConflict(node, suggestedName)) {
        collisionNodes.push({ nodeId: node.id, suggestedName, currentName: oldName });
        console.log(`[AI Naming] 형제 충돌 보류: "${oldName}" → "${suggestedName}"`);
        continue;
      }

      node.name = suggestedName;
      console.log('[AI Naming]', oldName, '→', suggestedName);
      renamedCount++;
    }
  }

  // 충돌 노드 UI 전송
  if (collisionNodes.length > 0) {
    console.log(`[AI Naming] 적용 성공: ${renamedCount}개, 충돌 보류: ${collisionNodes.length}개`);
    figma.ui.postMessage({
      type: 'naming-collision-hold',
      nodes: collisionNodes
    });
  }

  figma.notify(`AI 네이밍 완료: ${renamedCount}개 변경, ${collisionNodes.length}개 보류`, { timeout: 3000 });

  figma.ui.postMessage({ type: 'task-complete' });
  pendingNamingNodes = [];
}

/**
 * Naming Agent 컨텍스트 기반 결과 처리 (전체 스크린 분석)
 */
export function handleNamingContextResult(msg: NamingContextResultMessage): void {
  console.log(`[DEBUG] handleNamingContextResult 시작 - results: ${msg.data?.results?.length ?? 0}, pendingNodes: ${pendingNamingNodes.length}`);

  if (!msg.success || !msg.data || !msg.data.results) {
    figma.notify('컨텍스트 네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingNamingNodes = [];
    return;
  }

  let renamedCount = 0;
  let notFoundCount = 0;
  const collisionNodes: { nodeId: string; suggestedName: string; currentName: string }[] = [];
  const appliedNodeIds: string[] = []; // 패턴 저장 가드용

  // 1차 패스: AI 제안 이름 중 같은 부모 아래 중복 감지 (충돌 후보 전부 보류 정책)
  const proposedByParent = new Map<string, Map<string, string[]>>(); // parentId -> (name -> nodeIds[])
  for (const result of msg.data.results) {
    const node = pendingNamingNodes.find(n => n.id === result.nodeId);
    if (node && node.parent) {
      const parentId = node.parent.id;
      if (!proposedByParent.has(parentId)) {
        proposedByParent.set(parentId, new Map());
      }
      const nameMap = proposedByParent.get(parentId)!;
      if (!nameMap.has(result.suggestedName)) {
        nameMap.set(result.suggestedName, []);
      }
      nameMap.get(result.suggestedName)!.push(node.id);
    }
  }

  // 중복 제안된 nodeId 집합 (같은 부모 아래 같은 이름 2개 이상)
  const duplicateNodeIds = new Set<string>();
  for (const [_parentId, nameMap] of proposedByParent) {
    for (const [_name, nodeIds] of nameMap) {
      if (nodeIds.length > 1) {
        nodeIds.forEach(id => duplicateNodeIds.add(id));
      }
    }
  }
  if (duplicateNodeIds.size > 0) {
    console.log(`[Context AI Naming] 중복 제안 감지: ${duplicateNodeIds.size}개 노드 전부 보류`);
  }

  // 2차 패스: 실제 적용 (중복 제안 또는 기존 형제 충돌 시 보류)
  for (const result of msg.data.results) {
    const node = pendingNamingNodes.find(n => n.id === result.nodeId);
    if (node) {
      const oldName = node.name;

      // 충돌 체크 1: AI가 같은 이름을 여러 노드에 제안 → 전부 보류
      if (duplicateNodeIds.has(node.id)) {
        collisionNodes.push({ nodeId: node.id, suggestedName: result.suggestedName, currentName: oldName });
        console.log(`[Context AI Naming] 중복 제안 보류: "${oldName}" → "${result.suggestedName}"`);
        continue;
      }

      // 충돌 체크 2: 기존 형제와 충돌 → 보류
      if (hasExistingSiblingConflict(node, result.suggestedName)) {
        collisionNodes.push({ nodeId: node.id, suggestedName: result.suggestedName, currentName: oldName });
        console.log(`[Context AI Naming] 형제 충돌 보류: "${oldName}" → "${result.suggestedName}"`);
        continue;
      }

      node.name = result.suggestedName;
      appliedNodeIds.push(node.id);
      console.log(`[Context AI Naming] ${oldName} → ${result.suggestedName} (${result.componentType}, confidence: ${result.confidence})`);
      console.log(`  reasoning: ${result.reasoning}`);
      renamedCount++;
    } else {
      console.warn(`[Context AI Naming] Node not found: ${result.nodeId} (source: ${result.source})`);
      notFoundCount++;
    }
  }

  // 충돌 노드 UI 전송
  if (collisionNodes.length > 0) {
    figma.ui.postMessage({
      type: 'naming-collision-hold',
      nodes: collisionNodes
    });
  }

  // 적용 성공 노드 ID 전송 (패턴 저장 가드용)
  figma.ui.postMessage({
    type: 'naming-applied-nodes',
    nodeIds: appliedNodeIds
  });

  console.log(`[Context AI Naming] 적용 성공: ${renamedCount}개, 충돌 보류: ${collisionNodes.length}개, 미발견: ${notFoundCount}개`);
  figma.notify(`AI 컨텍스트 네이밍 완료: ${renamedCount}개 변경, ${collisionNodes.length}개 보류`, { timeout: 3000 });

  figma.ui.postMessage({ type: 'task-complete' });
  pendingNamingNodes = [];
}
