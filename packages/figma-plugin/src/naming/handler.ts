/**
 * Naming Handler Module
 *
 * AI Naming Agent와의 통신 및 결과 처리
 */

import {
  shouldSkipNaming,
  shouldSkipForParentComponent,
  inferTabItemNameFromIcon,
  resolveSiblingDuplicates,
  makeUniqueSiblingName,
  isAutoGeneratedName,
  isBlacklistedName,
} from '../modules/naming';

import {
  tryDirectNaming,
  collectAllNodes,
  hasValidSemanticName,
} from './direct';

// ============================================
// Types
// ============================================

export interface NamingResultMessage {
  type: 'naming-result';
  success?: boolean;
  data?: {
    suggestedName: string;
    componentType?: string;
    confidence?: number;
    reasoning?: string;
  };
  error?: string;
}

export interface NamingBatchResultMessage {
  type: 'naming-batch-result';
  success?: boolean;
  results?: Array<{
    success?: boolean;
    data?: { suggestedName: string };
  }>;
  error?: string;
}

export interface NamingContextResultMessage {
  type: 'naming-context-result';
  success?: boolean;
  data?: {
    results: Array<{
      nodeId: string;
      suggestedName: string;
      componentType: string;
      variant?: string;
      size?: string;
      confidence: number;
      reasoning: string;
    }>;
  };
  error?: string;
}

// ============================================
// State
// ============================================

let pendingNamingNode: SceneNode | null = null;
let pendingNamingNodes: SceneNode[] = [];

export function getPendingNamingNode(): SceneNode | null {
  return pendingNamingNode;
}

export function setPendingNamingNode(node: SceneNode | null): void {
  pendingNamingNode = node;
}

export function getPendingNamingNodes(): SceneNode[] {
  return pendingNamingNodes;
}

export function setPendingNamingNodes(nodes: SceneNode[]): void {
  pendingNamingNodes = nodes;
}

export function clearPendingNamingNodes(): void {
  pendingNamingNodes = [];
}

// ============================================
// Utilities
// ============================================

/**
 * 최상위 스크린 프레임 찾기
 * - 노드에서 위로 올라가며 가장 상위의 FRAME 반환
 * - PAGE 바로 아래 프레임 = 스크린
 */
function findScreenFrame(node: SceneNode): FrameNode | null {
  let current: BaseNode | null = node;
  let lastFrame: FrameNode | null = null;

  while (current && current.type !== 'PAGE') {
    if (current.type === 'FRAME') {
      lastFrame = current as FrameNode;
    }
    current = current.parent;
  }

  return lastFrame;
}

/**
 * 전체 스크린 캡처 (1회만)
 * - 1x 스케일로 캡처 (크기 절약)
 */
async function captureScreenContext(screenFrame: FrameNode): Promise<string | null> {
  try {
    const bytes = await screenFrame.exportAsync({
      format: 'PNG',
      constraint: { type: 'SCALE', value: 1 }, // 1x로 충분 (크기 절약)
    });
    return 'data:image/png;base64,' + figma.base64Encode(bytes);
  } catch (error) {
    console.error('Screen context capture failed:', error);
    return null;
  }
}

/**
 * 스크린 기준 노드 깊이 계산
 * - 1: 최상위 (Screen)
 * - 2: Layout 레벨
 * - 3+: 컴포넌트 레벨
 */
function getDepthFromScreen(node: SceneNode, screenFrame: FrameNode): number {
  let depth = 0;
  let current: BaseNode | null = node;

  while (current && current.id !== screenFrame.id) {
    depth++;
    current = current.parent;
  }

  // screenFrame 자체면 depth = 1
  return node.id === screenFrame.id ? 1 : depth;
}

/**
 * 스크린 기준 상대 좌표 및 깊이 계산
 */
function getRelativePosition(node: SceneNode, screenFrame: FrameNode): {
  x: number;
  y: number;
  width: number;
  height: number;
  depth: number;
} {
  // absoluteTransform: [[scaleX, skewY, translateX], [skewX, scaleY, translateY]]
  const nodeAbsolute = node.absoluteTransform;
  const screenAbsolute = screenFrame.absoluteTransform;

  return {
    x: Math.round(nodeAbsolute[0][2] - screenAbsolute[0][2]),
    y: Math.round(nodeAbsolute[1][2] - screenAbsolute[1][2]),
    width: Math.round(node.width),
    height: Math.round(node.height),
    depth: getDepthFromScreen(node, screenFrame),
  };
}

/**
 * 노드 구조 정보 추출 (패턴 매칭용)
 */
function extractNodeStructure(node: SceneNode, screenFrame: FrameNode): {
  childCount: number;
  childTypes: string[];
  childNames: string[];
  layoutMode: 'HORIZONTAL' | 'VERTICAL' | 'NONE';
  width: number;
  height: number;
  aspectRatio: number;
  positionZone: 'top' | 'middle' | 'bottom';
  textHints: string[];
  iconHints: string[];
} {
  const childTypes: string[] = [];
  const childNames: string[] = [];
  const textHints: string[] = [];
  const iconHints: string[] = [];

  // 자식 정보 수집
  if ('children' in node) {
    const frame = node as FrameNode;
    for (const child of frame.children) {
      childTypes.push(child.type);
      childNames.push(child.name);

      // 텍스트 힌트
      if (child.type === 'TEXT') {
        const text = (child as TextNode).characters.trim();
        if (text && text.length < 50) {
          textHints.push(text);
        }
      }

      // 아이콘 힌트
      if (child.name.startsWith('Icon/')) {
        iconHints.push(child.name.replace('Icon/', ''));
      }
    }
  }

  // 레이아웃 모드
  let layoutMode: 'HORIZONTAL' | 'VERTICAL' | 'NONE' = 'NONE';
  if (node.type === 'FRAME') {
    const frame = node as FrameNode;
    if (frame.layoutMode === 'HORIZONTAL' || frame.layoutMode === 'VERTICAL') {
      layoutMode = frame.layoutMode;
    }
  }

  // 위치 영역 계산 (스크린 기준 상대 좌표)
  const nodeAbsolute = node.absoluteTransform;
  const screenAbsolute = screenFrame.absoluteTransform;
  const relativeY = nodeAbsolute[1][2] - screenAbsolute[1][2];
  const centerY = relativeY + node.height / 2;
  const relativeYRatio = centerY / screenFrame.height;

  let positionZone: 'top' | 'middle' | 'bottom' = 'middle';
  if (relativeYRatio < 0.15) positionZone = 'top';
  else if (relativeYRatio >= 0.85) positionZone = 'bottom';

  return {
    childCount: childTypes.length,
    childTypes,
    childNames: childNames.length > 0 ? childNames : [],
    layoutMode,
    width: node.width,
    height: node.height,
    aspectRatio: node.width / node.height,
    positionZone,
    textHints: textHints.length > 0 ? textHints : [],
    iconHints: iconHints.length > 0 ? iconHints : [],
  };
}

// ============================================
// Handlers
// ============================================

/**
 * AI Naming Agent 핸들러 (재귀 + 제외/변환 로직)
 */
export async function handleNamingAgent(): Promise<void> {
  const selection = figma.currentPage.selection;

  if (selection.length === 0) {
    figma.notify('노드를 선택해주세요.', { error: true });
    return;
  }

  figma.ui.postMessage({ type: 'task-start', taskName: 'AI 네이밍 분석 중...' });

  // 1. 모든 노드 수집 (재귀)
  const allNodes: SceneNode[] = [];
  for (const node of selection) {
    collectAllNodes(node, allNodes);
  }

  // 2. 직접 변환 vs AI 분석 분류
  const directChanges: { node: SceneNode; oldName: string; newName: string }[] = [];
  const nodesForAI: SceneNode[] = [];
  let skippedCount = 0;

  for (const node of allNodes) {
    // 디버그: 최상위 프레임 체크
    const isTopLevel = node.parent?.type === 'PAGE';
    if (isTopLevel) {
      console.log(`[Naming Debug] 최상위 프레임 감지: "${node.name}" (type: ${node.type})`);
    }

    // 제외 조건 확인
    if (shouldSkipNaming(node)) {
      if (isTopLevel) console.log(`[Naming Debug] 최상위 프레임 스킵됨 (shouldSkipNaming)`);
      skippedCount++;
      continue;
    }

    // 부모 컴포넌트 체크 (Button/*, Card/* 내부면 스킵)
    const parentCheck = shouldSkipForParentComponent(node);
    if (parentCheck.shouldSkip) {
      if (isTopLevel) console.log(`[Naming Debug] 최상위 프레임 스킵됨 (shouldSkipForParentComponent): ${parentCheck.reason}`);
      skippedCount++;
      console.log(`[Naming] 스킵: "${node.name}" - ${parentCheck.reason}`);
      continue;
    }

    // 직접 변환 시도
    const directName = tryDirectNaming(node);
    if (isTopLevel) console.log(`[Naming Debug] 최상위 프레임 directName: ${directName}`);

    // AI 네이밍 대상 타입 확장 (TEXT, RECTANGLE 포함)
    const AI_TARGET_TYPES = ['FRAME', 'GROUP', 'COMPONENT', 'INSTANCE', 'TEXT', 'RECTANGLE'];

    // 언더스코어 포함 노드는 무조건 AI 분석 대상 (네이밍 규칙 위반)
    if (node.name.includes('_') && AI_TARGET_TYPES.includes(node.type)) {
      console.log(`[Naming] 언더스코어 감지: "${node.name}" → AI로 위임`);
      nodesForAI.push(node);
      continue;
    }

    // directName이 blacklist면 AI로 위임
    if (directName && isBlacklistedName(directName)) {
      console.log(`[Naming] Blacklist 감지: "${directName}" → AI로 위임`);
      if (AI_TARGET_TYPES.includes(node.type)) {
        nodesForAI.push(node);
      }
    } else if (directName && directName !== node.name) {
      directChanges.push({
        node,
        oldName: node.name,
        newName: directName,
      });
    } else if (AI_TARGET_TYPES.includes(node.type)) {
      // AI 대상 타입이고 직접 변환 불가능하면 AI 분석 대상
      // 자동생성 이름(Frame 123456)은 무조건 포함
      if (isAutoGeneratedName(node.name)) {
        nodesForAI.push(node);
      } else if (!directName && !hasValidSemanticName(node.name)) {
        nodesForAI.push(node);
      }
    }
  }

  // 디버그: 노드 분류 요약
  console.log(`[Naming Debug] 전체: ${allNodes.length}, 스킵: ${skippedCount}, 직접변환: ${directChanges.length}, AI위임: ${nodesForAI.length}`);
  const underscoreNodes = nodesForAI.filter(n => n.name.includes('_'));
  if (underscoreNodes.length > 0) {
    console.log(`[Naming Debug] AI위임 중 언더스코어 포함: ${underscoreNodes.length}개`);
  }

  // 3. 형제 중복 이름 해결 + 기존 형제와 충돌 체크
  const resolvedChanges = resolveSiblingDuplicates(directChanges);

  // 기존 형제와 충돌하는 경우도 해결
  for (const change of resolvedChanges) {
    change.newName = makeUniqueSiblingName(change.node, change.newName);
  }

  // 4. 직접 변환 적용
  for (const change of resolvedChanges) {
    change.node.name = change.newName;
    console.log('[Direct Naming]', change.oldName, '→', change.newName);
  }

  // 4.5. 룰베이스 패턴 정보 수집 (나중에 AI 네이밍 완료 후 저장)
  let ruleBasedPatterns: Array<{ name: string; structure: ReturnType<typeof extractNodeStructure>; sourceNodeId: string }> = [];
  if (resolvedChanges.length > 0) {
    const screenFrameForPatterns = findScreenFrame(resolvedChanges[0].node);
    if (screenFrameForPatterns) {
      ruleBasedPatterns = resolvedChanges.map(change => ({
        name: change.newName,
        structure: extractNodeStructure(change.node, screenFrameForPatterns),
        sourceNodeId: change.node.id
      }));
      console.log(`[Pattern] 룰베이스 ${ruleBasedPatterns.length}개 패턴 수집 (저장은 네이밍 완료 후)`);
    }
  }

  // 3.5. 2차 패스: TabItem 자식 아이콘 기반 이름 유추
  // (직접 변환 후에 실행해야 자식 Icon/* 이름이 적용된 상태)
  let tabItemInferredCount = 0;
  for (const node of allNodes) {
    if (node.name.startsWith('TabItem/')) {
      const inferredName = inferTabItemNameFromIcon(node);
      if (inferredName && inferredName !== node.name) {
        console.log('[TabItem Infer]', node.name, '→', inferredName);
        node.name = inferredName;
        tabItemInferredCount++;
      }
    }
  }

  // 4. AI 분석이 필요한 노드가 있으면 Agent Server 호출 (컨텍스트 기반)
  if (nodesForAI.length > 0) {
    // 스크린 프레임 찾기 (첫 번째 노드 기준)
    const screenFrame = findScreenFrame(nodesForAI[0]);
    if (!screenFrame) {
      figma.notify('스크린 프레임을 찾을 수 없습니다.', { error: true });
      figma.ui.postMessage({ type: 'task-complete' });
      return;
    }

    // 전체 스크린 캡처 (1회만)
    const screenScreenshot = await captureScreenContext(screenFrame);
    if (!screenScreenshot) {
      figma.notify('스크린 캡처에 실패했습니다.', { error: true });
      figma.ui.postMessage({ type: 'task-complete' });
      return;
    }

    // 노드 위치 정보 + 텍스트/아이콘 힌트 + 구조 정보 수집
    pendingNamingNodes = [];
    const nodePositions: Array<{
      nodeId: string;
      currentName: string;
      parentNodeId: string | null;
      parentName: string | null;
      nodeType: string;
      x: number;
      y: number;
      width: number;
      height: number;
      texts: string[];
      iconHints: string[];
      structure: ReturnType<typeof extractNodeStructure>;
    }> = [];

    for (const node of nodesForAI) {
      pendingNamingNodes.push(node);
      const position = getRelativePosition(node, screenFrame);

      // 자식에서 텍스트/아이콘 힌트 수집
      const texts: string[] = [];
      const iconHints: string[] = [];

      if ('children' in node) {
        for (const child of (node as FrameNode).children) {
          if (child.type === 'TEXT') {
            const textContent = (child as TextNode).characters;
            if (textContent && textContent.trim()) {
              texts.push(textContent.trim());
            }
          }
          if (child.name.startsWith('Icon/')) {
            iconHints.push(child.name.replace('Icon/', ''));
          }
        }
      }

      // 부모 정보 가져오기 (부모-자식 동일 이름 방지용)
      const parentNodeId = node.parent && node.parent.type !== 'PAGE'
        ? node.parent.id
        : null;
      const parentName = node.parent && node.parent.type !== 'PAGE'
        ? (node.parent as SceneNode).name
        : null;

      // 구조 정보 추출 (패턴 매칭용)
      const structure = extractNodeStructure(node, screenFrame);

      nodePositions.push({
        nodeId: node.id,
        currentName: node.name,
        parentNodeId,
        parentName,
        nodeType: node.type,
        texts,
        iconHints,
        structure,
        ...position,
      });
    }

    console.log(`[Context Naming] Screen: ${screenFrame.width}x${screenFrame.height}, Nodes: ${nodePositions.length}`);

    // UI로 컨텍스트 기반 요청 전송 (룰베이스 패턴도 함께 전달 - 네이밍 완료 후 저장용)
    figma.ui.postMessage({
      type: 'agent-naming-context',
      data: {
        screenScreenshot,
        screenWidth: screenFrame.width,
        screenHeight: screenFrame.height,
        nodes: nodePositions,
        ruleBasedPatterns, // 네이밍 완료 후 저장할 룰베이스 패턴
      },
    });

    // 직접 변환 결과는 로그로 표시
    if (resolvedChanges.length > 0 || tabItemInferredCount > 0) {
      console.log(`[AI Naming] 직접 변환: ${resolvedChanges.length}개, TabItem 유추: ${tabItemInferredCount}개, AI 분석: ${nodesForAI.length}개, 제외: ${skippedCount}개`);
    }
  } else {
    // AI 분석 필요 없음 - 직접 변환만 완료
    const totalChanged = resolvedChanges.length + tabItemInferredCount;
    const msg = totalChanged > 0
      ? `네이밍 완료: ${totalChanged}개 변환 (${skippedCount}개 제외)`
      : `변경할 이름이 없습니다. (${skippedCount}개 제외)`;
    figma.notify(msg, { timeout: 3000 });
    figma.ui.postMessage({ type: 'task-complete' });
  }
}

/**
 * Naming Agent 단일 결과 처리
 */
export function handleNamingResult(msg: NamingResultMessage): void {
  if (!msg.success || !msg.data) {
    figma.notify('네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    pendingNamingNode = null;
    return;
  }

  const node = pendingNamingNode;
  if (!node) {
    figma.notify('대상 노드를 찾을 수 없습니다.', { error: true });
    return;
  }

  const result = msg.data;
  const oldName = node.name;
  node.name = result.suggestedName;

  console.log('[AI Naming]', oldName, '→', result.suggestedName);
  console.log('[AI Naming] Confidence:', result.confidence, ', Reasoning:', result.reasoning);

  figma.notify('이름 변경: ' + oldName + ' → ' + result.suggestedName, { timeout: 3000 });

  pendingNamingNode = null;
}

/**
 * Naming Agent 배치 결과 처리
 */
export function handleNamingBatchResult(msg: NamingBatchResultMessage): void {
  if (!msg.success || !msg.results) {
    figma.notify('배치 네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingNamingNodes = [];
    return;
  }

  let renamedCount = 0;

  for (let i = 0; i < msg.results.length; i++) {
    const result = msg.results[i];
    const node = pendingNamingNodes[i];

    if (result && result.success && result.data && node) {
      const oldName = node.name;
      node.name = result.data.suggestedName;
      console.log('[AI Naming]', oldName, '→', result.data.suggestedName);
      renamedCount++;
    }
  }

  figma.notify('AI 네이밍 완료: ' + renamedCount + '개 이름 변경', { timeout: 3000 });

  figma.ui.postMessage({ type: 'task-complete' });
  pendingNamingNodes = [];
}

/**
 * Naming Agent 컨텍스트 기반 결과 처리 (전체 스크린 분석)
 */
export function handleNamingContextResult(msg: NamingContextResultMessage): void {
  console.log(`[DEBUG] handleNamingContextResult 시작 - results: ${msg.data?.results?.length ?? 0}, pendingNodes: ${pendingNamingNodes.length}`);

  if (!msg.success || !msg.data || !msg.data.results) {
    figma.notify('컨텍스트 네이밍 분석 실패: ' + (msg.error || 'Unknown error'), { error: true });
    figma.ui.postMessage({ type: 'task-complete' });
    pendingNamingNodes = [];
    return;
  }

  let renamedCount = 0;
  let notFoundCount = 0;

  // nodeId로 매칭하여 이름 적용
  for (const result of msg.data.results) {
    const node = pendingNamingNodes.find(n => n.id === result.nodeId);
    if (node) {
      const oldName = node.name;
      node.name = result.suggestedName;
      console.log(`[Context AI Naming] ${oldName} → ${result.suggestedName} (${result.componentType}, confidence: ${result.confidence})`);
      console.log(`  reasoning: ${result.reasoning}`);
      renamedCount++;
    } else {
      console.warn(`[Context AI Naming] Node not found: ${result.nodeId} (source: ${result.source})`);
      notFoundCount++;
    }
  }

  console.log(`[DEBUG] 결과 적용 완료 - 성공: ${renamedCount}, 미발견: ${notFoundCount}`);
  figma.notify(`AI 컨텍스트 네이밍 완료: ${renamedCount}개 이름 변경`, { timeout: 3000 });

  figma.ui.postMessage({ type: 'task-complete' });
  pendingNamingNodes = [];
}
