/**
 * 이름 추론 함수 모음
 *
 * 규칙:
 * - constants.ts, classify.ts, validate.ts, normalize.ts import 가능
 * - 판단 로직은 classify/validate 호출 (중복 구현 금지)
 * - 이름 생성/추론 로직만
 */

import {
  ICON_STYLE_SUFFIXES,
  ICON_FILLER_WORDS,
  HYPHEN_ICON_PATTERNS,
  WDS_ICON_MAP,
  STRUCTURAL_LAYER_NAMES,
  DOMAIN_KEYWORDS,
  CONTEXT_KEYWORDS,
  LAYOUT_KEYWORD_MAP,
} from './constants';
import {
  isGenericName,
  isAutoGeneratedName,
  isLayoutFrame,
  hasSameNameAsParent,
} from './classify';
import { shouldConvertToLayout } from './validate';

// ============================================
// 아이콘 변환
// ============================================

/**
 * 하이픈 패턴 아이콘 이름을 WDS 네이밍으로 변환
 */
export function convertHyphenIconToWDS(name: string): string {
  // 숫자 접미사 제거
  const withoutNumbers = name.replace(/-\d+$/, '');

  // 직접 매칭
  if (HYPHEN_ICON_PATTERNS[withoutNumbers]) {
    return `Icon/${HYPHEN_ICON_PATTERNS[withoutNumbers]}`;
  }

  // 부분 매칭
  for (const [pattern, wdsName] of Object.entries(HYPHEN_ICON_PATTERNS)) {
    if (withoutNumbers.startsWith(pattern)) {
      return `Icon/${wdsName}`;
    }
  }

  // 폴백: 첫 단어를 PascalCase로
  const parts = withoutNumbers.split('-');
  const firstPart = parts[0];
  const pascalCase = firstPart.charAt(0).toUpperCase() + firstPart.slice(1);
  return `Icon/${pascalCase}`;
}

/**
 * 아이콘 라이브러리 이름을 WDS 네이밍으로 변환
 * e.g., "carbon:ibm-watson-discovery" → "Icon/Discovery"
 */
export function convertIconLibraryToWDS(name: string): string {
  const colonIndex = name.indexOf(':');
  if (colonIndex === -1) return name;

  // 콜론 뒤의 아이콘 이름 추출
  let iconPart = name.slice(colonIndex + 1);

  // 스타일 접미사 제거
  for (const suffix of ICON_STYLE_SUFFIXES) {
    if (iconPart.endsWith(suffix)) {
      iconPart = iconPart.slice(0, -suffix.length);
      break;
    }
  }

  // 1. WDS 매핑 테이블에서 직접 찾기
  const directMatch = WDS_ICON_MAP[iconPart];
  if (directMatch) {
    return `Icon/${directMatch}`;
  }

  // 2. 하이픈으로 분리
  const parts = iconPart.split('-');

  // 3. 각 파트에서 매핑 찾기 (뒤에서부터)
  for (let i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    const partMatch = WDS_ICON_MAP[part];
    if (partMatch) {
      return `Icon/${partMatch}`;
    }
  }

  // 4. 의미 있는 파트들을 조합 (필러 단어와 숫자 제외)
  const meaningfulParts = parts.filter(part => {
    // 숫자만 있는 파트 제외
    if (/^\d+$/.test(part)) return false;
    // 필러 단어 제외
    if (ICON_FILLER_WORDS.includes(part.toLowerCase())) return false;
    // 너무 짧은 파트 제외 (1-2글자)
    if (part.length < 3) return false;
    return true;
  });

  if (meaningfulParts.length > 0) {
    // 의미 있는 파트들을 PascalCase로 조합
    // 최대 2개 파트까지만 사용 (너무 길어지는 것 방지)
    const partsToUse = meaningfulParts.slice(0, 2);
    const pascalCase = partsToUse
      .map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase())
      .join('');
    return `Icon/${pascalCase}`;
  }

  // 5. 폴백: 마지막 단어를 PascalCase로 변환
  const lastPart = parts[parts.length - 1];
  const pascalCase = lastPart.charAt(0).toUpperCase() + lastPart.slice(1);

  return `Icon/${pascalCase}`;
}

// ============================================
// 탭 아이템 추론
// ============================================

/**
 * 자식 노드에서 아이콘 이름 추출
 */
function extractIconNameFromChildren(node: SceneNode): string | null {
  if (!('children' in node)) return null;

  const children = (node as ChildrenMixin).children;

  for (const child of children) {
    // 직접 Icon/ 패턴 확인
    if (child.name.startsWith('Icon/')) {
      return child.name.replace('Icon/', '');
    }

    // 재귀적으로 자식 탐색 (1단계만)
    if ('children' in child) {
      const grandChildren = (child as ChildrenMixin).children;
      for (const grandChild of grandChildren) {
        if (grandChild.name.startsWith('Icon/')) {
          return grandChild.name.replace('Icon/', '');
        }
      }
    }
  }

  return null;
}

/**
 * 탭바 아이템에서 자식 아이콘을 기반으로 이름 유추
 */
export function inferTabItemNameFromIcon(node: SceneNode): string | null {
  // TabItem/ 형식인 경우에만 처리
  if (!node.name.startsWith('TabItem/')) return null;

  const iconName = extractIconNameFromChildren(node);
  if (!iconName) return null;

  // 현재 이름과 아이콘 이름이 다르면 아이콘 기반으로 변경
  const currentTabName = node.name.replace('TabItem/', '');
  if (currentTabName !== iconName) {
    return `TabItem/${iconName}`;
  }

  return null;
}

// ============================================
// 도메인/컨텍스트 추출
// ============================================

/**
 * 부모 노드에서 도메인 키워드 추출
 */
export function extractParentDomainKeywords(node: SceneNode): string[] {
  const keywords: string[] = [];
  let parent = node.parent;

  while (parent && 'name' in parent) {
    const parentName = (parent as SceneNode).name;

    // Section/WeeklyChallenge 형식에서 추출
    if (parentName.includes('/')) {
      const afterSlash = parentName.split('/').pop() || '';
      // PascalCase 분리: WeeklyChallenge → Weekly, Challenge
      const parts = afterSlash.split(/(?=[A-Z])/).filter(p => p.length > 0);
      for (const part of parts) {
        if (DOMAIN_KEYWORDS.includes(part) && !keywords.includes(part)) {
          keywords.push(part);
        }
      }
    }

    // 일반 이름에서 도메인 키워드 추출
    for (const keyword of DOMAIN_KEYWORDS) {
      if (parentName.toLowerCase().includes(keyword.toLowerCase()) && !keywords.includes(keyword)) {
        keywords.push(keyword);
      }
    }

    parent = parent.parent;
  }

  return keywords;
}

/**
 * 자식 노드들에서 공통 키워드 추출
 */
function extractDomainKeywordFromChildren(node: SceneNode): string | null {
  if (!('children' in node)) return null;

  const children = (node as ChildrenMixin).children;
  if (children.length === 0) return null;

  // 자식 이름들 수집 (재귀적으로 2단계까지)
  const childNames: string[] = [];

  function collectNames(n: SceneNode, depth: number) {
    childNames.push(n.name);
    if (depth < 2 && 'children' in n) {
      for (const child of (n as ChildrenMixin).children) {
        collectNames(child, depth + 1);
      }
    }
  }

  for (const child of children) {
    collectNames(child, 0);
  }

  // 키워드 빈도 카운트
  const keywordCounts = new Map<string, number>();

  for (const childName of childNames) {
    for (const keyword of DOMAIN_KEYWORDS) {
      if (childName.toLowerCase().includes(keyword.toLowerCase())) {
        keywordCounts.set(keyword, (keywordCounts.get(keyword) || 0) + 1);
      }
    }
  }

  // 가장 빈도가 높은 키워드 반환
  let maxCount = 0;
  let dominantKeyword: string | null = null;

  for (const [keyword, count] of keywordCounts) {
    if (count > maxCount) {
      maxCount = count;
      dominantKeyword = keyword;
    }
  }

  return dominantKeyword;
}

/**
 * 조상 노드에서 컨텍스트 추출
 */
function extractContextFromAncestors(node: SceneNode): string | null {
  // 1. 부모/조상 이름에서 컨텍스트 찾기
  let parent = node.parent;
  while (parent) {
    if ('name' in parent) {
      const parentName = (parent as SceneNode).name.toLowerCase();

      for (const [context, keywords] of Object.entries(CONTEXT_KEYWORDS)) {
        for (const kw of keywords) {
          if (parentName.includes(kw.toLowerCase())) {
            return context;
          }
        }
      }
    }
    parent = parent.parent;
  }

  // 2. 형제 노드들의 위치로 추론 (첫 번째 = Active/Current)
  const nodeParent = node.parent;
  if (nodeParent && 'children' in nodeParent) {
    const siblings = (nodeParent as ChildrenMixin).children;
    const index = siblings.indexOf(node as SceneNode);

    // 첫 번째 자식이면 Active로 추정
    if (index === 0) {
      return 'Active';
    }
  }

  return null;
}

// ============================================
// 구조적 네이밍 추론
// ============================================

/**
 * 부모와 동일한 이름일 때 대체 이름 생성
 * - Content, Inner 등 금지된 폴백 대신 null 반환 (AI에게 위임)
 */
export function generateAlternativeName(_node: SceneNode): string | null {
  // Content, Inner 등 금지 - AI에게 위임
  return null;
}

/**
 * 구조적 레이어 이름으로 변환 시도
 */
export function tryStructuralNaming(node: SceneNode): string | null {
  // 1. 부모와 완전히 동일한 이름이면 대체 이름 생성
  if (hasSameNameAsParent(node)) {
    return generateAlternativeName(node);
  }

  const parentDomains = extractParentDomainKeywords(node);

  // 부모에 도메인 키워드가 없으면 구조적 네이밍 스킵
  if (parentDomains.length === 0) return null;

  // 부모 도메인 제거
  let strippedName = node.name;
  for (const domain of parentDomains) {
    const regex = new RegExp(`\\b${domain}\\b[\\s_-]*`, 'gi');
    strippedName = strippedName.replace(regex, '');
  }
  strippedName = strippedName.replace(/\s+/g, ' ').trim();

  // 남은 이름이 비어있으면 스킵
  if (!strippedName) return null;

  const nameLower = strippedName.toLowerCase().trim();

  // 구조적 이름 매핑에서 찾기
  if (STRUCTURAL_LAYER_NAMES[nameLower]) {
    return STRUCTURAL_LAYER_NAMES[nameLower];
  }

  // 복합 구조적 이름 처리 (e.g., "Info Container" → "Info")
  const words = strippedName.split(/[\s_-]+/);
  if (words.length >= 1) {
    const firstWord = words[0].toLowerCase();
    if (STRUCTURAL_LAYER_NAMES[firstWord]) {
      return STRUCTURAL_LAYER_NAMES[firstWord];
    }

    // 마지막 단어 체크
    const lastWord = words[words.length - 1].toLowerCase();
    if (lastWord === 'container' || lastWord === 'wrapper' || lastWord === 'content') {
      if (words.length > 1) {
        const meaningfulWord = words[0].toLowerCase();
        if (STRUCTURAL_LAYER_NAMES[meaningfulWord]) {
          return STRUCTURAL_LAYER_NAMES[meaningfulWord];
        }
      }
    }
  }

  // 공백 제거 후 PascalCase로 변환 시도
  if (words.length <= 2 && strippedName !== node.name) {
    const pascalCase = words
      .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
      .join('');
    return pascalCase;
  }

  return null;
}

/**
 * 자식 키워드 기반으로 Section 이름 추론
 */
export function inferSectionNameFromChildren(node: SceneNode): string | null {
  // isGenericName 호출 (classify.ts에서)
  if (!isGenericName(node.name)) return null;

  // 부모가 이미 Section/이면 Section 추론 스킵
  let parent = node.parent;
  while (parent && 'name' in parent) {
    const parentName = (parent as SceneNode).name;
    if (parentName.startsWith('Section/')) {
      return null;
    }
    parent = parent.parent;
  }

  // 자식이 없으면 처리하지 않음
  if (!('children' in node)) return null;
  const children = (node as ChildrenMixin).children;
  if (children.length === 0) return null;

  // 1. 자식에서 도메인 키워드 추출
  const domainKeyword = extractDomainKeywordFromChildren(node);
  if (!domainKeyword) return null;

  // 2. 조상에서 컨텍스트 추출
  const context = extractContextFromAncestors(node);

  // 3. Section 이름 생성
  if (context) {
    return `Section/${context}${domainKeyword}`;
  }

  return `Section/${domainKeyword}`;
}

/**
 * 자동 생성 이름에서 의미 있는 이름 추론
 */
export function inferNameForAutoGenerated(node: SceneNode): string | null {
  // isAutoGeneratedName 호출 (classify.ts에서)
  if (!isAutoGeneratedName(node.name)) return null;

  // 1. 자식에서 도메인 키워드 추출 시도
  if ('children' in node) {
    const children = (node as ChildrenMixin).children;

    // 자식이 1개면 AI에게 위임 (Content 폴백 금지)
    if (children.length === 1) {
      return null;
    }

    // 자식이 여러 개면 Section 추론 시도
    if (children.length > 1) {
      const childNames = children.map(c => c.name.toLowerCase());
      const keywords = ['card', 'item', 'list', 'button', 'icon', 'text', 'image'];

      for (const keyword of keywords) {
        const matchCount = childNames.filter(n => n.includes(keyword)).length;
        if (matchCount >= 2) {
          const pascalKeyword = keyword.charAt(0).toUpperCase() + keyword.slice(1);
          return `Section/${pascalKeyword}`;
        }
      }
    }
  }

  // Content 폴백 금지 - AI에게 위임
  return null;
}

// ============================================
// 레이아웃 추론
// ============================================

/**
 * 구조 프레임 이름 추론 (Layout/* 금지)
 */
export function inferLayoutName(node: SceneNode): string | null {
  // isLayoutFrame 호출 (classify.ts에서)
  if (!isLayoutFrame(node)) return null;

  // shouldConvertToLayout 호출 (validate.ts에서)
  if (!shouldConvertToLayout(node)) return null;

  const nameLower = node.name.toLowerCase().trim();

  // 1. 직접 매핑
  if (LAYOUT_KEYWORD_MAP[nameLower]) {
    return LAYOUT_KEYWORD_MAP[nameLower];
  }

  // 2. 부분 매칭으로 역할 추론
  if (nameLower.includes('header') || nameLower.includes('status')) {
    return 'Header/Main';
  }

  if (nameLower.includes('_top') || nameLower.includes('top')) {
    if (!nameLower.includes('tab')) {
      return 'TopBar/Main';
    }
  }

  if (nameLower.includes('main')) {
    return 'Section/Main';
  }

  if (nameLower.includes('bottom') || nameLower.includes('footer') ||
      nameLower.includes('tabbar') || nameLower.includes('tab bar') ||
      nameLower.includes('navbar') || nameLower.includes('navigation')) {
    return 'TabBar/Main';
  }

  if (nameLower.includes('home indicator')) {
    return 'HomeIndicator';
  }

  return null;
}
